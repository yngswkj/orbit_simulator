[{"filePath":"C:\\Users\\yngsw\\dev\\orbit-simulator\\eslint.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\yngsw\\dev\\orbit-simulator\\src\\App.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":13,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":13,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[575,578],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[575,578],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":14,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":14,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[620,623],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[620,623],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"react-hooks/set-state-in-effect","severity":2,"message":"Error: Calling setState synchronously within an effect can trigger cascading renders\n\nEffects are intended to synchronize state between React and external systems such as manually updating the DOM, state management libraries, or other platform APIs. In general, the body of an effect should do one or both of the following:\n* Update external systems with the latest state from React.\n* Subscribe for updates from some external system, calling setState in a callback function when external state changes.\n\nCalling setState synchronously within an effect body causes cascading renders that can hurt performance, and is not recommended. (https://react.dev/learn/you-might-not-need-an-effect).\n\nC:\\Users\\yngsw\\dev\\orbit-simulator\\src\\App.tsx:43:7\n  41 |\n  42 |     if (followedBodyName) {\n> 43 |       setOverlayName(followedBodyName);\n     |       ^^^^^^^^^^^^^^ Avoid calling setState() directly within an effect\n  44 |       setOverlayOpacity(1);\n  45 |\n  46 |       const timer = setTimeout(() => {","line":43,"column":7,"nodeType":null,"endLine":43,"endColumn":21}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useEffect, useState } from 'react';\nimport { Scene } from './components/scene/Scene';\nimport { UnifiedSidePanel } from './components/ui/UnifiedSidePanel';\n// PropertyInspector removed (merged into BodyInspector)\nimport { Tour } from './components/ui/Tour';\nimport { useTranslation } from './utils/i18n';\nimport { usePhysicsStore } from './store/physicsStore';\nimport './App.css';\nimport { runBenchmark, runGPUBenchmark } from './utils/benchmark';\nimport { ToastProvider } from './components/ui/common/Toast';\n\n// Expose runBenchmark to window for testing\n(window as any).runBenchmark = runBenchmark;\n(window as any).runGPUBenchmark = runGPUBenchmark;\n\nfunction App() {\n  const { t } = useTranslation();\n\n  // Keyboard Shortcuts\n  const simulationState = usePhysicsStore(state => state.simulationState);\n  const setSimulationState = usePhysicsStore(state => state.setSimulationState);\n  const bodies = usePhysicsStore(state => state.bodies);\n  const followingBodyId = usePhysicsStore(state => state.followingBodyId);\n  const setFollowingBody = usePhysicsStore(state => state.setFollowingBody);\n  const setCameraMode = usePhysicsStore(state => state.setCameraMode);\n\n  // Get name securely to avoid re-renders on every physics frame\n  const followedBodyName = usePhysicsStore(state =>\n    state.followingBodyId\n      ? state.bodies.find(b => b.id === state.followingBodyId)?.name\n      : null\n  );\n\n  const [overlayName, setOverlayName] = useState<string | null>(null);\n  const [overlayOpacity, setOverlayOpacity] = useState(0);\n\n  const checkGPUSupport = usePhysicsStore(state => state.checkGPUSupport);\n\n  useEffect(() => {\n    checkGPUSupport(); // Check if WebGPU is available\n\n    if (followedBodyName) {\n      setOverlayName(followedBodyName);\n      setOverlayOpacity(1);\n\n      const timer = setTimeout(() => {\n        setOverlayOpacity(0);\n      }, 2000);\n\n      return () => clearTimeout(timer);\n    } else {\n      setOverlayOpacity(0);\n    }\n\n    // Cleanup physics resources on unmount\n    return () => {\n      usePhysicsStore.getState().cleanup();\n    };\n  }, [followedBodyName, checkGPUSupport]);\n\n  useEffect(() => {\n    const handleKeyDown = (e: KeyboardEvent) => {\n      const activeTag = document.activeElement?.tagName.toLowerCase();\n      // Ignore if typing in input or textarea\n      if (activeTag === 'input' || activeTag === 'textarea') return;\n\n      // Spacebar: Toggle Pause/Resume\n      if (e.code === 'Space') {\n        e.preventDefault();\n        setSimulationState(simulationState === 'running' ? 'paused' : 'running');\n      }\n\n      // Undo/Redo\n      if (e.ctrlKey && !e.shiftKey && e.code === 'KeyZ') {\n        e.preventDefault();\n        usePhysicsStore.getState().undo();\n      }\n      if ((e.ctrlKey && e.code === 'KeyY') || (e.ctrlKey && e.shiftKey && e.code === 'KeyZ')) {\n        e.preventDefault();\n        usePhysicsStore.getState().redo();\n      }\n\n      // Shift + Number: Camera Modes\n      if (e.shiftKey) {\n        if (e.code === 'Digit1') setCameraMode('free');\n        if (e.code === 'Digit2' && followingBodyId) setCameraMode('sun_lock');\n        if (e.code === 'Digit3' && followingBodyId) setCameraMode('surface_lock');\n      }\n      // Number (1-9): Toggle Follow Body\n      else if (e.code.startsWith('Digit') && !e.ctrlKey && !e.altKey && !e.metaKey) {\n        const num = Number(e.code.replace('Digit', ''));\n        // Only handle 1-9\n        if (!isNaN(num) && num >= 1 && num <= 9) {\n          const index = num - 1;\n          if (index >= 0 && index < bodies.length) {\n            const targetBody = bodies[index];\n            if (followingBodyId === targetBody.id) {\n              setFollowingBody(null);\n            } else {\n              setFollowingBody(targetBody.id);\n              // Sync Inspector if it's open (selectedBodyId is set)\n              if (usePhysicsStore.getState().selectedBodyId) {\n                usePhysicsStore.getState().selectBody(targetBody.id);\n              }\n            }\n          }\n        }\n      }\n    };\n\n    window.addEventListener('keydown', handleKeyDown);\n    return () => window.removeEventListener('keydown', handleKeyDown);\n  }, [simulationState, setSimulationState, bodies, followingBodyId, setFollowingBody, setCameraMode]);\n\n  return (\n    <ToastProvider>\n      <div style={{ width: '100vw', height: '100vh', overflow: 'hidden', position: 'relative' }}>\n        <Scene />\n\n        <div className=\"app-header\" style={{\n          position: 'absolute',\n          top: 20,\n          left: 20,\n          color: 'white',\n          fontFamily: \"'Inter', sans-serif\",\n          pointerEvents: 'none',\n          textShadow: '0 2px 4px rgba(0,0,0,0.5)',\n          opacity: usePhysicsStore(state => state.zenMode) ? 0 : 1,\n          transition: 'opacity 0.5s ease-in-out'\n        }}>\n          <h1 style={{ margin: 0, fontWeight: 300, fontSize: '2rem', letterSpacing: '-0.02em' }}>{t('app_title')}</h1>\n          <p style={{ margin: 0, opacity: 0.7, fontSize: '0.9rem' }}>{t('app_subtitle')}</p>\n\n          <div style={{\n            marginTop: '10px',\n            fontSize: '2.5rem',\n            fontWeight: 300,\n            opacity: overlayOpacity,\n            transition: 'opacity 0.5s ease-in-out',\n            color: '#3b82f6',\n            textShadow: '0 0 10px rgba(59, 130, 246, 0.5)',\n            letterSpacing: '-0.02em'\n          }}>\n            {overlayName}\n          </div>\n        </div>\n\n        <UnifiedSidePanel />\n\n        <Tour />\n      </div>\n    </ToastProvider>\n  );\n}\n\nexport default App;\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\yngsw\\dev\\orbit-simulator\\src\\components\\effects\\AccretionDisk.tsx","messages":[{"ruleId":"react-hooks/purity","severity":2,"message":"Error: Cannot call impure function during render\n\n`Math.random` is an impure function. Calling an impure function can produce unstable results that update unpredictably when the component happens to re-render. (https://react.dev/reference/rules/components-and-hooks-must-be-pure#components-and-hooks-must-be-idempotent).\n\nC:\\Users\\yngsw\\dev\\orbit-simulator\\src\\components\\effects\\AccretionDisk.tsx:228:23\n  226 |         for (let i = 0; i < particleCount; i++) {\n  227 |             // Logarithmic distribution - more particles near inner edge\n> 228 |             const t = Math.random();\n      |                       ^^^^^^^^^^^^^ Cannot call impure function\n  229 |             const r = innerRadius + (outerRadius - innerRadius) * Math.pow(t, 0.35);\n  230 |             const angle = Math.random() * Math.PI * 2;\n  231 |","line":228,"column":23,"nodeType":null,"endLine":228,"endColumn":36},{"ruleId":"react-hooks/purity","severity":2,"message":"Error: Cannot call impure function during render\n\n`Math.random` is an impure function. Calling an impure function can produce unstable results that update unpredictably when the component happens to re-render. (https://react.dev/reference/rules/components-and-hooks-must-be-pure#components-and-hooks-must-be-idempotent).\n\nC:\\Users\\yngsw\\dev\\orbit-simulator\\src\\components\\effects\\AccretionDisk.tsx:230:27\n  228 |             const t = Math.random();\n  229 |             const r = innerRadius + (outerRadius - innerRadius) * Math.pow(t, 0.35);\n> 230 |             const angle = Math.random() * Math.PI * 2;\n      |                           ^^^^^^^^^^^^^ Cannot call impure function\n  231 |\n  232 |             // Disk thickness varies with radius (thinner near center)\n  233 |             const normalizedR = (r - innerRadius) / (outerRadius - innerRadius);","line":230,"column":27,"nodeType":null,"endLine":230,"endColumn":40},{"ruleId":"react-hooks/purity","severity":2,"message":"Error: Cannot call impure function during render\n\n`Math.random` is an impure function. Calling an impure function can produce unstable results that update unpredictably when the component happens to re-render. (https://react.dev/reference/rules/components-and-hooks-must-be-pure#components-and-hooks-must-be-idempotent).\n\nC:\\Users\\yngsw\\dev\\orbit-simulator\\src\\components\\effects\\AccretionDisk.tsx:235:29\n  233 |             const normalizedR = (r - innerRadius) / (outerRadius - innerRadius);\n  234 |             const thickness = normalizedR * outerRadius * 0.06;\n> 235 |             const height = (Math.random() - 0.5) * thickness;\n      |                             ^^^^^^^^^^^^^ Cannot call impure function\n  236 |\n  237 |             const x = Math.cos(angle) * r;\n  238 |             const z = Math.sin(angle) * r;","line":235,"column":29,"nodeType":null,"endLine":235,"endColumn":42},{"ruleId":"react-hooks/immutability","severity":2,"message":"Error: This value cannot be modified\n\nModifying a value previously passed as an argument to a hook is not allowed. Consider moving the modification before calling the hook.\n\nC:\\Users\\yngsw\\dev\\orbit-simulator\\src\\components\\effects\\AccretionDisk.tsx:332:9\n  330 |\n  331 |         // Update uniforms\n> 332 |         material.uniforms.time.value = state.clock.elapsedTime;\n      |         ^^^^^^^^^^^^^^^^^^^^^^ `material` cannot be modified\n  333 |         photonRingMaterial.uniforms.time.value = state.clock.elapsedTime;\n  334 |\n  335 |         // Animation speeds","line":332,"column":9,"nodeType":null,"endLine":332,"endColumn":31},{"ruleId":"react-hooks/immutability","severity":2,"message":"Error: This value cannot be modified\n\nModifying a value previously passed as an argument to a hook is not allowed. Consider moving the modification before calling the hook.\n\nC:\\Users\\yngsw\\dev\\orbit-simulator\\src\\components\\effects\\AccretionDisk.tsx:333:9\n  331 |         // Update uniforms\n  332 |         material.uniforms.time.value = state.clock.elapsedTime;\n> 333 |         photonRingMaterial.uniforms.time.value = state.clock.elapsedTime;\n      |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `photonRingMaterial` cannot be modified\n  334 |\n  335 |         // Animation speeds\n  336 |         const baseSpeed = 0.15;","line":333,"column":9,"nodeType":null,"endLine":333,"endColumn":41},{"ruleId":"react-hooks/immutability","severity":2,"message":"Error: This value cannot be modified\n\nModifying a value previously passed as an argument to a hook is not allowed. Consider moving the modification before calling the hook.\n\nC:\\Users\\yngsw\\dev\\orbit-simulator\\src\\components\\effects\\AccretionDisk.tsx:367:13\n  365 |             const x = Math.cos(angles[i]) * r;\n  366 |             const z = Math.sin(angles[i]) * r;\n> 367 |             positions[i * 3] = x;\n      |             ^^^^^^^^^ `geometry` cannot be modified\n  368 |             positions[i * 3 + 2] = z;\n  369 |\n  370 |             // Update velocity magnitude (higher at inner edge)","line":367,"column":13,"nodeType":null,"endLine":367,"endColumn":22}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * AccretionDisk.tsx\r\n * Visual representation of an accretion disk around massive objects (black holes, neutron stars)\r\n * Features:\r\n * - Particle system with Keplerian rotation\r\n * - Photon sphere ring (bright ring at ~1.5 Schwarzschild radii)\r\n * - Temperature gradient (inner=hot/blue, outer=cool/red)\r\n */\r\n\r\nimport React, { useRef, useMemo } from 'react';\r\nimport { useFrame, useThree } from '@react-three/fiber';\r\nimport * as THREE from 'three';\r\nimport { usePhysicsStore } from '../../store/physicsStore';\r\n\r\ninterface AccretionDiskProps {\r\n    position: { x: number; y: number; z: number };\r\n    innerRadius: number;\r\n    outerRadius: number;\r\n    rotationSpeed?: number;\r\n    particleCount?: number;\r\n    tilt?: number; // Disk tilt angle in radians\r\n}\r\n\r\n// Disk particle shader with velocity-based stretching\r\nconst diskVertexShader = `\r\n    attribute float size;\r\n    attribute float temperature;\r\n    attribute float velocity;\r\n    attribute vec2 velocityDir;\r\n\r\n    uniform float time;\r\n    uniform float innerRadius;\r\n    uniform float rotationSpeed;\r\n\r\n    varying float vTemperature;\r\n    varying float vDistance;\r\n    varying float vVelocity;\r\n    varying vec2 vVelocityDir;\r\n\r\n    void main() {\r\n        vTemperature = temperature;\r\n        vVelocity = velocity;\r\n        vVelocityDir = velocityDir;\r\n\r\n        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n        vDistance = length(mvPosition.xyz);\r\n\r\n        // Larger particles for stretched effect\r\n        float stretchFactor = 1.0 + velocity * 0.5;\r\n        gl_PointSize = size * stretchFactor * (300.0 / vDistance);\r\n        gl_Position = projectionMatrix * mvPosition;\r\n    }\r\n`;\r\n\r\nconst diskFragmentShader = `\r\n    varying float vTemperature;\r\n    varying float vDistance;\r\n    varying float vVelocity;\r\n    varying vec2 vVelocityDir;\r\n\r\n    vec3 temperatureToColor(float t) {\r\n        // Black body radiation approximation\r\n        if (t > 0.85) {\r\n            // Innermost: Blue-white (very hot)\r\n            return vec3(0.6, 0.8, 1.0) * (1.0 + t * 0.5);\r\n        } else if (t > 0.6) {\r\n            // Hot: White-blue\r\n            return vec3(0.9, 0.95, 1.0) * (0.8 + t * 0.4);\r\n        } else if (t > 0.35) {\r\n            // Medium: Yellow-white\r\n            return vec3(1.0, 0.9, 0.7) * (0.7 + t * 0.3);\r\n        } else if (t > 0.15) {\r\n            // Cool: Orange\r\n            return vec3(1.0, 0.6, 0.3) * (0.6 + t * 0.2);\r\n        } else {\r\n            // Outer: Red-orange (dim)\r\n            return vec3(0.8, 0.3, 0.1) * (0.4 + t * 0.2);\r\n        }\r\n    }\r\n\r\n    void main() {\r\n        vec2 center = gl_PointCoord - vec2(0.5);\r\n\r\n        // Stretch particle in velocity direction (gravitational dragging effect)\r\n        float stretchAmount = 1.0 + vVelocity * 1.5;\r\n        vec2 stretchDir = normalize(vVelocityDir + vec2(0.001));\r\n\r\n        // Rotate and scale the coordinate to create elongated shape\r\n        float cosA = stretchDir.x;\r\n        float sinA = stretchDir.y;\r\n        vec2 rotated = vec2(\r\n            center.x * cosA + center.y * sinA,\r\n            -center.x * sinA + center.y * cosA\r\n        );\r\n\r\n        // Compress along velocity direction, expand perpendicular\r\n        rotated.x *= stretchAmount;\r\n        rotated.y *= 1.0 / sqrt(stretchAmount);\r\n\r\n        float dist = length(rotated);\r\n        if (dist > 0.5) discard;\r\n\r\n        // Tail effect - fade toward the back (opposite velocity direction)\r\n        float tailFade = 1.0 - smoothstep(0.0, 0.4, rotated.x) * vVelocity * 0.5;\r\n\r\n        // Soft edge\r\n        float alpha = smoothstep(0.5, 0.15, dist) * tailFade;\r\n\r\n        // Distance fade\r\n        alpha *= clamp(1.0 - vDistance / 600.0, 0.2, 1.0);\r\n\r\n        vec3 color = temperatureToColor(vTemperature);\r\n\r\n        // Brighter core, dimmer tail\r\n        float coreBrightness = smoothstep(0.3, 0.0, dist);\r\n        float glow = 1.0 + coreBrightness * 0.4;\r\n\r\n        gl_FragColor = vec4(color * glow, alpha * 0.85);\r\n    }\r\n`;\r\n\r\n// Photon sphere ring shader\r\nconst photonRingVertexShader = `\r\n    varying vec3 vNormal;\r\n    varying vec3 vViewDir;\r\n    varying vec2 vUv;\r\n\r\n    void main() {\r\n        vNormal = normalize(normalMatrix * normal);\r\n        vUv = uv;\r\n\r\n        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n        vViewDir = normalize(-mvPosition.xyz);\r\n\r\n        gl_Position = projectionMatrix * mvPosition;\r\n    }\r\n`;\r\n\r\nconst photonRingFragmentShader = `\r\n    uniform float time;\r\n\r\n    varying vec3 vNormal;\r\n    varying vec3 vViewDir;\r\n    varying vec2 vUv;\r\n\r\n    void main() {\r\n        // Fresnel effect for edge glow\r\n        float fresnel = pow(1.0 - abs(dot(vNormal, vViewDir)), 2.0);\r\n\r\n        // Static brightness\r\n        float pulse = 1.0;\r\n        float hotspot = 1.0;\r\n\r\n        // Core brightness\r\n        float core = smoothstep(0.0, 0.3, vUv.y) * smoothstep(1.0, 0.7, vUv.y);\r\n\r\n        float intensity = (fresnel * 0.5 + core * 0.8) * pulse * hotspot;\r\n\r\n        // Color: bright yellow-white core with orange-red edges\r\n        vec3 coreColor = vec3(1.0, 0.95, 0.8);\r\n        vec3 edgeColor = vec3(1.0, 0.6, 0.3);\r\n        vec3 color = mix(edgeColor, coreColor, core);\r\n\r\n        gl_FragColor = vec4(color * intensity * 1.5, intensity * 0.9);\r\n    }\r\n`;\r\n\r\n// Event horizon shader\r\nconst eventHorizonVertexShader = `\r\n    varying vec3 vNormal;\r\n    varying vec3 vViewDir;\r\n\r\n    void main() {\r\n        vNormal = normalize(normalMatrix * normal);\r\n        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n        vViewDir = normalize(-mvPosition.xyz);\r\n        gl_Position = projectionMatrix * mvPosition;\r\n    }\r\n`;\r\n\r\nconst eventHorizonFragmentShader = `\r\n    varying vec3 vNormal;\r\n    varying vec3 vViewDir;\r\n\r\n    void main() {\r\n        // Pure black center with very subtle edge highlight\r\n        float fresnel = pow(1.0 - abs(dot(vNormal, vViewDir)), 4.0);\r\n\r\n        // Extremely subtle purple-ish edge (frame dragging hint)\r\n        vec3 edgeColor = vec3(0.1, 0.05, 0.15) * fresnel;\r\n\r\n        // Mostly black\r\n        gl_FragColor = vec4(edgeColor, 1.0);\r\n    }\r\n`;\r\n\r\nexport const AccretionDisk: React.FC<AccretionDiskProps> = ({\r\n    position,\r\n    innerRadius,\r\n    outerRadius,\r\n    rotationSpeed = 1,\r\n    particleCount = 30000,\r\n    tilt = 0.1\r\n}) => {\r\n    const pointsRef = useRef<THREE.Points>(null);\r\n    const anglesRef = useRef<Float32Array | null>(null);\r\n    const radiiRef = useRef<Float32Array | null>(null);\r\n    const baseRadiiRef = useRef<Float32Array | null>(null); // Original radii for respawn\r\n    const groupRef = useRef<THREE.Group>(null);\r\n    const simulationState = usePhysicsStore(state => state.simulationState);\r\n\r\n    useThree(); // Keep for potential future use\r\n\r\n    // Create particle geometry and material\r\n    const { geometry, material } = useMemo(() => {\r\n        const geo = new THREE.BufferGeometry();\r\n        const positions = new Float32Array(particleCount * 3);\r\n        const sizes = new Float32Array(particleCount);\r\n        const temperatures = new Float32Array(particleCount);\r\n        const velocities = new Float32Array(particleCount);\r\n        const velocityDirs = new Float32Array(particleCount * 2);\r\n        const angles = new Float32Array(particleCount);\r\n        const radii = new Float32Array(particleCount);\r\n        const baseRadii = new Float32Array(particleCount);\r\n\r\n        for (let i = 0; i < particleCount; i++) {\r\n            // Logarithmic distribution - more particles near inner edge\r\n            const t = Math.random();\r\n            const r = innerRadius + (outerRadius - innerRadius) * Math.pow(t, 0.35);\r\n            const angle = Math.random() * Math.PI * 2;\r\n\r\n            // Disk thickness varies with radius (thinner near center)\r\n            const normalizedR = (r - innerRadius) / (outerRadius - innerRadius);\r\n            const thickness = normalizedR * outerRadius * 0.06;\r\n            const height = (Math.random() - 0.5) * thickness;\r\n\r\n            const x = Math.cos(angle) * r;\r\n            const z = Math.sin(angle) * r;\r\n\r\n            positions[i * 3] = x;\r\n            positions[i * 3 + 1] = height;\r\n            positions[i * 3 + 2] = z;\r\n\r\n            angles[i] = angle;\r\n            radii[i] = r;\r\n            baseRadii[i] = r;\r\n\r\n            // Initial velocity (will be updated each frame)\r\n            // Velocity increases toward center (Keplerian)\r\n            const vel = (1 - normalizedR) * 0.8;\r\n            velocities[i] = vel;\r\n\r\n            // Velocity direction (tangent to orbit, slightly inward spiral)\r\n            const tangentAngle = angle + Math.PI / 2;\r\n            velocityDirs[i * 2] = Math.cos(tangentAngle);\r\n            velocityDirs[i * 2 + 1] = Math.sin(tangentAngle);\r\n\r\n            // Temperature: higher at inner edge\r\n            const tempFactor = 1 - normalizedR;\r\n            temperatures[i] = tempFactor;\r\n\r\n            // Size: smaller particles near inner edge (appear brighter)\r\n            sizes[i] = 0.8 + normalizedR * 1.8;\r\n        }\r\n\r\n        geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));\r\n        geo.setAttribute('size', new THREE.BufferAttribute(sizes, 1));\r\n        geo.setAttribute('temperature', new THREE.BufferAttribute(temperatures, 1));\r\n        geo.setAttribute('velocity', new THREE.BufferAttribute(velocities, 1));\r\n        geo.setAttribute('velocityDir', new THREE.BufferAttribute(velocityDirs, 2));\r\n\r\n        anglesRef.current = angles;\r\n        radiiRef.current = radii;\r\n        baseRadiiRef.current = baseRadii;\r\n\r\n        // Shader material\r\n        const mat = new THREE.ShaderMaterial({\r\n            vertexShader: diskVertexShader,\r\n            fragmentShader: diskFragmentShader,\r\n            uniforms: {\r\n                time: { value: 0 },\r\n                innerRadius: { value: innerRadius },\r\n                rotationSpeed: { value: rotationSpeed },\r\n            },\r\n            transparent: true,\r\n            blending: THREE.AdditiveBlending,\r\n            depthWrite: false,\r\n        });\r\n\r\n        return { geometry: geo, material: mat };\r\n    // IMPORTANT: position removed from deps to prevent particle regeneration on every frame\r\n    }, [innerRadius, outerRadius, particleCount, rotationSpeed]);\r\n\r\n    // Photon sphere ring material\r\n    const photonRingMaterial = useMemo(() => {\r\n        return new THREE.ShaderMaterial({\r\n            vertexShader: photonRingVertexShader,\r\n            fragmentShader: photonRingFragmentShader,\r\n            uniforms: {\r\n                time: { value: 0 },\r\n            },\r\n            transparent: true,\r\n            blending: THREE.AdditiveBlending,\r\n            depthWrite: false,\r\n            side: THREE.DoubleSide,\r\n        });\r\n    }, []);\r\n\r\n    // Event horizon material\r\n    const eventHorizonMaterial = useMemo(() => {\r\n        return new THREE.ShaderMaterial({\r\n            vertexShader: eventHorizonVertexShader,\r\n            fragmentShader: eventHorizonFragmentShader,\r\n            uniforms: {},\r\n        });\r\n    }, []);\r\n\r\n    useFrame((state, delta) => {\r\n        if (!pointsRef.current || !anglesRef.current || !radiiRef.current || !baseRadiiRef.current) return;\r\n        if (simulationState !== 'running') return;\r\n\r\n        const positions = geometry.attributes.position.array as Float32Array;\r\n        const velocityAttr = geometry.attributes.velocity.array as Float32Array;\r\n        const velocityDirAttr = geometry.attributes.velocityDir.array as Float32Array;\r\n        const temperatureAttr = geometry.attributes.temperature.array as Float32Array;\r\n        const sizeAttr = geometry.attributes.size.array as Float32Array;\r\n        const angles = anglesRef.current;\r\n        const radii = radiiRef.current;\r\n        const baseRadii = baseRadiiRef.current;\r\n\r\n        // Update uniforms\r\n        material.uniforms.time.value = state.clock.elapsedTime;\r\n        photonRingMaterial.uniforms.time.value = state.clock.elapsedTime;\r\n\r\n        // Animation speeds\r\n        const baseSpeed = 0.15;\r\n        const infallSpeed = 0.02; // Slow spiral infall\r\n\r\n        for (let i = 0; i < particleCount; i++) {\r\n            let r = radii[i];\r\n\r\n            // Normalize radius\r\n            const normalizedR = Math.max(0, (r - innerRadius) / (outerRadius - innerRadius));\r\n\r\n            // Keplerian rotation: inner particles orbit faster\r\n            const speedMultiplier = 1.0 + (1.0 - normalizedR) * 2.0;\r\n            const angularVelocity = rotationSpeed * baseSpeed * speedMultiplier * (innerRadius / r);\r\n            angles[i] += angularVelocity * delta;\r\n\r\n            // Spiral infall: particles slowly move toward center\r\n            // Infall rate increases as particles get closer (gravitational acceleration)\r\n            const infallRate = infallSpeed * (1.0 + (1.0 - normalizedR) * 2.0);\r\n            r -= infallRate * delta;\r\n            radii[i] = r;\r\n\r\n            // Respawn at outer edge when reaching inner boundary\r\n            if (r <= innerRadius * 0.9) {\r\n                // Reset to outer region with new random angle\r\n                radii[i] = baseRadii[i];\r\n                r = baseRadii[i];\r\n                angles[i] = Math.random() * Math.PI * 2;\r\n            }\r\n\r\n            // Update position\r\n            const x = Math.cos(angles[i]) * r;\r\n            const z = Math.sin(angles[i]) * r;\r\n            positions[i * 3] = x;\r\n            positions[i * 3 + 2] = z;\r\n\r\n            // Update velocity magnitude (higher at inner edge)\r\n            const newNormalizedR = (r - innerRadius) / (outerRadius - innerRadius);\r\n            const velocity = Math.min(1.0, (1.0 - newNormalizedR) * 1.2);\r\n            velocityAttr[i] = velocity;\r\n\r\n            // Update velocity direction (tangent + slight inward spiral)\r\n            // Tangent direction with inward component\r\n            const tangentAngle = angles[i] + Math.PI / 2;\r\n            const inwardAngle = angles[i] + Math.PI; // Points toward center\r\n            const spiralMix = 0.15; // How much inward vs tangent\r\n\r\n            const dirX = Math.cos(tangentAngle) * (1 - spiralMix) + Math.cos(inwardAngle) * spiralMix;\r\n            const dirZ = Math.sin(tangentAngle) * (1 - spiralMix) + Math.sin(inwardAngle) * spiralMix;\r\n            const dirLen = Math.sqrt(dirX * dirX + dirZ * dirZ);\r\n\r\n            velocityDirAttr[i * 2] = dirX / dirLen;\r\n            velocityDirAttr[i * 2 + 1] = dirZ / dirLen;\r\n\r\n            // Update temperature (hotter at inner edge)\r\n            temperatureAttr[i] = 1.0 - newNormalizedR;\r\n\r\n            // Update size (smaller at inner edge)\r\n            sizeAttr[i] = 0.8 + newNormalizedR * 1.8;\r\n        }\r\n\r\n        geometry.attributes.position.needsUpdate = true;\r\n        geometry.attributes.velocity.needsUpdate = true;\r\n        geometry.attributes.velocityDir.needsUpdate = true;\r\n        geometry.attributes.temperature.needsUpdate = true;\r\n        geometry.attributes.size.needsUpdate = true;\r\n    });\r\n\r\n    // Photon sphere radius (1.5 Schwarzschild radii equivalent)\r\n    const photonSphereRadius = innerRadius * 0.5;\r\n\r\n    return (\r\n        <group\r\n            ref={groupRef}\r\n            position={[position.x, position.y, position.z]}\r\n            rotation={[tilt, 0, 0]}\r\n        >\r\n            {/* Main accretion disk particles */}\r\n            <points ref={pointsRef} geometry={geometry} material={material} />\r\n\r\n            {/* Photon Sphere Ring - The characteristic bright ring */}\r\n            <mesh rotation={[Math.PI / 2, 0, 0]}>\r\n                <torusGeometry args={[photonSphereRadius, photonSphereRadius * 0.15, 16, 64]} />\r\n                <primitive object={photonRingMaterial} attach=\"material\" />\r\n            </mesh>\r\n\r\n            {/* Secondary photon ring (inner) */}\r\n            <mesh rotation={[Math.PI / 2, 0, 0]}>\r\n                <torusGeometry args={[photonSphereRadius * 0.7, photonSphereRadius * 0.08, 12, 48]} />\r\n                <meshBasicMaterial\r\n                    color=\"#ffffff\"\r\n                    transparent\r\n                    opacity={0.4}\r\n                    blending={THREE.AdditiveBlending}\r\n                />\r\n            </mesh>\r\n\r\n            {/* Inner glow - ISCO region */}\r\n            <mesh>\r\n                <sphereGeometry args={[innerRadius * 0.6, 32, 16]} />\r\n                <meshBasicMaterial\r\n                    color=\"#ffddaa\"\r\n                    transparent\r\n                    opacity={0.25}\r\n                    blending={THREE.AdditiveBlending}\r\n                />\r\n            </mesh>\r\n\r\n            {/* Event horizon with subtle edge effect */}\r\n            <mesh>\r\n                <sphereGeometry args={[innerRadius * 0.25, 32, 32]} />\r\n                <primitive object={eventHorizonMaterial} attach=\"material\" />\r\n            </mesh>\r\n\r\n            {/* Shadow silhouette (slightly larger than event horizon) */}\r\n            <mesh>\r\n                <sphereGeometry args={[innerRadius * 0.35, 32, 32]} />\r\n                <meshBasicMaterial color=\"#000000\" transparent opacity={0.95} />\r\n            </mesh>\r\n        </group>\r\n    );\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\yngsw\\dev\\orbit-simulator\\src\\components\\effects\\DebrisRenderer.tsx","messages":[{"ruleId":"react-hooks/purity","severity":2,"message":"Error: Cannot call impure function during render\n\n`Math.random` is an impure function. Calling an impure function can produce unstable results that update unpredictably when the component happens to re-render. (https://react.dev/reference/rules/components-and-hooks-must-be-pure#components-and-hooks-must-be-idempotent).\n\nC:\\Users\\yngsw\\dev\\orbit-simulator\\src\\components\\effects\\DebrisRenderer.tsx:36:33\n  34 |             const y = pos.getY(i);\n  35 |             const z = pos.getZ(i);\n> 36 |             const noise = 0.7 + Math.random() * 0.6;\n     |                                 ^^^^^^^^^^^^^ Cannot call impure function\n  37 |             pos.setXYZ(i, x * noise, y * noise, z * noise);\n  38 |         }\n  39 |         geo.computeVertexNormals();","line":36,"column":33,"nodeType":null,"endLine":36,"endColumn":46},{"ruleId":"react-hooks/immutability","severity":2,"message":"Error: This value cannot be modified\n\nModifying a value previously passed as an argument to a hook is not allowed. Consider moving the modification before calling the hook.\n\nC:\\Users\\yngsw\\dev\\orbit-simulator\\src\\components\\effects\\DebrisRenderer.tsx:83:13\n  81 |\n  82 |             // Rotation (tumbling)\n> 83 |             dummy.rotation.x += p.rotationSpeed.x * delta;\n     |             ^^^^^^^^^^^^^^ `dummy` cannot be modified\n  84 |             dummy.rotation.y += p.rotationSpeed.y * delta;\n  85 |             dummy.rotation.z += p.rotationSpeed.z * delta;\n  86 |","line":83,"column":13,"nodeType":null,"endLine":83,"endColumn":27}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * DebrisRenderer.tsx\r\n * Efficient rendering of debris particles using instanced mesh\r\n */\r\n\r\nimport React, { useRef, useMemo, useEffect } from 'react';\r\nimport { useFrame } from '@react-three/fiber';\r\nimport { useEffectsStore } from '../../store/effectsStore';\r\nimport * as THREE from 'three';\r\nimport { EFFECT_CONSTANTS } from '../../constants/physics';\r\n\r\nconst MAX_DEBRIS = EFFECT_CONSTANTS.MAX_DEBRIS_PARTICLES;\r\n\r\nexport const DebrisRenderer: React.FC = () => {\r\n    const debrisClouds = useEffectsStore(state => state.debrisClouds);\r\n    const updateDebris = useEffectsStore(state => state.updateDebris);\r\n    const removeExpiredDebris = useEffectsStore(state => state.removeExpiredDebris);\r\n\r\n    const meshRef = useRef<THREE.InstancedMesh>(null);\r\n    const lastCleanup = useRef(0);\r\n\r\n    // Dummy object for matrix calculations\r\n    const dummy = useMemo(() => new THREE.Object3D(), []);\r\n\r\n    // Create geometry and material\r\n    const geometry = useMemo(() => {\r\n        // Irregular rock-like shape\r\n        const geo = new THREE.IcosahedronGeometry(1, 0);\r\n\r\n        // Deform vertices for more irregular shape\r\n        const pos = geo.attributes.position;\r\n        for (let i = 0; i < pos.count; i++) {\r\n            const x = pos.getX(i);\r\n            const y = pos.getY(i);\r\n            const z = pos.getZ(i);\r\n            const noise = 0.7 + Math.random() * 0.6;\r\n            pos.setXYZ(i, x * noise, y * noise, z * noise);\r\n        }\r\n        geo.computeVertexNormals();\r\n\r\n        return geo;\r\n    }, []);\r\n\r\n    const material = useMemo(() => {\r\n        return new THREE.MeshStandardMaterial({\r\n            roughness: 0.9,\r\n            metalness: 0.1,\r\n            flatShading: true\r\n        });\r\n    }, []);\r\n\r\n    // Get all particles flattened\r\n    const allParticles = useMemo(() => {\r\n        return debrisClouds.flatMap(c => c.particles).slice(0, MAX_DEBRIS);\r\n    }, [debrisClouds]);\r\n\r\n    // Update instance matrices and colors\r\n    useFrame((_, delta) => {\r\n        if (!meshRef.current) return;\r\n\r\n        const now = performance.now();\r\n\r\n        // Update physics\r\n        updateDebris(delta);\r\n\r\n        // Periodic cleanup\r\n        if (now - lastCleanup.current > 2000) {\r\n            removeExpiredDebris();\r\n            lastCleanup.current = now;\r\n        }\r\n\r\n        // Update instances\r\n        const count = Math.min(allParticles.length, MAX_DEBRIS);\r\n\r\n        for (let i = 0; i < count; i++) {\r\n            const p = allParticles[i];\r\n            const age = (now - p.createdAt) / p.lifetime;\r\n\r\n            // Position\r\n            dummy.position.set(p.position.x, p.position.y, p.position.z);\r\n\r\n            // Rotation (tumbling)\r\n            dummy.rotation.x += p.rotationSpeed.x * delta;\r\n            dummy.rotation.y += p.rotationSpeed.y * delta;\r\n            dummy.rotation.z += p.rotationSpeed.z * delta;\r\n\r\n            // Scale (shrink as it ages)\r\n            const scale = p.size * (1 - age * 0.5);\r\n            dummy.scale.setScalar(Math.max(scale, 0.01));\r\n\r\n            dummy.updateMatrix();\r\n            meshRef.current.setMatrixAt(i, dummy.matrix);\r\n\r\n            // Color with gamma-corrected fade for more natural color transition\r\n            const color = new THREE.Color(p.color);\r\n            const fade = Math.pow(1 - age, EFFECT_CONSTANTS.GAMMA_CORRECTION) * 0.7 + 0.3;\r\n            color.multiplyScalar(fade);\r\n            meshRef.current.setColorAt(i, color);\r\n        }\r\n\r\n        // Hide unused instances\r\n        for (let i = count; i < MAX_DEBRIS; i++) {\r\n            dummy.scale.setScalar(0);\r\n            dummy.updateMatrix();\r\n            meshRef.current.setMatrixAt(i, dummy.matrix);\r\n        }\r\n\r\n        meshRef.current.instanceMatrix.needsUpdate = true;\r\n        if (meshRef.current.instanceColor) {\r\n            meshRef.current.instanceColor.needsUpdate = true;\r\n        }\r\n        meshRef.current.count = count;\r\n    });\r\n\r\n    // Initialize instance color attribute\r\n    useEffect(() => {\r\n        if (meshRef.current && !meshRef.current.instanceColor) {\r\n            const colors = new Float32Array(MAX_DEBRIS * 3);\r\n            meshRef.current.instanceColor = new THREE.InstancedBufferAttribute(colors, 3);\r\n        }\r\n    }, []);\r\n\r\n    if (allParticles.length === 0) return null;\r\n\r\n    return (\r\n        <instancedMesh\r\n            ref={meshRef}\r\n            args={[geometry, material, MAX_DEBRIS]}\r\n            frustumCulled={false}\r\n        />\r\n    );\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\yngsw\\dev\\orbit-simulator\\src\\components\\effects\\EffectsLayer.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\yngsw\\dev\\orbit-simulator\\src\\components\\effects\\ExplosionEffect.tsx","messages":[{"ruleId":"react-hooks/purity","severity":2,"message":"Error: Cannot call impure function during render\n\n`Math.random` is an impure function. Calling an impure function can produce unstable results that update unpredictably when the component happens to re-render. (https://react.dev/reference/rules/components-and-hooks-must-be-pure#components-and-hooks-must-be-idempotent).\n\nC:\\Users\\yngsw\\dev\\orbit-simulator\\src\\components\\effects\\ExplosionEffect.tsx:53:27\n  51 |\n  52 |             // Random velocity (spherical distribution)\n> 53 |             const theta = Math.random() * Math.PI * 2;\n     |                           ^^^^^^^^^^^^^ Cannot call impure function\n  54 |             const phi = Math.acos(2 * Math.random() - 1);\n  55 |             const speed = size * (0.5 + Math.random() * 1.5);\n  56 |","line":53,"column":27,"nodeType":null,"endLine":53,"endColumn":40},{"ruleId":"react-hooks/purity","severity":2,"message":"Error: Cannot call impure function during render\n\n`Math.random` is an impure function. Calling an impure function can produce unstable results that update unpredictably when the component happens to re-render. (https://react.dev/reference/rules/components-and-hooks-must-be-pure#components-and-hooks-must-be-idempotent).\n\nC:\\Users\\yngsw\\dev\\orbit-simulator\\src\\components\\effects\\ExplosionEffect.tsx:54:39\n  52 |             // Random velocity (spherical distribution)\n  53 |             const theta = Math.random() * Math.PI * 2;\n> 54 |             const phi = Math.acos(2 * Math.random() - 1);\n     |                                       ^^^^^^^^^^^^^ Cannot call impure function\n  55 |             const speed = size * (0.5 + Math.random() * 1.5);\n  56 |\n  57 |             vels.push(new THREE.Vector3(","line":54,"column":39,"nodeType":null,"endLine":54,"endColumn":52},{"ruleId":"react-hooks/purity","severity":2,"message":"Error: Cannot call impure function during render\n\n`Math.random` is an impure function. Calling an impure function can produce unstable results that update unpredictably when the component happens to re-render. (https://react.dev/reference/rules/components-and-hooks-must-be-pure#components-and-hooks-must-be-idempotent).\n\nC:\\Users\\yngsw\\dev\\orbit-simulator\\src\\components\\effects\\ExplosionEffect.tsx:55:41\n  53 |             const theta = Math.random() * Math.PI * 2;\n  54 |             const phi = Math.acos(2 * Math.random() - 1);\n> 55 |             const speed = size * (0.5 + Math.random() * 1.5);\n     |                                         ^^^^^^^^^^^^^ Cannot call impure function\n  56 |\n  57 |             vels.push(new THREE.Vector3(\n  58 |                 Math.sin(phi) * Math.cos(theta) * speed,","line":55,"column":41,"nodeType":null,"endLine":55,"endColumn":54},{"ruleId":"react-hooks/purity","severity":2,"message":"Error: Cannot call impure function during render\n\n`Math.random` is an impure function. Calling an impure function can produce unstable results that update unpredictably when the component happens to re-render. (https://react.dev/reference/rules/components-and-hooks-must-be-pure#components-and-hooks-must-be-idempotent).\n\nC:\\Users\\yngsw\\dev\\orbit-simulator\\src\\components\\effects\\ExplosionEffect.tsx:64:38\n  62 |\n  63 |             // Color gradient: center particles brighter\n> 64 |             const brightness = 0.5 + Math.random() * 0.5;\n     |                                      ^^^^^^^^^^^^^ Cannot call impure function\n  65 |             const particleColor = new THREE.Color().lerpColors(baseColor, brightColor, Math.random() * 0.5);\n  66 |\n  67 |             colors[i * 3] = particleColor.r * brightness;","line":64,"column":38,"nodeType":null,"endLine":64,"endColumn":51},{"ruleId":"react-hooks/purity","severity":2,"message":"Error: Cannot call impure function during render\n\n`Math.random` is an impure function. Calling an impure function can produce unstable results that update unpredictably when the component happens to re-render. (https://react.dev/reference/rules/components-and-hooks-must-be-pure#components-and-hooks-must-be-idempotent).\n\nC:\\Users\\yngsw\\dev\\orbit-simulator\\src\\components\\effects\\ExplosionEffect.tsx:65:88\n  63 |             // Color gradient: center particles brighter\n  64 |             const brightness = 0.5 + Math.random() * 0.5;\n> 65 |             const particleColor = new THREE.Color().lerpColors(baseColor, brightColor, Math.random() * 0.5);\n     |                                                                                        ^^^^^^^^^^^^^ Cannot call impure function\n  66 |\n  67 |             colors[i * 3] = particleColor.r * brightness;\n  68 |             colors[i * 3 + 1] = particleColor.g * brightness;","line":65,"column":88,"nodeType":null,"endLine":65,"endColumn":101},{"ruleId":"react-hooks/purity","severity":2,"message":"Error: Cannot call impure function during render\n\n`Math.random` is an impure function. Calling an impure function can produce unstable results that update unpredictably when the component happens to re-render. (https://react.dev/reference/rules/components-and-hooks-must-be-pure#components-and-hooks-must-be-idempotent).\n\nC:\\Users\\yngsw\\dev\\orbit-simulator\\src\\components\\effects\\ExplosionEffect.tsx:72:55\n  70 |\n  71 |             // Random sizes\n> 72 |             const particleSize = size * 0.05 * (0.3 + Math.random() * 0.7);\n     |                                                       ^^^^^^^^^^^^^ Cannot call impure function\n  73 |             sizes[i] = particleSize;\n  74 |             initSizes.push(particleSize);\n  75 |         }","line":72,"column":55,"nodeType":null,"endLine":72,"endColumn":68},{"ruleId":"react-hooks/immutability","severity":2,"message":"Error: This value cannot be modified\n\nModifying a value previously passed as an argument to a hook is not allowed. Consider moving the modification before calling the hook.\n\nC:\\Users\\yngsw\\dev\\orbit-simulator\\src\\components\\effects\\ExplosionEffect.tsx:118:17\n  116 |             for (let i = 0; i < particleCount; i++) {\n  117 |                 // Update position\n> 118 |                 positions[i * 3] += velocities[i].x * dt;\n      |                 ^^^^^^^^^ `geometry` cannot be modified\n  119 |                 positions[i * 3 + 1] += velocities[i].y * dt + gravity * dt;\n  120 |                 positions[i * 3 + 2] += velocities[i].z * dt;\n  121 |","line":118,"column":17,"nodeType":null,"endLine":118,"endColumn":26}],"suppressedMessages":[],"errorCount":7,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * ExplosionEffect.tsx\r\n * Particle-based explosion with flash, sparks, and smoke\r\n */\r\n\r\nimport React, { useRef, useMemo } from 'react';\r\nimport { useFrame } from '@react-three/fiber';\r\nimport * as THREE from 'three';\r\nimport { EFFECT_CONSTANTS } from '../../constants/physics';\r\n\r\ninterface ExplosionEffectProps {\r\n    position: { x: number; y: number; z: number };\r\n    startTime: number;\r\n    duration: number;\r\n    size: number;\r\n    color: string;\r\n    particleCount: number;\r\n    onComplete?: () => void;\r\n}\r\n\r\nexport const ExplosionEffect: React.FC<ExplosionEffectProps> = ({\r\n    position,\r\n    startTime,\r\n    duration,\r\n    size,\r\n    color,\r\n    particleCount,\r\n    onComplete\r\n}) => {\r\n    const pointsRef = useRef<THREE.Points>(null);\r\n    const flashRef = useRef<THREE.Mesh>(null);\r\n    const completedRef = useRef(false);\r\n\r\n    // Initialize particles\r\n    const { geometry, velocities, initialSizes } = useMemo(() => {\r\n        const geo = new THREE.BufferGeometry();\r\n        const positions = new Float32Array(particleCount * 3);\r\n        const colors = new Float32Array(particleCount * 3);\r\n        const sizes = new Float32Array(particleCount);\r\n        const vels: THREE.Vector3[] = [];\r\n        const initSizes: number[] = [];\r\n\r\n        const baseColor = new THREE.Color(color);\r\n        const brightColor = new THREE.Color('#ffffff');\r\n\r\n        for (let i = 0; i < particleCount; i++) {\r\n            // Start at center\r\n            positions[i * 3] = position.x;\r\n            positions[i * 3 + 1] = position.y;\r\n            positions[i * 3 + 2] = position.z;\r\n\r\n            // Random velocity (spherical distribution)\r\n            const theta = Math.random() * Math.PI * 2;\r\n            const phi = Math.acos(2 * Math.random() - 1);\r\n            const speed = size * (0.5 + Math.random() * 1.5);\r\n\r\n            vels.push(new THREE.Vector3(\r\n                Math.sin(phi) * Math.cos(theta) * speed,\r\n                Math.sin(phi) * Math.sin(theta) * speed,\r\n                Math.cos(phi) * speed\r\n            ));\r\n\r\n            // Color gradient: center particles brighter\r\n            const brightness = 0.5 + Math.random() * 0.5;\r\n            const particleColor = new THREE.Color().lerpColors(baseColor, brightColor, Math.random() * 0.5);\r\n\r\n            colors[i * 3] = particleColor.r * brightness;\r\n            colors[i * 3 + 1] = particleColor.g * brightness;\r\n            colors[i * 3 + 2] = particleColor.b * brightness;\r\n\r\n            // Random sizes\r\n            const particleSize = size * 0.05 * (0.3 + Math.random() * 0.7);\r\n            sizes[i] = particleSize;\r\n            initSizes.push(particleSize);\r\n        }\r\n\r\n        geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));\r\n        geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));\r\n        geo.setAttribute('size', new THREE.BufferAttribute(sizes, 1));\r\n\r\n        return { geometry: geo, velocities: vels, initialSizes: initSizes };\r\n    }, [position, size, color, particleCount]);\r\n\r\n    useFrame(() => {\r\n        if (completedRef.current) return;\r\n\r\n        const elapsed = performance.now() - startTime;\r\n        const progress = Math.min(elapsed / duration, 1);\r\n\r\n        if (progress >= 1 && !completedRef.current) {\r\n            completedRef.current = true;\r\n            onComplete?.();\r\n            return;\r\n        }\r\n\r\n        // Update flash (bright sphere that fades quickly)\r\n        if (flashRef.current) {\r\n            const flashProgress = Math.min(elapsed / (duration * 0.3), 1);\r\n            const flashScale = size * 2 * (1 - flashProgress * 0.5);\r\n            flashRef.current.scale.setScalar(flashScale);\r\n\r\n            const material = flashRef.current.material as THREE.MeshBasicMaterial;\r\n            material.opacity = (1 - flashProgress) * 0.9;\r\n        }\r\n\r\n        // Update particles\r\n        if (pointsRef.current) {\r\n            const positions = geometry.attributes.position.array as Float32Array;\r\n            const sizes = geometry.attributes.size.array as Float32Array;\r\n            const colors = geometry.attributes.color.array as Float32Array;\r\n\r\n            const dt = EFFECT_CONSTANTS.FRAME_TIME;\r\n            const drag = 0.98;\r\n            const gravity = -0.02 * size;\r\n\r\n            for (let i = 0; i < particleCount; i++) {\r\n                // Update position\r\n                positions[i * 3] += velocities[i].x * dt;\r\n                positions[i * 3 + 1] += velocities[i].y * dt + gravity * dt;\r\n                positions[i * 3 + 2] += velocities[i].z * dt;\r\n\r\n                // Apply drag\r\n                velocities[i].multiplyScalar(drag);\r\n\r\n                // Shrink particles over time\r\n                sizes[i] = initialSizes[i] * (1 - progress * 0.8);\r\n\r\n                // Gamma-corrected fade for more natural color transition\r\n                const gammaFade = Math.pow(1 - progress, EFFECT_CONSTANTS.GAMMA_CORRECTION);\r\n                colors[i * 3] *= 0.995 * (0.7 + 0.3 * gammaFade);\r\n                colors[i * 3 + 1] *= 0.99 * (0.7 + 0.3 * gammaFade);\r\n                colors[i * 3 + 2] *= 0.98 * (0.7 + 0.3 * gammaFade);\r\n            }\r\n\r\n            geometry.attributes.position.needsUpdate = true;\r\n            geometry.attributes.size.needsUpdate = true;\r\n            geometry.attributes.color.needsUpdate = true;\r\n        }\r\n    });\r\n\r\n    return (\r\n        <group>\r\n            {/* Central flash */}\r\n            <mesh ref={flashRef} position={[position.x, position.y, position.z]}>\r\n                <sphereGeometry args={[1, 16, 16]} />\r\n                <meshBasicMaterial\r\n                    color=\"#ffffff\"\r\n                    transparent\r\n                    opacity={1}\r\n                    depthWrite={false}\r\n                    blending={THREE.AdditiveBlending}\r\n                />\r\n            </mesh>\r\n\r\n            {/* Particles */}\r\n            <points ref={pointsRef} geometry={geometry}>\r\n                <pointsMaterial\r\n                    vertexColors\r\n                    transparent\r\n                    opacity={1}\r\n                    sizeAttenuation\r\n                    depthWrite={false}\r\n                    blending={THREE.AdditiveBlending}\r\n                />\r\n            </points>\r\n        </group>\r\n    );\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\yngsw\\dev\\orbit-simulator\\src\\components\\effects\\GravitationalLensEffect.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'_renderer' is defined but never used.","line":106,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":106,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'_inputBuffer' is defined but never used.","line":107,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":107,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'_deltaTime' is defined but never used.","line":108,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":108,"endColumn":19}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * GravitationalLensEffect.tsx\r\n * Post-processing gravitational lensing effect that distorts the background\r\n * Uses screen-space distortion based on black hole positions\r\n */\r\n\r\nimport { forwardRef, useMemo, useImperativeHandle } from 'react';\r\nimport { useFrame } from '@react-three/fiber';\r\nimport { Effect } from 'postprocessing';\r\nimport { Uniform, Vector2, Vector3, Camera } from 'three';\r\n\r\n// Custom shader for gravitational lensing\r\nconst fragmentShader = `\r\nuniform vec2 blackHoleScreen;\r\nuniform float lensStrength;\r\nuniform float schwarzschildRadius;\r\nuniform float aspectRatio;\r\n\r\nvoid mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {\r\n    // Adjust UV for aspect ratio\r\n    vec2 adjustedUV = uv;\r\n    adjustedUV.x *= aspectRatio;\r\n\r\n    vec2 adjustedBH = blackHoleScreen;\r\n    adjustedBH.x *= aspectRatio;\r\n\r\n    // Vector from pixel to black hole center\r\n    vec2 toBH = adjustedBH - adjustedUV;\r\n    float dist = length(toBH);\r\n\r\n    // Gravitational lensing formula (simplified)\r\n    // Light bends toward the black hole, stronger near the event horizon\r\n    float eventHorizon = schwarzschildRadius * 0.5;\r\n    float photonSphere = schwarzschildRadius * 1.5;\r\n\r\n    // Skip if too far (optimization)\r\n    if (dist > schwarzschildRadius * 8.0) {\r\n        outputColor = inputColor;\r\n        return;\r\n    }\r\n\r\n    // Einstein ring effect - light wraps around\r\n    float bendStrength = 0.0;\r\n\r\n    if (dist > eventHorizon) {\r\n        // Outside event horizon: bend light toward black hole\r\n        // Strength falls off with distance squared (inverse square law)\r\n        float normalizedDist = dist / schwarzschildRadius;\r\n        bendStrength = lensStrength / (normalizedDist * normalizedDist);\r\n\r\n        // Extra bending near photon sphere\r\n        if (dist < photonSphere * 2.0) {\r\n            float photonFactor = 1.0 - smoothstep(photonSphere, photonSphere * 2.0, dist);\r\n            bendStrength *= (1.0 + photonFactor * 2.0);\r\n        }\r\n    }\r\n\r\n    // Apply distortion - pull UV toward black hole center\r\n    vec2 bendDir = normalize(toBH);\r\n    vec2 distortedUV = uv + bendDir * bendStrength * 0.1;\r\n\r\n    // Undo aspect ratio adjustment for sampling\r\n    distortedUV.x = clamp(distortedUV.x, 0.0, 1.0);\r\n    distortedUV.y = clamp(distortedUV.y, 0.0, 1.0);\r\n\r\n    // Sample the distorted position\r\n    vec4 distortedColor = texture2D(inputBuffer, distortedUV);\r\n\r\n    // Darken near event horizon (light cannot escape)\r\n    float darkenFactor = 1.0;\r\n    if (dist < eventHorizon * 1.2) {\r\n        darkenFactor = smoothstep(eventHorizon * 0.8, eventHorizon * 1.2, dist);\r\n    }\r\n\r\n    // Add subtle blue-shift effect near the black hole (gravitational blueshift)\r\n    vec3 finalColor = distortedColor.rgb * darkenFactor;\r\n    if (dist < photonSphere * 3.0) {\r\n        float blueShift = (1.0 - dist / (photonSphere * 3.0)) * 0.15;\r\n        finalColor.b += blueShift;\r\n        finalColor.r -= blueShift * 0.5;\r\n    }\r\n\r\n    outputColor = vec4(finalColor, distortedColor.a);\r\n}\r\n`;\r\n\r\n// Custom postprocessing Effect class\r\nclass GravitationalLensEffectImpl extends Effect {\r\n    constructor({\r\n        blackHoleScreen = new Vector2(0.5, 0.5),\r\n        lensStrength = 1.0,\r\n        schwarzschildRadius = 0.05,\r\n        aspectRatio = 1.0,\r\n    } = {}) {\r\n        super('GravitationalLensEffect', fragmentShader, {\r\n            uniforms: new Map<string, Uniform>([\r\n                ['blackHoleScreen', new Uniform(blackHoleScreen)],\r\n                ['lensStrength', new Uniform(lensStrength)],\r\n                ['schwarzschildRadius', new Uniform(schwarzschildRadius)],\r\n                ['aspectRatio', new Uniform(aspectRatio)],\r\n            ]),\r\n        });\r\n    }\r\n\r\n    update(\r\n        _renderer: unknown,\r\n        _inputBuffer: unknown,\r\n        _deltaTime: number\r\n    ) {\r\n        // Updates are handled externally\r\n    }\r\n}\r\n\r\n// Props for the React component\r\ninterface GravitationalLensEffectProps {\r\n    blackHolePosition: Vector3;\r\n    schwarzschildRadius: number;\r\n    strength?: number;\r\n    camera: Camera;\r\n    enabled?: boolean;\r\n}\r\n\r\n// React component wrapper\r\nexport const GravitationalLensEffect = forwardRef<\r\n    GravitationalLensEffectImpl,\r\n    GravitationalLensEffectProps\r\n>(({ blackHolePosition, schwarzschildRadius, strength = 1.0, camera, enabled = true }, ref) => {\r\n    const effect = useMemo(() => {\r\n        return new GravitationalLensEffectImpl({\r\n            lensStrength: strength,\r\n        });\r\n    }, [strength]);\r\n\r\n    // Update uniforms every frame based on camera position\r\n    useFrame(() => {\r\n        if (!camera) return;\r\n\r\n        // Always set lensStrength based on enabled state\r\n        effect.uniforms.get('lensStrength')!.value = enabled ? strength : 0;\r\n\r\n        // Skip calculations if disabled\r\n        if (!enabled) return;\r\n\r\n        // Project 3D position to screen space (0-1)\r\n        const screenPos = blackHolePosition.clone().project(camera);\r\n\r\n        // Convert from NDC (-1 to 1) to UV (0 to 1)\r\n        const screenUV = new Vector2(\r\n            (screenPos.x + 1) / 2,\r\n            (screenPos.y + 1) / 2\r\n        );\r\n\r\n        // Calculate screen-space radius based on distance\r\n        const distance = camera.position.distanceTo(blackHolePosition);\r\n        const screenRadius = Math.min(0.3, schwarzschildRadius / distance * 2);\r\n\r\n        // Get aspect ratio\r\n        const aspect = window.innerWidth / window.innerHeight;\r\n\r\n        effect.uniforms.get('blackHoleScreen')!.value = screenUV;\r\n        effect.uniforms.get('schwarzschildRadius')!.value = screenRadius;\r\n        effect.uniforms.get('aspectRatio')!.value = aspect;\r\n    });\r\n\r\n    // Expose the effect instance via ref\r\n    useImperativeHandle(ref, () => effect, [effect]);\r\n\r\n    return <primitive object={effect} />;\r\n});\r\n\r\nGravitationalLensEffect.displayName = 'GravitationalLensEffect';\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\yngsw\\dev\\orbit-simulator\\src\\components\\effects\\HeatGlowEffect.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\yngsw\\dev\\orbit-simulator\\src\\components\\effects\\RelativisticJet.tsx","messages":[{"ruleId":"react-hooks/purity","severity":2,"message":"Error: Cannot call impure function during render\n\n`Math.random` is an impure function. Calling an impure function can produce unstable results that update unpredictably when the component happens to re-render. (https://react.dev/reference/rules/components-and-hooks-must-be-pure#components-and-hooks-must-be-idempotent).\n\nC:\\Users\\yngsw\\dev\\orbit-simulator\\src\\components\\effects\\RelativisticJet.tsx:91:23\n  89 |\n  90 |             // Random progress along jet (0 = base, 1 = tip)\n> 91 |             const t = Math.random();\n     |                       ^^^^^^^^^^^^^ Cannot call impure function\n  92 |             progress[i] = t;\n  93 |\n  94 |             // Individual speed variation (0.5x to 1.5x base speed)","line":91,"column":23,"nodeType":null,"endLine":91,"endColumn":36},{"ruleId":"react-hooks/purity","severity":2,"message":"Error: Cannot call impure function during render\n\n`Math.random` is an impure function. Calling an impure function can produce unstable results that update unpredictably when the component happens to re-render. (https://react.dev/reference/rules/components-and-hooks-must-be-pure#components-and-hooks-must-be-idempotent).\n\nC:\\Users\\yngsw\\dev\\orbit-simulator\\src\\components\\effects\\RelativisticJet.tsx:95:31\n  93 |\n  94 |             // Individual speed variation (0.5x to 1.5x base speed)\n> 95 |             speeds[i] = 0.5 + Math.random();\n     |                               ^^^^^^^^^^^^^ Cannot call impure function\n  96 |\n  97 |             // Jet expands as it travels\n  98 |             const spreadRadius = baseWidth * (0.1 + t * 0.5);","line":95,"column":31,"nodeType":null,"endLine":95,"endColumn":44},{"ruleId":"react-hooks/purity","severity":2,"message":"Error: Cannot call impure function during render\n\n`Math.random` is an impure function. Calling an impure function can produce unstable results that update unpredictably when the component happens to re-render. (https://react.dev/reference/rules/components-and-hooks-must-be-pure#components-and-hooks-must-be-idempotent).\n\nC:\\Users\\yngsw\\dev\\orbit-simulator\\src\\components\\effects\\RelativisticJet.tsx:99:27\n   97 |             // Jet expands as it travels\n   98 |             const spreadRadius = baseWidth * (0.1 + t * 0.5);\n>  99 |             const angle = Math.random() * Math.PI * 2;\n      |                           ^^^^^^^^^^^^^ Cannot call impure function\n  100 |             const r = Math.random() * spreadRadius;\n  101 |\n  102 |             spread[i] = r;","line":99,"column":27,"nodeType":null,"endLine":99,"endColumn":40},{"ruleId":"react-hooks/purity","severity":2,"message":"Error: Cannot call impure function during render\n\n`Math.random` is an impure function. Calling an impure function can produce unstable results that update unpredictably when the component happens to re-render. (https://react.dev/reference/rules/components-and-hooks-must-be-pure#components-and-hooks-must-be-idempotent).\n\nC:\\Users\\yngsw\\dev\\orbit-simulator\\src\\components\\effects\\RelativisticJet.tsx:100:23\n   98 |             const spreadRadius = baseWidth * (0.1 + t * 0.5);\n   99 |             const angle = Math.random() * Math.PI * 2;\n> 100 |             const r = Math.random() * spreadRadius;\n      |                       ^^^^^^^^^^^^^ Cannot call impure function\n  101 |\n  102 |             spread[i] = r;\n  103 |             angles[i] = angle;","line":100,"column":23,"nodeType":null,"endLine":100,"endColumn":36},{"ruleId":"react-hooks/immutability","severity":2,"message":"Error: This value cannot be modified\n\nModifying a value previously passed as an argument to a hook is not allowed. Consider moving the modification before calling the hook.\n\nC:\\Users\\yngsw\\dev\\orbit-simulator\\src\\components\\effects\\RelativisticJet.tsx:177:13\n  175 |             const z = Math.sin(angles[i]) * currentSpread;\n  176 |\n> 177 |             positions[i * 3] = x;\n      |             ^^^^^^^^^ `geometry` cannot be modified\n  178 |             positions[i * 3 + 1] = y;\n  179 |             positions[i * 3 + 2] = z;\n  180 |","line":177,"column":13,"nodeType":null,"endLine":177,"endColumn":22}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * RelativisticJet.tsx\r\n * Visual representation of bipolar relativistic jets from compact objects\r\n * Particles stream from poles in opposite directions\r\n */\r\n\r\nimport React, { useRef, useMemo } from 'react';\r\nimport { useFrame } from '@react-three/fiber';\r\nimport * as THREE from 'three';\r\nimport { usePhysicsStore } from '../../store/physicsStore';\r\n\r\ninterface RelativisticJetProps {\r\n    position: { x: number; y: number; z: number };\r\n    length: number;\r\n    baseWidth: number;\r\n    particleCount?: number;\r\n    speed?: number;\r\n    color?: string;\r\n}\r\n\r\nconst jetVertexShader = `\r\n    attribute float size;\r\n    attribute float alpha;\r\n\r\n    varying float vAlpha;\r\n\r\n    void main() {\r\n        vAlpha = alpha;\r\n\r\n        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n        float distance = length(mvPosition.xyz);\r\n\r\n        gl_PointSize = size * (200.0 / distance);\r\n        gl_Position = projectionMatrix * mvPosition;\r\n    }\r\n`;\r\n\r\nconst jetFragmentShader = `\r\n    uniform vec3 jetColor;\r\n    varying float vAlpha;\r\n\r\n    void main() {\r\n        // Circular particle\r\n        vec2 center = gl_PointCoord - vec2(0.5);\r\n        float dist = length(center);\r\n        if (dist > 0.5) discard;\r\n\r\n        // Soft glow\r\n        float alpha = smoothstep(0.5, 0.0, dist) * vAlpha;\r\n\r\n        // Core is brighter\r\n        float core = smoothstep(0.3, 0.0, dist);\r\n        vec3 color = jetColor + vec3(core * 0.5);\r\n\r\n        gl_FragColor = vec4(color, alpha);\r\n    }\r\n`;\r\n\r\nexport const RelativisticJet: React.FC<RelativisticJetProps> = ({\r\n    position,\r\n    length,\r\n    baseWidth,\r\n    particleCount = 8000,\r\n    speed = 1,\r\n    color = '#4488ff'\r\n}) => {\r\n    const pointsRef = useRef<THREE.Points>(null);\r\n    const progressRef = useRef<Float32Array | null>(null);\r\n    const spreadRef = useRef<Float32Array | null>(null);\r\n    const angleRef = useRef<Float32Array | null>(null);\r\n    const speedRef = useRef<Float32Array | null>(null);\r\n    const simulationState = usePhysicsStore(state => state.simulationState);\r\n\r\n    const { geometry, material } = useMemo(() => {\r\n        const geo = new THREE.BufferGeometry();\r\n        const positions = new Float32Array(particleCount * 3);\r\n        const sizes = new Float32Array(particleCount);\r\n        const alphas = new Float32Array(particleCount);\r\n        const progress = new Float32Array(particleCount);\r\n        const spread = new Float32Array(particleCount);\r\n        const angles = new Float32Array(particleCount);\r\n        const speeds = new Float32Array(particleCount); // Individual speeds\r\n\r\n        const halfCount = particleCount / 2;\r\n\r\n        for (let i = 0; i < particleCount; i++) {\r\n            // Direction: first half goes up (+Y), second half goes down (-Y)\r\n            const direction = i < halfCount ? 1 : -1;\r\n\r\n            // Random progress along jet (0 = base, 1 = tip)\r\n            const t = Math.random();\r\n            progress[i] = t;\r\n\r\n            // Individual speed variation (0.5x to 1.5x base speed)\r\n            speeds[i] = 0.5 + Math.random();\r\n\r\n            // Jet expands as it travels\r\n            const spreadRadius = baseWidth * (0.1 + t * 0.5);\r\n            const angle = Math.random() * Math.PI * 2;\r\n            const r = Math.random() * spreadRadius;\r\n\r\n            spread[i] = r;\r\n            angles[i] = angle;\r\n\r\n            const x = Math.cos(angle) * r;\r\n            const y = t * length * direction;\r\n            const z = Math.sin(angle) * r;\r\n\r\n            positions[i * 3] = x;\r\n            positions[i * 3 + 1] = y;\r\n            positions[i * 3 + 2] = z;\r\n\r\n            // Smaller and dimmer at tip\r\n            sizes[i] = 2.0 * (1 - t * 0.7);\r\n            alphas[i] = 0.8 * (1 - t * 0.6);\r\n        }\r\n\r\n        geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));\r\n        geo.setAttribute('size', new THREE.BufferAttribute(sizes, 1));\r\n        geo.setAttribute('alpha', new THREE.BufferAttribute(alphas, 1));\r\n\r\n        progressRef.current = progress;\r\n        spreadRef.current = spread;\r\n        angleRef.current = angles;\r\n        speedRef.current = speeds;\r\n\r\n        const mat = new THREE.ShaderMaterial({\r\n            vertexShader: jetVertexShader,\r\n            fragmentShader: jetFragmentShader,\r\n            uniforms: {\r\n                jetColor: { value: new THREE.Color(color) }\r\n            },\r\n            transparent: true,\r\n            blending: THREE.AdditiveBlending,\r\n            depthWrite: false,\r\n        });\r\n\r\n        return { geometry: geo, material: mat };\r\n    }, [length, baseWidth, particleCount, color]);\r\n\r\n    useFrame((_, delta) => {\r\n        if (!pointsRef.current || !progressRef.current || !spreadRef.current || !angleRef.current || !speedRef.current) return;\r\n        if (simulationState !== 'running') return;\r\n\r\n        const positions = geometry.attributes.position.array as Float32Array;\r\n        const alphas = geometry.attributes.alpha.array as Float32Array;\r\n        const sizes = geometry.attributes.size.array as Float32Array;\r\n        const progress = progressRef.current;\r\n        const spread = spreadRef.current;\r\n        const angles = angleRef.current;\r\n        const speeds = speedRef.current;\r\n\r\n        const halfCount = particleCount / 2;\r\n\r\n        for (let i = 0; i < particleCount; i++) {\r\n            const direction = i < halfCount ? 1 : -1;\r\n\r\n            // Move particle along jet with individual speed\r\n            progress[i] += delta * speed * 0.3 * speeds[i];\r\n\r\n            // Reset when reaching tip\r\n            if (progress[i] > 1) {\r\n                progress[i] = 0;\r\n                spread[i] = Math.random() * baseWidth * 0.1;\r\n                angles[i] = Math.random() * Math.PI * 2;\r\n                speeds[i] = 0.5 + Math.random(); // Re-randomize speed\r\n            }\r\n\r\n            const t = progress[i];\r\n\r\n            // Expand spread as particle moves\r\n            const currentSpread = spread[i] * (0.5 + t * 1.5);\r\n            const x = Math.cos(angles[i]) * currentSpread;\r\n            const y = t * length * direction;\r\n            const z = Math.sin(angles[i]) * currentSpread;\r\n\r\n            positions[i * 3] = x;\r\n            positions[i * 3 + 1] = y;\r\n            positions[i * 3 + 2] = z;\r\n\r\n            // Fade and shrink at tip\r\n            alphas[i] = 0.8 * (1 - t * 0.7);\r\n            sizes[i] = 2.0 * (1 - t * 0.5);\r\n        }\r\n\r\n        geometry.attributes.position.needsUpdate = true;\r\n        geometry.attributes.alpha.needsUpdate = true;\r\n        geometry.attributes.size.needsUpdate = true;\r\n    });\r\n\r\n    return (\r\n        <group position={[position.x, position.y, position.z]}>\r\n            <points ref={pointsRef} geometry={geometry} material={material} />\r\n\r\n            {/* Base glow at origin */}\r\n            <mesh>\r\n                <sphereGeometry args={[baseWidth * 0.3, 16, 8]} />\r\n                <meshBasicMaterial\r\n                    color={color}\r\n                    transparent\r\n                    opacity={0.5}\r\n                    blending={THREE.AdditiveBlending}\r\n                />\r\n            </mesh>\r\n        </group>\r\n    );\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\yngsw\\dev\\orbit-simulator\\src\\components\\effects\\ShockwaveEffect.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\yngsw\\dev\\orbit-simulator\\src\\components\\effects\\TidalDisruptionEffect.tsx","messages":[{"ruleId":"react-hooks/purity","severity":2,"message":"Error: Cannot call impure function during render\n\n`Math.random` is an impure function. Calling an impure function can produce unstable results that update unpredictably when the component happens to re-render. (https://react.dev/reference/rules/components-and-hooks-must-be-pure#components-and-hooks-must-be-idempotent).\n\nC:\\Users\\yngsw\\dev\\orbit-simulator\\src\\components\\effects\\TidalDisruptionEffect.tsx:53:27\n  51 |         for (let i = 0; i < PARTICLE_COUNT; i++) {\n  52 |             // \n> 53 |             const theta = Math.random() * Math.PI * 2;\n     |                           ^^^^^^^^^^^^^ Cannot call impure function\n  54 |             const phi = Math.acos(2 * Math.random() - 1);\n  55 |             const r = bodyRadius * (0.8 + Math.random() * 0.4);\n  56 |","line":53,"column":27,"nodeType":null,"endLine":53,"endColumn":40},{"ruleId":"react-hooks/purity","severity":2,"message":"Error: Cannot call impure function during render\n\n`Math.random` is an impure function. Calling an impure function can produce unstable results that update unpredictably when the component happens to re-render. (https://react.dev/reference/rules/components-and-hooks-must-be-pure#components-and-hooks-must-be-idempotent).\n\nC:\\Users\\yngsw\\dev\\orbit-simulator\\src\\components\\effects\\TidalDisruptionEffect.tsx:54:39\n  52 |             // \n  53 |             const theta = Math.random() * Math.PI * 2;\n> 54 |             const phi = Math.acos(2 * Math.random() - 1);\n     |                                       ^^^^^^^^^^^^^ Cannot call impure function\n  55 |             const r = bodyRadius * (0.8 + Math.random() * 0.4);\n  56 |\n  57 |             const x = r * Math.sin(phi) * Math.cos(theta);","line":54,"column":39,"nodeType":null,"endLine":54,"endColumn":52},{"ruleId":"react-hooks/purity","severity":2,"message":"Error: Cannot call impure function during render\n\n`Math.random` is an impure function. Calling an impure function can produce unstable results that update unpredictably when the component happens to re-render. (https://react.dev/reference/rules/components-and-hooks-must-be-pure#components-and-hooks-must-be-idempotent).\n\nC:\\Users\\yngsw\\dev\\orbit-simulator\\src\\components\\effects\\TidalDisruptionEffect.tsx:55:43\n  53 |             const theta = Math.random() * Math.PI * 2;\n  54 |             const phi = Math.acos(2 * Math.random() - 1);\n> 55 |             const r = bodyRadius * (0.8 + Math.random() * 0.4);\n     |                                           ^^^^^^^^^^^^^ Cannot call impure function\n  56 |\n  57 |             const x = r * Math.sin(phi) * Math.cos(theta);\n  58 |             const y = r * Math.sin(phi) * Math.sin(theta);","line":55,"column":43,"nodeType":null,"endLine":55,"endColumn":56},{"ruleId":"react-hooks/purity","severity":2,"message":"Error: Cannot call impure function during render\n\n`Math.random` is an impure function. Calling an impure function can produce unstable results that update unpredictably when the component happens to re-render. (https://react.dev/reference/rules/components-and-hooks-must-be-pure#components-and-hooks-must-be-idempotent).\n\nC:\\Users\\yngsw\\dev\\orbit-simulator\\src\\components\\effects\\TidalDisruptionEffect.tsx:75:77\n  73 |             // \n  74 |             // \n> 75 |             const tidalSpeed = escapeVelocity * tidalForceStrength * (0.3 + Math.random() * 0.7);\n     |                                                                             ^^^^^^^^^^^^^ Cannot call impure function\n  76 |             const vel = tidalDir.clone().multiplyScalar(dot * tidalSpeed);\n  77 |\n  78 |             // ","line":75,"column":77,"nodeType":null,"endLine":75,"endColumn":90},{"ruleId":"react-hooks/purity","severity":2,"message":"Error: Cannot call impure function during render\n\n`Math.random` is an impure function. Calling an impure function can produce unstable results that update unpredictably when the component happens to re-render. (https://react.dev/reference/rules/components-and-hooks-must-be-pure#components-and-hooks-must-be-idempotent).\n\nC:\\Users\\yngsw\\dev\\orbit-simulator\\src\\components\\effects\\TidalDisruptionEffect.tsx:83:61\n  81 |                 .crossVectors(toPrimary, tidalDir)\n  82 |                 .normalize()\n> 83 |                 .multiplyScalar(orbitalSpeed * 0.3 * (0.5 + Math.random() * 0.5));\n     |                                                             ^^^^^^^^^^^^^ Cannot call impure function\n  84 |             vel.add(tangent);\n  85 |\n  86 |             vels.push(vel);","line":83,"column":61,"nodeType":null,"endLine":83,"endColumn":74},{"ruleId":"react-hooks/purity","severity":2,"message":"Error: Cannot call impure function during render\n\n`Math.random` is an impure function. Calling an impure function can produce unstable results that update unpredictably when the component happens to re-render. (https://react.dev/reference/rules/components-and-hooks-must-be-pure#components-and-hooks-must-be-idempotent).\n\nC:\\Users\\yngsw\\dev\\orbit-simulator\\src\\components\\effects\\TidalDisruptionEffect.tsx:89:42\n  87 |\n  88 |             // \n> 89 |             const colorVariation = 0.7 + Math.random() * 0.3;\n     |                                          ^^^^^^^^^^^^^ Cannot call impure function\n  90 |             colors[i * 3] = baseColor.r * colorVariation;\n  91 |             colors[i * 3 + 1] = baseColor.g * colorVariation;\n  92 |             colors[i * 3 + 2] = baseColor.b * colorVariation;","line":89,"column":42,"nodeType":null,"endLine":89,"endColumn":55},{"ruleId":"react-hooks/purity","severity":2,"message":"Error: Cannot call impure function during render\n\n`Math.random` is an impure function. Calling an impure function can produce unstable results that update unpredictably when the component happens to re-render. (https://react.dev/reference/rules/components-and-hooks-must-be-pure#components-and-hooks-must-be-idempotent).\n\nC:\\Users\\yngsw\\dev\\orbit-simulator\\src\\components\\effects\\TidalDisruptionEffect.tsx:94:51\n  92 |             colors[i * 3 + 2] = baseColor.b * colorVariation;\n  93 |\n> 94 |             sizes[i] = bodyRadius * 0.02 * (0.5 + Math.random());\n     |                                                   ^^^^^^^^^^^^^ Cannot call impure function\n  95 |         }\n  96 |\n  97 |         geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));","line":94,"column":51,"nodeType":null,"endLine":94,"endColumn":64},{"ruleId":"react-hooks/immutability","severity":2,"message":"Error: This value cannot be modified\n\nModifying a value previously passed as an argument to a hook is not allowed. Consider moving the modification before calling the hook.\n\nC:\\Users\\yngsw\\dev\\orbit-simulator\\src\\components\\effects\\TidalDisruptionEffect.tsx:120:13\n  118 |         for (let i = 0; i < PARTICLE_COUNT; i++) {\n  119 |             // \n> 120 |             positions[i * 3] += velocities[i].x * EFFECT_CONSTANTS.FRAME_TIME;\n      |             ^^^^^^^^^ `geometry` cannot be modified\n  121 |             positions[i * 3 + 1] += velocities[i].y * EFFECT_CONSTANTS.FRAME_TIME;\n  122 |             positions[i * 3 + 2] += velocities[i].z * EFFECT_CONSTANTS.FRAME_TIME;\n  123 |","line":120,"column":13,"nodeType":null,"endLine":120,"endColumn":22}],"suppressedMessages":[],"errorCount":8,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useRef, useMemo } from 'react';\r\nimport { useFrame } from '@react-three/fiber';\r\nimport * as THREE from 'three';\r\nimport { EFFECT_CONSTANTS, PHYSICS_CONSTANTS } from '../../constants/physics';\r\n\r\ninterface TidalDisruptionEffectProps {\r\n    position: THREE.Vector3;\r\n    primaryPosition: THREE.Vector3;\r\n    bodyRadius: number;\r\n    bodyColor: string;\r\n    primaryMass: number;\r\n    startTime: number;\r\n    duration?: number;\r\n    onComplete?: () => void;\r\n}\r\n\r\nconst PARTICLE_COUNT = EFFECT_CONSTANTS.MAX_TIDAL_PARTICLES;\r\n\r\nexport const TidalDisruptionEffect: React.FC<TidalDisruptionEffectProps> = ({\r\n    position,\r\n    primaryPosition,\r\n    bodyRadius,\r\n    bodyColor,\r\n    primaryMass,\r\n    startTime,\r\n    duration = 5000,\r\n    onComplete\r\n}) => {\r\n    const pointsRef = useRef<THREE.Points>(null);\r\n    const startTimeRef = useRef(startTime);\r\n\r\n    // \r\n    const { geometry, velocities } = useMemo(() => {\r\n        const geo = new THREE.BufferGeometry();\r\n        const positions = new Float32Array(PARTICLE_COUNT * 3);\r\n        const colors = new Float32Array(PARTICLE_COUNT * 3);\r\n        const sizes = new Float32Array(PARTICLE_COUNT);\r\n        const vels: THREE.Vector3[] = [];\r\n\r\n        const baseColor = new THREE.Color(bodyColor);\r\n        const toPrimary = new THREE.Vector3()\r\n            .subVectors(primaryPosition, position);\r\n        const distance = toPrimary.length();\r\n        toPrimary.normalize();\r\n\r\n        // \r\n        // v_escape = sqrt(2 * G * M / r)\r\n        const G = PHYSICS_CONSTANTS.G;\r\n        const escapeVelocity = Math.sqrt(2 * G * primaryMass / distance);\r\n\r\n        for (let i = 0; i < PARTICLE_COUNT; i++) {\r\n            // \r\n            const theta = Math.random() * Math.PI * 2;\r\n            const phi = Math.acos(2 * Math.random() - 1);\r\n            const r = bodyRadius * (0.8 + Math.random() * 0.4);\r\n\r\n            const x = r * Math.sin(phi) * Math.cos(theta);\r\n            const y = r * Math.sin(phi) * Math.sin(theta);\r\n            const z = r * Math.cos(phi);\r\n\r\n            positions[i * 3] = position.x + x;\r\n            positions[i * 3 + 1] = position.y + y;\r\n            positions[i * 3 + 2] = position.z + z;\r\n\r\n            // /\r\n            const tidalDir = new THREE.Vector3(x, y, z).normalize();\r\n            const dot = tidalDir.dot(toPrimary);\r\n\r\n            // 3\r\n            // F_tidal  2 * G * M * R / r\r\n            const tidalForceStrength = (2 * G * primaryMass * bodyRadius) / Math.pow(distance, 3);\r\n\r\n            // \r\n            // \r\n            const tidalSpeed = escapeVelocity * tidalForceStrength * (0.3 + Math.random() * 0.7);\r\n            const vel = tidalDir.clone().multiplyScalar(dot * tidalSpeed);\r\n\r\n            // \r\n            const orbitalSpeed = Math.sqrt(G * primaryMass / distance);\r\n            const tangent = new THREE.Vector3()\r\n                .crossVectors(toPrimary, tidalDir)\r\n                .normalize()\r\n                .multiplyScalar(orbitalSpeed * 0.3 * (0.5 + Math.random() * 0.5));\r\n            vel.add(tangent);\r\n\r\n            vels.push(vel);\r\n\r\n            // \r\n            const colorVariation = 0.7 + Math.random() * 0.3;\r\n            colors[i * 3] = baseColor.r * colorVariation;\r\n            colors[i * 3 + 1] = baseColor.g * colorVariation;\r\n            colors[i * 3 + 2] = baseColor.b * colorVariation;\r\n\r\n            sizes[i] = bodyRadius * 0.02 * (0.5 + Math.random());\r\n        }\r\n\r\n        geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));\r\n        geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));\r\n        geo.setAttribute('size', new THREE.BufferAttribute(sizes, 1));\r\n\r\n        return { geometry: geo, velocities: vels };\r\n    }, [position, primaryPosition, bodyRadius, bodyColor, primaryMass]);\r\n\r\n    useFrame(() => {\r\n        if (!pointsRef.current) return;\r\n\r\n        const elapsed = (performance.now() - startTimeRef.current);\r\n        const progress = Math.min(elapsed / duration, 1);\r\n\r\n        if (progress >= 1) {\r\n            onComplete?.();\r\n            return;\r\n        }\r\n\r\n        const positions = geometry.attributes.position.array as Float32Array;\r\n        const sizes = geometry.attributes.size.array as Float32Array;\r\n\r\n        for (let i = 0; i < PARTICLE_COUNT; i++) {\r\n            // \r\n            positions[i * 3] += velocities[i].x * EFFECT_CONSTANTS.FRAME_TIME;\r\n            positions[i * 3 + 1] += velocities[i].y * EFFECT_CONSTANTS.FRAME_TIME;\r\n            positions[i * 3 + 2] += velocities[i].z * EFFECT_CONSTANTS.FRAME_TIME;\r\n\r\n            // \r\n            velocities[i].multiplyScalar(EFFECT_CONSTANTS.PARTICLE_DRAG);\r\n\r\n            // \r\n            sizes[i] *= (1 - progress * 0.01);\r\n        }\r\n\r\n        geometry.attributes.position.needsUpdate = true;\r\n        geometry.attributes.size.needsUpdate = true;\r\n\r\n        // \r\n        const material = pointsRef.current.material as THREE.PointsMaterial;\r\n        material.opacity = 1 - progress * 0.8;\r\n    });\r\n\r\n    return (\r\n        <points ref={pointsRef} geometry={geometry}>\r\n            <pointsMaterial\r\n                vertexColors\r\n                transparent\r\n                opacity={1}\r\n                sizeAttenuation\r\n                depthWrite={false}\r\n                blending={THREE.AdditiveBlending}\r\n            />\r\n        </points>\r\n    );\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\yngsw\\dev\\orbit-simulator\\src\\components\\effects\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\yngsw\\dev\\orbit-simulator\\src\\components\\scene\\CelestialBody.tsx","messages":[{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useTexture\" is called conditionally. React Hooks must be called in the exact same order in every component render.","line":20,"column":21,"nodeType":"Identifier","endLine":20,"endColumn":31},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":109,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":109,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4199,4202],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4199,4202],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":110,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":110,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4245,4248],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4245,4248],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":175,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":175,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7136,7139],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7136,7139],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useMemo } from 'react';\r\nimport { useFrame } from '@react-three/fiber';\r\nimport { Sphere, useTexture, Line, Html } from '@react-three/drei';\r\nimport { usePhysicsStore } from '../../store/physicsStore';\r\nimport type { CelestialBody as BodyType } from '../../types/physics';\r\nimport { Vector3, CatmullRomCurve3 } from 'three';\r\nimport { AccretionDisk } from '../effects/AccretionDisk';\r\nimport { RelativisticJet } from '../effects/RelativisticJet';\r\nimport { ProceduralPlanet } from './ProceduralPlanet';\r\n\r\ninterface CelestialBodyProps {\r\n    body: BodyType;\r\n}\r\n\r\n// Separate component since useTexture suspends\r\nconst TextureOrb = ({ body }: { body: BodyType }) => {\r\n    const texturePath = body.texturePath;\r\n    if (!texturePath) return null;\r\n\r\n    const texture = useTexture(texturePath);\r\n\r\n    return (\r\n        <meshStandardMaterial\r\n            map={texture}\r\n            emissiveMap={body.isStar ? texture : undefined}\r\n            emissive={body.isStar ? 'white' : 'black'}\r\n            emissiveIntensity={body.isStar ? 2.0 : 0.0}\r\n            roughness={1}\r\n            metalness={0}\r\n        />\r\n    );\r\n};\r\n\r\n// Trail configuration\r\nconst TRAIL_CONFIG = {\r\n    RECENT_MAX: 60,\r\n    RECENT_INTERVAL: 2,\r\n    COMPRESSED_MAX: 120,\r\n    COMPRESS_RATIO: 4,\r\n    COMPRESS_TRIGGER: 80\r\n};\r\n\r\n// Spline interpolation for smooth curves (memoized)\r\nconst useSplinePoints = (controlPoints: Vector3[], segments: number): Vector3[] => {\r\n    return useMemo(() => {\r\n        if (controlPoints.length < 4) return controlPoints;\r\n        try {\r\n            const curve = new CatmullRomCurve3(controlPoints, false, 'catmullrom', 0.5);\r\n            return curve.getPoints(segments);\r\n        } catch {\r\n            return controlPoints;\r\n        }\r\n    }, [controlPoints, segments]);\r\n};\r\n\r\n// Internal component for constant width trail with LOD compression\r\nconst ConstantWidthTrail = ({ position, color }: { position: Vector3, color: string }) => {\r\n    const recentPoints = React.useRef<Vector3[]>([]);\r\n    const compressedPoints = React.useRef<Vector3[]>([]);\r\n    const [renderPoints, setRenderPoints] = React.useState<Vector3[]>([]);\r\n    const frameCount = React.useRef(0);\r\n    const useRealisticDistances = usePhysicsStore(state => state.useRealisticDistances);\r\n    const resetToken = usePhysicsStore(state => state.resetToken);\r\n    const simulationState = usePhysicsStore(state => state.simulationState);\r\n\r\n    React.useEffect(() => {\r\n        recentPoints.current = [];\r\n        compressedPoints.current = [];\r\n        setRenderPoints([]);\r\n    }, [useRealisticDistances, resetToken]);\r\n\r\n    useFrame(() => {\r\n        if (simulationState !== 'running') return;\r\n        frameCount.current++;\r\n        if (frameCount.current % TRAIL_CONFIG.RECENT_INTERVAL === 0) {\r\n            recentPoints.current.push(position.clone());\r\n            if (recentPoints.current.length > TRAIL_CONFIG.COMPRESS_TRIGGER) {\r\n                const toCompress = recentPoints.current.splice(0, TRAIL_CONFIG.COMPRESS_TRIGGER - TRAIL_CONFIG.RECENT_MAX);\r\n                for (let i = 0; i < toCompress.length; i += TRAIL_CONFIG.COMPRESS_RATIO) {\r\n                    compressedPoints.current.push(toCompress[i]);\r\n                }\r\n                while (compressedPoints.current.length > TRAIL_CONFIG.COMPRESSED_MAX) {\r\n                    compressedPoints.current.shift();\r\n                }\r\n            }\r\n            setRenderPoints([...compressedPoints.current, ...recentPoints.current]);\r\n        }\r\n    });\r\n\r\n    const smoothPoints = useSplinePoints(renderPoints, Math.min(renderPoints.length * 2, 400));\r\n    if (smoothPoints.length < 2) return null;\r\n\r\n    return (\r\n        <Line\r\n            points={smoothPoints}\r\n            color={color}\r\n            lineWidth={2.5}\r\n            opacity={0.6}\r\n            transparent\r\n        />\r\n    );\r\n};\r\n\r\nexport const CelestialBody: React.FC<CelestialBodyProps> = ({ body }) => {\r\n    const showRealistic = usePhysicsStore(state => state.showRealisticVisuals);\r\n    const showGrid = usePhysicsStore(state => state.showGrid);\r\n    const simulationTime = usePhysicsStore(state => state.simulationTime);\r\n\r\n    const groupRef = React.useRef<any>(null);\r\n    const meshRef = React.useRef<any>(null);\r\n\r\n    const positionVector = useMemo(() => new Vector3(body.position.x, body.position.y, body.position.z), [body.position]);\r\n\r\n    const tiltRadians = useMemo(() => {\r\n        return (body.axialTilt || 0) * (Math.PI / 180);\r\n    }, [body.axialTilt]);\r\n\r\n    // Helper to Determine Planet Type\r\n    const planetType = useMemo(() => {\r\n        if (body.mass > 200) return 'gas_giant';\r\n\r\n        // Special exclusions/overrides based on name\r\n        const nameLower = body.name.toLowerCase();\r\n\r\n        // Explicit types for Solar System\r\n        if (nameLower.includes('sun')) return 'star'; // Should be handled by body.isStar but just in case\r\n        if (nameLower.includes('mercury')) return 'rocky';\r\n        if (nameLower.includes('venus')) return 'terrestrial'; // Or 'rocky' with atmosphere override? Let's use terrestrial for now or add 'venusian' later\r\n        if (nameLower.includes('earth')) return 'terrestrial';\r\n        if (nameLower.includes('mars')) return 'rocky';\r\n        if (nameLower.includes('jupiter') || nameLower.includes('saturn') || nameLower.includes('uranus') || nameLower.includes('neptune')) return 'gas_giant';\r\n\r\n        // Moons\r\n        if (nameLower.includes('moon') || nameLower.includes('luna')) return 'rocky';\r\n        if (nameLower.includes('europa') || nameLower.includes('enceladus') || nameLower.includes('pluto')) return 'ice';\r\n        if (nameLower.includes('io') || nameLower.includes('volcano')) return 'molten';\r\n\r\n        // Distance / Density heuristics for unknown bodies\r\n        const dist = Math.sqrt(body.position.x ** 2 + body.position.z ** 2);\r\n\r\n        // Very close to sun -> Molten (only if extremely close, e.g. < 0.3 AU => < 15 units)\r\n        if (dist < 15) return 'molten';\r\n\r\n        // Far from sun -> Ice\r\n        if (dist > 800 && body.mass < 100) return 'ice';\r\n\r\n        // Default small body logic\r\n        if (body.mass < 0.2) return 'rocky';\r\n\r\n        return 'terrestrial';\r\n    }, [body.mass, body.position.x, body.position.z, body.name]);\r\n\r\n    const [trailReady, setTrailReady] = React.useState(false);\r\n    React.useEffect(() => {\r\n        const timer = setTimeout(() => {\r\n            setTrailReady(true);\r\n        }, 600);\r\n        return () => clearTimeout(timer);\r\n    }, []);\r\n\r\n    useFrame(() => {\r\n        if (meshRef.current && body.rotationSpeed) {\r\n            const EARTH_YEAR_RAD = 2300;\r\n            meshRef.current.rotation.y = (body.rotationSpeed * simulationTime * EARTH_YEAR_RAD);\r\n        }\r\n    });\r\n\r\n    const selectBody = usePhysicsStore(state => state.selectBody);\r\n    const cameraMode = usePhysicsStore(state => state.cameraMode);\r\n    const followingBodyId = usePhysicsStore(state => state.followingBodyId);\r\n\r\n    const isSurfaceView = cameraMode === 'surface_lock';\r\n    const isSelf = isSurfaceView && followingBodyId === body.id;\r\n\r\n    const handleClick = (e: any) => {\r\n        if (isSurfaceView) return;\r\n        e.stopPropagation();\r\n        selectBody(body.id);\r\n    };\r\n\r\n    // Display Logic:\r\n    // 1. If showRealistic AND texturePath exists -> Use TextureOrb (Sphere)\r\n    // 2. Else -> Use Shader (ProceduralPlanet) OR Emissive Sphere (for Stars/Compact without texture override)\r\n\r\n    const shouldUseTexture = showRealistic && !!body.texturePath;\r\n\r\n    return (\r\n        <>\r\n            <group\r\n                ref={groupRef}\r\n                position={positionVector}\r\n                onClick={handleClick}\r\n            >\r\n                <group rotation={[0, 0, tiltRadians]}>\r\n                    {shouldUseTexture ? (\r\n                        <Sphere ref={meshRef} args={[body.radius, 32, 32]}>\r\n                            <React.Suspense fallback={<meshStandardMaterial color={body.color} />}>\r\n                                <TextureOrb body={body} />\r\n                            </React.Suspense>\r\n                        </Sphere>\r\n                    ) : (\r\n                        /* Fallback to Procedual / Simple Shader */\r\n                        body.isStar || body.isCompactObject ? (\r\n                            /* Star/Compact Shader (Simple Emissive for now, could be procedural later) */\r\n                            <Sphere ref={meshRef} args={[body.radius, 32, 32]}>\r\n                                <meshStandardMaterial\r\n                                    color={body.color}\r\n                                    emissive={body.color}\r\n                                    emissiveIntensity={2.0}\r\n                                />\r\n                            </Sphere>\r\n                        ) : (\r\n                            /* Planet Shader */\r\n                            /* Note: ProceduralPlanet does not use meshRef for rotation from parent logic yet. \r\n                               It handles rotation internally via uniforms but we might want to sync it.\r\n                               For now, we just render it. */\r\n                            <ProceduralPlanet\r\n                                radius={body.radius}\r\n                                color={body.color}\r\n                                type={planetType}\r\n                                rotationSpeed={body.rotationSpeed}\r\n                            />\r\n                        )\r\n                    )}\r\n\r\n                    {showGrid && !isSelf && (\r\n                        <Line\r\n                            points={[[0, -body.radius * 1.5, 0], [0, body.radius * 1.5, 0]]}\r\n                            color=\"white\"\r\n                            lineWidth={1}\r\n                            opacity={0.5}\r\n                            transparent\r\n                            dashed\r\n                            dashScale={2}\r\n                            gapSize={1}\r\n                        />\r\n                    )}\r\n                </group>\r\n\r\n                <Html\r\n                    position={[0, body.radius + 1.5, 0]}\r\n                    center\r\n                    zIndexRange={[1000, 0]}\r\n                    style={{\r\n                        color: 'white',\r\n                        fontSize: '14px',\r\n                        fontFamily: 'system-ui, sans-serif',\r\n                        textShadow: '0 0 4px black, 0 0 2px black',\r\n                        whiteSpace: 'nowrap',\r\n                        pointerEvents: 'none',\r\n                        userSelect: 'none',\r\n                    }}\r\n                >\r\n                    {body.name}\r\n                </Html>\r\n            </group>\r\n\r\n            {trailReady && (\r\n                <ConstantWidthTrail\r\n                    position={positionVector}\r\n                    color={body.color}\r\n                />\r\n            )}\r\n\r\n            {body.hasAccretionDisk && body.accretionDiskConfig && (\r\n                <AccretionDisk\r\n                    position={body.position}\r\n                    innerRadius={body.radius * body.accretionDiskConfig.innerRadius}\r\n                    outerRadius={body.radius * body.accretionDiskConfig.outerRadius}\r\n                    rotationSpeed={body.accretionDiskConfig.rotationSpeed}\r\n                    particleCount={body.accretionDiskConfig.particleCount}\r\n                    tilt={body.accretionDiskConfig.tilt}\r\n                />\r\n            )}\r\n\r\n            {body.hasJets && (\r\n                <RelativisticJet\r\n                    position={body.position}\r\n                    length={body.radius * 15}\r\n                    baseWidth={body.radius * 2}\r\n                    speed={1.5}\r\n                />\r\n            )}\r\n        </>\r\n    );\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\yngsw\\dev\\orbit-simulator\\src\\components\\scene\\GravityHeatmap.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\yngsw\\dev\\orbit-simulator\\src\\components\\scene\\HabitableZoneMap.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\yngsw\\dev\\orbit-simulator\\src\\components\\scene\\OrbitPrediction.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'e' is defined but never used.","line":34,"column":18,"nodeType":null,"messageId":"unusedVar","endLine":34,"endColumn":19}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useMemo } from 'react';\r\nimport { usePhysicsStore } from '../../store/physicsStore';\r\nimport { BASE_DT } from '../../utils/physics';\r\nimport { Vector3, CatmullRomCurve3 } from 'three';\r\nimport { Line } from '@react-three/drei';\r\n\r\nconst PREDICTION_STEPS = 1200;\r\nconst TIME_MULTIPLIER = 1.0;\r\nconst SAVE_FREQUENCY = 10; // Save every 10 steps (120 points total)\r\n\r\n// Dynamic update intervals based on timeScale\r\n// Higher timeScale = more frequent updates needed\r\nconst getUpdateInterval = (timeScale: number): number => {\r\n    if (timeScale >= 10) return 50;   // 20fps for fast simulation\r\n    if (timeScale >= 5) return 80;    // 12.5fps\r\n    if (timeScale >= 2) return 100;   // 10fps (default)\r\n    if (timeScale >= 1) return 150;   // 6.7fps for normal speed\r\n    return 200;                        // 5fps for slow simulation\r\n};\r\n\r\n// Worker singleton\r\nlet predictionWorker: Worker | null = null;\r\nlet pendingRequest = false;\r\n\r\nconst getPredictionWorker = (): Worker | null => {\r\n    if (typeof window === 'undefined') return null;\r\n\r\n    if (!predictionWorker) {\r\n        try {\r\n            predictionWorker = new Worker(\r\n                new URL('../../workers/predictionWorker.ts', import.meta.url),\r\n                { type: 'module' }\r\n            );\r\n        } catch (e) {\r\n            console.warn('Prediction worker not available, using main thread fallback');\r\n            return null;\r\n        }\r\n    }\r\n    return predictionWorker;\r\n};\r\n\r\ninterface PathData {\r\n    id: string;\r\n    points: Vector3[];\r\n    color: string;\r\n}\r\n\r\n// Smooth orbit line with Catmull-Rom spline interpolation\r\nconst SmoothOrbitLine: React.FC<{ points: Vector3[]; color: string }> = ({ points, color }) => {\r\n    const smoothPoints = useMemo(() => {\r\n        if (points.length < 4) return points;\r\n        try {\r\n            const curve = new CatmullRomCurve3(points, false, 'catmullrom', 0.5);\r\n            // Interpolate to ~3x the original points for smooth curves\r\n            return curve.getPoints(Math.min(points.length * 3, 360));\r\n        } catch {\r\n            return points;\r\n        }\r\n    }, [points]);\r\n\r\n    if (smoothPoints.length < 2) return null;\r\n\r\n    return (\r\n        <Line\r\n            points={smoothPoints}\r\n            color={color}\r\n            lineWidth={1.5}\r\n            opacity={0.4}\r\n            transparent\r\n        />\r\n    );\r\n};\r\n\r\nexport const OrbitPrediction: React.FC = () => {\r\n    const bodies = usePhysicsStore((state) => state.bodies);\r\n    const simulationState = usePhysicsStore((state) => state.simulationState);\r\n    const timeScale = usePhysicsStore((state) => state.timeScale);\r\n    const useRealisticDistances = usePhysicsStore((state) => state.useRealisticDistances);\r\n\r\n    const [paths, setPaths] = React.useState<PathData[]>([]);\r\n\r\n    // Reset paths when distance scale changes\r\n    React.useEffect(() => {\r\n        setPaths([]);\r\n    }, [useRealisticDistances]);\r\n\r\n    // Worker message handler\r\n    React.useEffect(() => {\r\n        const worker = getPredictionWorker();\r\n        if (!worker) return;\r\n\r\n        const handleMessage = (e: MessageEvent) => {\r\n            if (e.data.type === 'result') {\r\n                pendingRequest = false;\r\n                const result = e.data.paths.map((p: { id: string; points: number[][]; color: string }) => ({\r\n                    id: p.id,\r\n                    points: p.points.map((pt: number[]) => new Vector3(pt[0], pt[1], pt[2])),\r\n                    color: p.color\r\n                }));\r\n                setPaths(result);\r\n            }\r\n        };\r\n\r\n        worker.addEventListener('message', handleMessage);\r\n        return () => {\r\n            worker.removeEventListener('message', handleMessage);\r\n        };\r\n    }, []);\r\n\r\n    // Main prediction loop with dynamic frequency\r\n    React.useEffect(() => {\r\n        if (simulationState === 'paused') return;\r\n\r\n        const updateInterval = getUpdateInterval(timeScale);\r\n\r\n        const interval = setInterval(() => {\r\n            const currentBodies = usePhysicsStore.getState().bodies;\r\n            if (currentBodies.length === 0) return;\r\n\r\n            const worker = getPredictionWorker();\r\n            const dt = BASE_DT * TIME_MULTIPLIER;\r\n\r\n            if (worker && !pendingRequest) {\r\n                // Use Worker for calculation\r\n                pendingRequest = true;\r\n\r\n                const bodyData = currentBodies.map(b => ({\r\n                    id: b.id,\r\n                    position: { x: b.position.x, y: b.position.y, z: b.position.z },\r\n                    velocity: { x: b.velocity.x, y: b.velocity.y, z: b.velocity.z },\r\n                    mass: b.mass,\r\n                    radius: b.radius,\r\n                    color: b.color\r\n                }));\r\n\r\n                worker.postMessage({\r\n                    type: 'predict',\r\n                    bodies: bodyData,\r\n                    steps: PREDICTION_STEPS,\r\n                    dt,\r\n                    saveFrequency: SAVE_FREQUENCY\r\n                });\r\n            }\r\n            // Note: Main thread fallback removed for performance\r\n            // If worker is unavailable, prediction lines won't update\r\n        }, updateInterval);\r\n\r\n        return () => clearInterval(interval);\r\n    }, [simulationState, timeScale, bodies.length]);\r\n\r\n    return (\r\n        <group>\r\n            {paths.map(p => (\r\n                <SmoothOrbitLine\r\n                    key={p.id}\r\n                    points={p.points}\r\n                    color={p.color}\r\n                />\r\n            ))}\r\n        </group>\r\n    );\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\yngsw\\dev\\orbit-simulator\\src\\components\\scene\\ProceduralPlanet.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\yngsw\\dev\\orbit-simulator\\src\\components\\scene\\Scene.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":63,"column":51,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":63,"endColumn":54,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3241,3244],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3241,3244],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook React.useEffect has a missing dependency: 'bodies'. Either include it or remove the dependency array.","line":146,"column":8,"nodeType":"ArrayExpression","endLine":146,"endColumn":55,"suggestions":[{"desc":"Update the dependencies array to be: [followingBodyId, cameraMode, controls, camera, bodies]","fix":{"range":[7953,8000],"text":"[followingBodyId, cameraMode, controls, camera, bodies]"}}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":163,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":163,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8548,8551],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8548,8551],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":255,"column":51,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":255,"endColumn":54,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12988,12991],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12988,12991],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":278,"column":51,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":278,"endColumn":54,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13885,13888],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13885,13888],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useMemo } from 'react';\r\nimport { Canvas, useFrame, useThree } from '@react-three/fiber';\r\nimport { OrbitControls, Grid, GizmoHelper, GizmoViewport } from '@react-three/drei';\r\nimport { Vector3 } from 'three';\r\nimport * as THREE from 'three';\r\nimport { usePhysicsStore, physicsStats } from '../../store/physicsStore';\r\nimport { CelestialBody } from './CelestialBody';\r\nimport { usePhysicsLoop } from '../../hooks/usePhysicsLoop';\r\nimport { OrbitPrediction } from './OrbitPrediction';\r\nimport { DateDisplay } from '../ui/DateDisplay';\r\nimport type { CelestialBody as BodyType } from '../../types/physics';\r\nimport { GravityHeatmap } from './GravityHeatmap';\r\nimport { HabitableZoneMap } from './HabitableZoneMap';\r\nimport { EffectsLayer } from '../effects/EffectsLayer';\r\nimport { calculateSingleStarHZ } from '../../utils/habitableZone';\r\nimport { DISTANCE_SCALES } from '../../utils/solarSystem';\r\nimport { EffectComposer, BrightnessContrast } from '@react-three/postprocessing';\r\nimport { GravitationalLensEffect } from '../effects/GravitationalLensEffect';\r\nimport { TidalDisruptionEffect } from '../effects/TidalDisruptionEffect';\r\nimport { ShockwaveEffect } from '../effects/ShockwaveEffect';\r\nimport { StarfieldBackground } from './StarfieldBackground';\r\nimport { transitionCamera } from '../../utils/cameraTransitions';\r\n\r\n// Helper to find the primary star (most massive star body)\r\nconst findPrimaryStar = (bodies: BodyType[]): BodyType | undefined => {\r\n    const stars = bodies.filter(b => b.isStar);\r\n    if (stars.length === 0) return undefined;\r\n    return stars.reduce((max, star) => star.mass > max.mass ? star : max, stars[0]);\r\n};\r\n\r\n// Wrapper to avoid re-rendering entire Scene on toggle change if possible,\r\n// or just standard conditional render.\r\nconst OrbitPredictionWrapper = () => {\r\n    const showPrediction = usePhysicsStore((state) => state.showPrediction);\r\n    return showPrediction ? <OrbitPrediction /> : null;\r\n};\r\n\r\n// Internal component to hook into the R3F context\r\n// Handles Camera Follow logic\r\nconst CameraController = () => {\r\n    const bodies = usePhysicsStore((state) => state.bodies);\r\n    const followingBodyId = usePhysicsStore((state) => state.followingBodyId);\r\n    const cameraMode = usePhysicsStore((state) => state.cameraMode);\r\n    const simulationTime = usePhysicsStore(state => state.simulationTime);\r\n    const { camera, controls } = useThree();\r\n\r\n    // Store previous states to calculate deltas\r\n    const prevBodyPos = React.useRef<Vector3 | null>(null);\r\n    const prevSimulationTime = React.useRef<number>(0);\r\n    const isFirstLockFrame = React.useRef(true);\r\n    const lastUsedMode = React.useRef<string>('free');\r\n\r\n    // Reset flags when target or mode changes\r\n    // Initial Jump / Target Switch Logic with smooth transitions\r\n    React.useEffect(() => {\r\n        isFirstLockFrame.current = true;\r\n\r\n        // Handle switching TO lock modes\r\n        if (followingBodyId && controls) {\r\n            const body = usePhysicsStore.getState().bodies.find(b => b.id === followingBodyId);\r\n            if (body) {\r\n                const bodyPos = new Vector3(body.position.x, body.position.y, body.position.z);\r\n                const orbitControls = controls as any;\r\n\r\n                // If switching mode or target, ensure we set up the view correctly\r\n                if (cameraMode !== lastUsedMode.current || isFirstLockFrame.current) {\r\n\r\n                    if (cameraMode === 'surface_lock') {\r\n                        // FPS Setup for Surface View:\r\n                        // Y-Neutral (Equatorial)\r\n                        // Look at Direction of Motion (Tangent)\r\n\r\n                        // 1. Calculate safe Forward direction (Tangent to Orbit)\r\n                        // Use Star-Body vector to derive tangent, ensuring validity even if velocity is 0\r\n                        const primaryStar = findPrimaryStar(usePhysicsStore.getState().bodies);\r\n                        let forwardDir = new Vector3(0, 0, -1);\r\n                        let radialDir = new Vector3(1, 0, 0);\r\n\r\n                        if (primaryStar) {\r\n                            const starPos = new Vector3(primaryStar.position.x, primaryStar.position.y, primaryStar.position.z);\r\n                            const toStar = starPos.clone().sub(bodyPos).normalize();\r\n                            radialDir = toStar.clone().negate(); // Radial Out (Midnight)\r\n\r\n                            // Tangent = toStar x Up (for CCW orbit)\r\n                            forwardDir = toStar.clone().cross(new Vector3(0, 1, 0)).normalize();\r\n                        } else {\r\n                            // Fallback to Velocity if no star\r\n                            const v = new Vector3(body.velocity.x, body.velocity.y, body.velocity.z);\r\n                            if (v.lengthSq() > 0.0001) forwardDir = v.normalize();\r\n                        }\r\n\r\n                        // Position: \"Midnight\" (Outer Edge)\r\n                        // Radial Outwards from Star\r\n                        const surfaceOffset = radialDir.multiplyScalar(body.radius * 1.05);\r\n                        const camPos = bodyPos.clone().add(surfaceOffset);\r\n\r\n                        // Target: Point ahead in tangent direction\r\n                        const targetPos = camPos.clone().add(forwardDir.multiplyScalar(100));\r\n\r\n                        // Smooth transition to surface lock view\r\n                        transitionCamera(camera, orbitControls, camPos, targetPos, {\r\n                            duration: 1.0,\r\n                            ease: 'power2.inOut'\r\n                        });\r\n\r\n                    } else {\r\n                        // Free or Sun Lock: Target = Center of the body\r\n                        // Calculate direction from body to camera (so camera looks at body)\r\n                        const currentCameraPos = camera.position.clone();\r\n                        const direction = currentCameraPos.sub(bodyPos).normalize();\r\n\r\n                        // If camera is too close to body (nearly at same position), use default viewing angle\r\n                        if (direction.lengthSq() < 0.001) {\r\n                            direction.set(1, 0.8, 1).normalize(); // Diagonal view from upper-right-front\r\n                        }\r\n\r\n                        // Ideal distance: proportional to body radius for good framing\r\n                        const idealDist = Math.max(body.radius * 5, 10); // At least 10 units away\r\n\r\n                        // Calculate new camera position: body position + direction * distance\r\n                        const newCamPos = bodyPos.clone().add(direction.multiplyScalar(idealDist));\r\n\r\n                        // Smooth transition: camera moves to new position while looking at body center\r\n                        // Use dynamicTarget to continuously track the moving body during animation\r\n                        transitionCamera(camera, orbitControls, newCamPos, bodyPos, {\r\n                            duration: 0.8,\r\n                            ease: 'power2.inOut',\r\n                            dynamicTarget: () => {\r\n                                // Return current body position every frame\r\n                                const currentBody = bodies.find(b => b.id === followingBodyId);\r\n                                if (currentBody) {\r\n                                    return new Vector3(\r\n                                        currentBody.position.x,\r\n                                        currentBody.position.y,\r\n                                        currentBody.position.z\r\n                                    );\r\n                                }\r\n                                return bodyPos; // Fallback to initial position\r\n                            }\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        lastUsedMode.current = cameraMode;\r\n    }, [followingBodyId, cameraMode, controls, camera]);\r\n\r\n    // Continuous Follow Logic\r\n    useFrame((state) => {\r\n        // Update stats (Always run this, even if not following)\r\n        physicsStats.cameraPosition = [\r\n            state.camera.position.x,\r\n            state.camera.position.y,\r\n            state.camera.position.z\r\n        ];\r\n\r\n        if (!followingBodyId) return;\r\n\r\n        const body = bodies.find(b => b.id === followingBodyId);\r\n        const primaryStar = findPrimaryStar(bodies);\r\n\r\n        if (body && state.controls) {\r\n            const controls = state.controls as any;\r\n            const currentBodyPos = new Vector3(body.position.x, body.position.y, body.position.z);\r\n\r\n            // Initialization for the first frame of tracking\r\n            if (isFirstLockFrame.current || !prevBodyPos.current) {\r\n                prevBodyPos.current = currentBodyPos.clone();\r\n                prevSimulationTime.current = simulationTime;\r\n                isFirstLockFrame.current = false;\r\n\r\n                // Initial jump if needed (simple centering)\r\n                controls.target.copy(currentBodyPos);\r\n                controls.update();\r\n                return;\r\n            }\r\n\r\n            // Delta time for rotation calculations\r\n            // Note: physicsStore simulationTime might be jumping if dt changes, but it's accumulated time.\r\n            // We use the difference between frames.\r\n            // const dt = simulationTime - prevSimulationTime.current; // Unused in new logic\r\n\r\n            if (cameraMode === 'free') {\r\n                // Classic Follow: Just move camera by the same amount the body moved (Translation only)\r\n                const deltaMove = currentBodyPos.clone().sub(prevBodyPos.current);\r\n                state.camera.position.add(deltaMove);\r\n                controls.target.add(deltaMove);\r\n\r\n            } else if (cameraMode === 'sun_lock' || cameraMode === 'surface_lock') {\r\n                // Orbit Fixed View: Lock camera orientation relative to primary star\r\n                // The only difference is the initial distance/position (handled in useEffect).\r\n\r\n                if (primaryStar) {\r\n                    // 1. Calculate the rotation of the Star->Body vector\r\n                    const starPos = new Vector3(primaryStar.position.x, primaryStar.position.y, primaryStar.position.z);\r\n\r\n                    const prevRel = prevBodyPos.current.clone().sub(starPos);\r\n                    const currRel = currentBodyPos.clone().sub(starPos);\r\n\r\n                    // Avoid division by zero or unstable rotation\r\n                    if (prevRel.lengthSq() > 0.0001 && currRel.lengthSq() > 0.0001) {\r\n                        prevRel.normalize();\r\n                        currRel.normalize();\r\n\r\n                        const quaternion = new THREE.Quaternion().setFromUnitVectors(prevRel, currRel);\r\n\r\n                        // 2. Apply this rotation to the (Camera - Body) vector\r\n                        const camToBody = state.camera.position.clone().sub(prevBodyPos.current);\r\n                        camToBody.applyQuaternion(quaternion);\r\n\r\n                        // 3. Move camera to new position\r\n                        state.camera.position.copy(currentBodyPos.clone().add(camToBody));\r\n\r\n                        // 4. Update target (rotate Target-Body vector to keep viewing direction fixed)\r\n                        const targetToBody = controls.target.clone().sub(prevBodyPos.current);\r\n                        targetToBody.applyQuaternion(quaternion);\r\n                        controls.target.copy(currentBodyPos.clone().add(targetToBody));\r\n\r\n                    } else {\r\n                        const deltaMove = currentBodyPos.clone().sub(prevBodyPos.current);\r\n                        state.camera.position.add(deltaMove);\r\n                        controls.target.add(deltaMove);\r\n                    }\r\n                } else {\r\n                    // Fallback if no star (Simple Translation)\r\n                    const deltaMove = currentBodyPos.clone().sub(prevBodyPos.current);\r\n                    state.camera.position.add(deltaMove);\r\n                    controls.target.add(deltaMove);\r\n                }\r\n            }\r\n\r\n            controls.update();\r\n            prevBodyPos.current.copy(currentBodyPos);\r\n            prevSimulationTime.current = simulationTime; // Update stored time\r\n        }\r\n    });\r\n\r\n    return null;\r\n};\r\n\r\n// Component to handle camera adjustment when distance scale changes\r\nconst CameraScaleAdjuster = () => {\r\n    const { camera, controls } = useThree();\r\n\r\n    React.useEffect(() => {\r\n        const handleScaleChange = (e: Event) => {\r\n            const customEvent = e as CustomEvent<{ realistic: boolean; factor: number }>;\r\n            const { factor } = customEvent.detail;\r\n\r\n            // Scale camera position\r\n            camera.position.multiplyScalar(factor);\r\n\r\n            // Scale OrbitControls target\r\n            if (controls) {\r\n                const orbitControls = controls as any;\r\n                orbitControls.target.multiplyScalar(factor);\r\n                orbitControls.update();\r\n            }\r\n\r\n            // Update camera far value dynamically\r\n            camera.far = customEvent.detail.realistic ? 100000 : 50000;\r\n            camera.updateProjectionMatrix();\r\n        };\r\n\r\n        const handleSystemChange = (e: Event) => {\r\n            const customEvent = e as CustomEvent<{\r\n                systemId: string;\r\n                mode?: string;\r\n                camera: { position: [number, number, number]; target: [number, number, number] };\r\n            }>;\r\n\r\n            const { camera: camConfig } = customEvent.detail;\r\n\r\n            // Reset camera to preset position\r\n            camera.position.set(camConfig.position[0], camConfig.position[1], camConfig.position[2]);\r\n\r\n            if (controls) {\r\n                const orbitControls = controls as any;\r\n                orbitControls.target.set(camConfig.target[0], camConfig.target[1], camConfig.target[2]);\r\n                orbitControls.update();\r\n            }\r\n        };\r\n\r\n        window.addEventListener('distanceScaleChanged', handleScaleChange);\r\n        window.addEventListener('starSystemChanged', handleSystemChange);\r\n        return () => {\r\n            window.removeEventListener('distanceScaleChanged', handleScaleChange);\r\n            window.removeEventListener('starSystemChanged', handleSystemChange);\r\n        };\r\n    }, [camera, controls]);\r\n\r\n    return null;\r\n};\r\n\r\n// Gravitational lens post-processing wrapper (always enabled for compact objects)\r\nconst GravitationalLensPostProcess = () => {\r\n    const bodies = usePhysicsStore((state) => state.bodies);\r\n    const { camera } = useThree();\r\n\r\n    // Find compact objects (black holes)\r\n    const compactObjects = useMemo(() => bodies.filter(b => b.isCompactObject), [bodies]);\r\n    const hasBlackHole = compactObjects.length > 0;\r\n\r\n    // Only render when black holes exist\r\n    if (!hasBlackHole) {\r\n        return null;\r\n    }\r\n\r\n    // For now, only apply effect to the first compact object\r\n    const blackHole = compactObjects[0];\r\n    const bhPosition = new Vector3(blackHole.position.x, blackHole.position.y, blackHole.position.z);\r\n\r\n    return (\r\n        <EffectComposer key=\"gravitational-lens-composer\" enableNormalPass={false} multisampling={0}>\r\n            <GravitationalLensEffect\r\n                blackHolePosition={bhPosition}\r\n                schwarzschildRadius={blackHole.radius}\r\n                strength={1.5}\r\n                camera={camera}\r\n                enabled={true}\r\n            />\r\n            <BrightnessContrast brightness={-0.2} contrast={0.1} />\r\n        </EffectComposer>\r\n    );\r\n};\r\n\r\nconst SimulationContent = () => {\r\n    usePhysicsLoop();\r\n    const bodies = usePhysicsStore((state) => state.bodies);\r\n    const showHabitableZone = usePhysicsStore((state) => state.showHabitableZone);\r\n    const useRealisticDistances = usePhysicsStore((state) => state.useRealisticDistances);\r\n    const tidallyDisruptedEvents = usePhysicsStore((state) => state.tidallyDisruptedEvents);\r\n    const removeTidalDisruptionEvent = usePhysicsStore((state) => state.removeTidalDisruptionEvent);\r\n    const collisionEvents = usePhysicsStore((state) => state.collisionEvents);\r\n    const removeCollisionEvent = usePhysicsStore((state) => state.removeCollisionEvent);\r\n\r\n    // Find all stars and determine if we should show habitable zone\r\n    const stars = useMemo(() => bodies.filter(b => b.isStar), [bodies]);\r\n    const isSingleStarSystem = stars.length === 1;\r\n    const isMultiStarSystem = stars.length > 1;\r\n    const primaryStar = isSingleStarSystem ? stars[0] : undefined;\r\n\r\n    // Dynamic habitable zone calculation based on star's mass/luminosity\r\n    const scale = useRealisticDistances ? DISTANCE_SCALES.REALISTIC.AU_UNIT : DISTANCE_SCALES.COMPRESSED.AU_UNIT;\r\n\r\n    const habitableZone = useMemo(() => {\r\n        if (!primaryStar) return null;\r\n        return calculateSingleStarHZ(primaryStar, scale);\r\n    }, [primaryStar, scale]);\r\n\r\n    return (\r\n        <>\r\n            <CameraController />\r\n            <ambientLight intensity={0.2} />\r\n            <pointLight position={[0, 0, 0]} intensity={2} decay={0} distance={1000} />\r\n\r\n\r\n\r\n            {/* Single star system: Ring-based habitable zone */}\r\n            {showHabitableZone && habitableZone && primaryStar && isSingleStarSystem && (\r\n                <mesh\r\n                    position={[primaryStar.position.x, primaryStar.position.y, primaryStar.position.z]}\r\n                    rotation={[-Math.PI / 2, 0, 0]}\r\n                >\r\n                    <ringGeometry args={[habitableZone.inner, habitableZone.outer, 64]} />\r\n                    <meshBasicMaterial color=\"#22aa44\" opacity={0.15} transparent side={THREE.DoubleSide} depthWrite={false} />\r\n                </mesh>\r\n            )}\r\n\r\n            {/* Multi-star system: 2D heatmap-based habitable zone */}\r\n            {showHabitableZone && isMultiStarSystem && <HabitableZoneMap />}\r\n\r\n            {/* Legacy: Tidal Disruption & Shockwave rendered directly here for Week 1 compatibility */}\r\n            {tidallyDisruptedEvents.map(event => {\r\n                const primary = bodies.find(b => b.id === event.primaryId);\r\n                const body = bodies.find(b => b.id === event.bodyId);\r\n                const primaryPos = primary ? primary.position : new THREE.Vector3(0, 0, 0);\r\n                const primaryMass = primary ? primary.mass : 1000;\r\n                const radius = body ? body.radius : 10;\r\n                const color = body ? body.color : '#aaaaaa';\r\n\r\n                return (\r\n                    <TidalDisruptionEffect\r\n                        key={event.bodyId + '_' + event.startTime}\r\n                        position={new THREE.Vector3(event.position.x, event.position.y, event.position.z)}\r\n                        primaryPosition={new THREE.Vector3(primaryPos.x, primaryPos.y, primaryPos.z)}\r\n                        bodyRadius={radius}\r\n                        bodyColor={color}\r\n                        primaryMass={primaryMass}\r\n                        startTime={event.startTime}\r\n                        duration={event.duration}\r\n                        onComplete={() => removeTidalDisruptionEvent(event.bodyId)}\r\n                    />\r\n                );\r\n            })}\r\n\r\n            {collisionEvents.map(event => (\r\n                <ShockwaveEffect\r\n                    key={event.id}\r\n                    position={new THREE.Vector3(event.position.x, event.position.y, event.position.z)}\r\n                    startTime={event.startTime}\r\n                    duration={2000}\r\n                    maxRadius={50}\r\n                    color={event.color}\r\n                    onComplete={() => removeCollisionEvent(event.id)}\r\n                />\r\n            ))}\r\n\r\n            {\r\n                bodies.map((body) => {\r\n                    return <CelestialBody key={body.id} body={body} />;\r\n                })\r\n            }\r\n\r\n            <OrbitPredictionWrapper />\r\n\r\n            <GravityHeatmap />\r\n\r\n            {/* Visual effects layer (shockwaves, debris, etc.) */}\r\n            <EffectsLayer />\r\n        </>\r\n    );\r\n};\r\n\r\nimport { PerformanceStats } from '../ui/PerformanceStats';\r\n\r\nconst SceneGrid = () => {\r\n    const showGrid = usePhysicsStore((state) => state.showGrid);\r\n    const zenMode = usePhysicsStore((state) => state.zenMode);\r\n    const useRealisticDistances = usePhysicsStore((state) => state.useRealisticDistances);\r\n\r\n    // Check for black holes for grid brightness adjustment\r\n    const bodies = usePhysicsStore((state) => state.bodies);\r\n    const hasBlackHole = useMemo(() => bodies.some(b => b.isCompactObject), [bodies]);\r\n\r\n    const gridConfig = useRealisticDistances\r\n        ? { fadeDistance: 5000, sectionSize: 200, cellSize: 50 }\r\n        : { fadeDistance: 2000, sectionSize: 50, cellSize: 10 };\r\n\r\n    const sectionColor = hasBlackHole ? \"#aaaaaa\" : \"#555555\";\r\n    const cellColor = hasBlackHole ? \"#888888\" : \"#333333\";\r\n\r\n    // Always render Grid but control visibility to prevent EffectComposer unmounting\r\n    const shouldShow = showGrid && !zenMode;\r\n\r\n    return (\r\n        <group visible={shouldShow}>\r\n            <Grid\r\n                infiniteGrid\r\n                fadeDistance={gridConfig.fadeDistance}\r\n                sectionColor={sectionColor}\r\n                cellColor={cellColor}\r\n                sectionSize={gridConfig.sectionSize}\r\n                cellSize={gridConfig.cellSize}\r\n                side={2}\r\n            />\r\n        </group>\r\n    );\r\n};\r\n\r\nconst SceneContent = () => {\r\n    const showGrid = usePhysicsStore((state) => state.showGrid);\r\n    const zenMode = usePhysicsStore((state) => state.zenMode);\r\n    const cameraMode = usePhysicsStore((state) => state.cameraMode);\r\n    const useRealisticDistances = usePhysicsStore((state) => state.useRealisticDistances);\r\n\r\n    const isSurfaceLock = cameraMode === 'surface_lock';\r\n\r\n    // Camera far value based on distance scale\r\n    const cameraFar = useRealisticDistances ? 200000 : 50000;\r\n\r\n    return (\r\n        <Canvas camera={{ position: [0, 25, 50], fov: 45, near: 0.1, far: cameraFar }}>\r\n            <color attach=\"background\" args={['#000000']} />\r\n            <StarfieldBackground />\r\n            <SimulationContent />\r\n            <CameraScaleAdjuster />\r\n            <OrbitControls\r\n                makeDefault\r\n                enablePan={true}\r\n                minDistance={0.001}\r\n                maxDistance={100000}\r\n                enableZoom={!isSurfaceLock}\r\n                enableDamping={true}\r\n                dampingFactor={0.1}\r\n                zoomSpeed={1.5}\r\n                panSpeed={1.2}\r\n                rotateSpeed={0.8}\r\n            />\r\n\r\n            <SceneGrid />\r\n\r\n            {/* Always render to prevent EffectComposer unmounting */}\r\n            <group visible={showGrid && !zenMode}>\r\n                <GizmoHelper alignment=\"bottom-left\" margin={[100, 100]}>\r\n                    <GizmoViewport axisColors={['#ff3653', '#0adb50', '#2c8fdf']} labelColor=\"black\" />\r\n                </GizmoHelper>\r\n            </group>\r\n\r\n            {/* Post-processing effects are rendered last to capture everything including the grid */}\r\n            <GravitationalLensPostProcess />\r\n        </Canvas>\r\n    );\r\n};\r\n\r\nexport const Scene = () => {\r\n    return (\r\n        <div style={{ position: 'relative', width: '100%', height: '100%' }}>\r\n            <SceneContent />\r\n            <DateDisplay />\r\n            {usePhysicsStore(state => state.showPerformance) && <PerformanceStats />}\r\n        </div>\r\n    );\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\yngsw\\dev\\orbit-simulator\\src\\components\\scene\\StarfieldBackground.tsx","messages":[{"ruleId":"react-hooks/purity","severity":2,"message":"Error: Cannot call impure function during render\n\n`Math.random` is an impure function. Calling an impure function can produce unstable results that update unpredictably when the component happens to re-render. (https://react.dev/reference/rules/components-and-hooks-must-be-pure#components-and-hooks-must-be-idempotent).\n\nC:\\Users\\yngsw\\dev\\orbit-simulator\\src\\components\\scene\\StarfieldBackground.tsx:190:22\n  188 |     const uniforms = useMemo(() => {\n  189 |         // Random Seed\n> 190 |         const seed = Math.random() * 100.0;\n      |                      ^^^^^^^^^^^^^ Cannot call impure function\n  191 |\n  192 |         // Randomize Nebula Palette\n  193 |         const baseHue = Math.random();","line":190,"column":22,"nodeType":null,"endLine":190,"endColumn":35},{"ruleId":"react-hooks/purity","severity":2,"message":"Error: Cannot call impure function during render\n\n`Math.random` is an impure function. Calling an impure function can produce unstable results that update unpredictably when the component happens to re-render. (https://react.dev/reference/rules/components-and-hooks-must-be-pure#components-and-hooks-must-be-idempotent).\n\nC:\\Users\\yngsw\\dev\\orbit-simulator\\src\\components\\scene\\StarfieldBackground.tsx:193:25\n  191 |\n  192 |         // Randomize Nebula Palette\n> 193 |         const baseHue = Math.random();\n      |                         ^^^^^^^^^^^^^ Cannot call impure function\n  194 |\n  195 |         // Helper for hsl\n  196 |         const deep = new THREE.Color().setHSL(baseHue, 0.6, 0.02);","line":193,"column":25,"nodeType":null,"endLine":193,"endColumn":38}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useRef, useMemo } from 'react';\r\nimport { useFrame } from '@react-three/fiber';\r\nimport * as THREE from 'three';\r\n\r\nconst starfieldShader = {\r\n    vertexShader: `\r\n        varying vec3 vWorldPosition;\r\n        void main() {\r\n            vWorldPosition = position; \r\n            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n        }\r\n    `,\r\n    fragmentShader: `\r\n        uniform float time;\r\n        uniform float seed;\r\n        uniform vec3 uColorDeep;\r\n        uniform vec3 uColorMist;\r\n        uniform vec3 uColorGlow;\r\n        uniform vec3 uColorCore;\r\n        varying vec3 vWorldPosition;\r\n\r\n        // Simplex 3D Noise (Ian McEwan, Ashima Arts)\r\n        vec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\r\n        vec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\r\n\r\n        float snoise(vec3 v){ \r\n            const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\r\n            const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\r\n\r\n            vec3 i  = floor(v + dot(v, C.yyy) );\r\n            vec3 x0 = v - i + dot(i, C.xxx) ;\r\n            vec3 g = step(x0.yzx, x0.xyz);\r\n            vec3 l = 1.0 - g;\r\n            vec3 i1 = min( g.xyz, l.zxy );\r\n            vec3 i2 = max( g.xyz, l.zxy );\r\n            vec3 x1 = x0 - i1 + 1.0 * C.xxx;\r\n            vec3 x2 = x0 - i2 + 2.0 * C.xxx;\r\n            vec3 x3 = x0 - 1.0 + 3.0 * C.xxx;\r\n            i = mod(i, 289.0 ); \r\n            vec4 p = permute( permute( permute( \r\n                        i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\r\n                    + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \r\n                    + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\r\n            float n_ = 1.0/7.0; \r\n            vec3  ns = n_ * D.wyz - D.xzx;\r\n            vec4 j = p - 49.0 * floor(p * ns.z * ns.z); \r\n            vec4 x_ = floor(j * ns.z);\r\n            vec4 y_ = floor(j - 7.0 * x_ );  \r\n            vec4 x = x_ *ns.x + ns.yyyy;\r\n            vec4 y = y_ *ns.x + ns.yyyy;\r\n            vec4 h = 1.0 - abs(x) - abs(y);\r\n            vec4 b0 = vec4( x.xy, y.xy );\r\n            vec4 b1 = vec4( x.zw, y.zw );\r\n            vec4 s0 = floor(b0)*2.0 + 1.0;\r\n            vec4 s1 = floor(b1)*2.0 + 1.0;\r\n            vec4 sh = -step(h, vec4(0.0));\r\n            vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\r\n            vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\r\n            vec3 p0 = vec3(a0.xy,h.x);\r\n            vec3 p1 = vec3(a0.zw,h.y);\r\n            vec3 p2 = vec3(a1.xy,h.z);\r\n            vec3 p3 = vec3(a1.zw,h.w);\r\n            vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\r\n            p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;\r\n            vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\r\n            m = m * m;\r\n            return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );\r\n        }\r\n\r\n        // Fractal Brownian Motion (Layered Noise)\r\n        float fbm(vec3 p) {\r\n            float value = 0.0;\r\n            float amplitude = 0.5;\r\n            float frequency = 1.0;\r\n            for (int i = 0; i < 4; i++) {\r\n                value += amplitude * snoise(p * frequency);\r\n                p += vec3(10.0); // Shift next layer to avoid alignment artifacts\r\n                frequency *= 2.0;\r\n                amplitude *= 0.5;\r\n            }\r\n            return value;\r\n        }\r\n\r\n        // Determine star color based on position (Pseudo-random)\r\n        vec3 getStarColor(vec3 position) {\r\n            float starType = snoise(position * 1234.5) * 0.5 + 0.5; // 0.0 - 1.0\r\n\r\n            vec3 color;\r\n            if (starType < 0.76) {\r\n                // M-type: Red-Orange (76%)\r\n                color = mix(vec3(1.0, 0.4, 0.2), vec3(1.0, 0.6, 0.3), (starType / 0.76));\r\n            } else if (starType < 0.88) {\r\n                // K-type: Orange (12%)\r\n                color = vec3(1.0, 0.8, 0.5);\r\n            } else if (starType < 0.96) {\r\n                // G-type: Yellow (8%)\r\n                color = vec3(1.0, 0.95, 0.7);\r\n            } else if (starType < 0.99) {\r\n                // F/A-type: White (3%)\r\n                color = vec3(1.0, 1.0, 0.95);\r\n            } else {\r\n                // O/B-type: Blue-White (1%)\r\n                color = vec3(0.7, 0.8, 1.0);\r\n            }\r\n            return color;\r\n        }\r\n\r\n        void main() {\r\n            vec3 pos = normalize(vWorldPosition); \r\n            // Apply Random Seed Offset to position pattern\r\n            vec3 seedOffset = vec3(seed * 100.0);\r\n\r\n            // --- 1. Stars (Twinkle & Multi-colored) ---\r\n            float nStars = snoise(pos * 600.0 + seedOffset); \r\n            float twinkle = sin(time * 2.0 + pos.x * 100.0 + pos.y * 50.0) * 0.5 + 0.5;\r\n            float stars = smoothstep(0.97, 1.0, nStars + twinkle * 0.02); \r\n            float brightStars = smoothstep(0.995, 1.0, snoise(pos * 300.0 + 100.0 + seedOffset));\r\n\r\n            vec3 starColor = getStarColor(pos * 600.0 + seedOffset);\r\n            vec3 brightStarColor = getStarColor(pos * 300.0 + 100.0 + seedOffset);\r\n\r\n            vec3 starContribution = starColor * stars * 0.8 + brightStarColor * brightStars * 1.0;\r\n\r\n            // --- 1.5 Milky Way (Dense Band) ---\r\n            // Galactic plane at Y=0 (Equator)\r\n            float galacticLatitude = abs(pos.y); \r\n            float densityBand = smoothstep(0.5, 0.0, galacticLatitude);\r\n            \r\n            // Vary density with noise\r\n            float densityVariation = fbm(pos * 8.0 + seedOffset) * 0.5 + 0.5;\r\n            float galaxyDensity = densityBand * densityVariation;\r\n\r\n            // Dense stars for Milky Way\r\n            // Lower threshold to show more stars in the band\r\n            float milkyWayStars = snoise(pos * 1200.0 + seedOffset); \r\n            float milkyWayMask = smoothstep(0.90, 1.0, milkyWayStars);\r\n\r\n            // Milky Way Color (slightly bluish/white)\r\n            vec3 milkyWayColor = mix(\r\n                vec3(0.9, 0.95, 1.0),\r\n                vec3(1.0, 0.98, 0.9),\r\n                snoise(pos * 1200.0 + 500.0 + seedOffset) * 0.5 + 0.5\r\n            );\r\n\r\n            // Boost intensity significantly to make it visible\r\n            vec3 milkyWayContribution = milkyWayColor * milkyWayMask * galaxyDensity * 2.5;\r\n\r\n            // --- 2. Rich Nebula (Multi-layered FBM) ---\r\n            float flowTime = time * 0.005;\r\n            vec3 flowOffset = vec3(flowTime, -flowTime * 0.5, flowTime * 0.2);\r\n            \r\n            float nebulaNoise = fbm(pos * 1.5 + flowOffset + seedOffset * 0.1);\r\n            nebulaNoise = nebulaNoise * 0.5 + 0.5; \r\n            \r\n            float clouds = smoothstep(0.3, 0.8, nebulaNoise);\r\n\r\n            // Use uniform colors for randomness\r\n            vec3 nebulaColor = mix(uColorDeep, uColorMist, clouds);\r\n            nebulaColor = mix(nebulaColor, uColorGlow, smoothstep(0.6, 0.9, nebulaNoise) * 0.6);\r\n            \r\n            float coreNoise = snoise(pos * 3.0 + vec3(10.0) + seedOffset);\r\n            nebulaColor += uColorCore * smoothstep(0.7, 1.0, coreNoise * clouds) * 0.3;\r\n\r\n            // Darken the nebula significantly as requested\r\n            nebulaColor *= 0.4;\r\n\r\n            // --- Final Combine ---\r\n            vec3 finalColor = nebulaColor + starContribution + milkyWayContribution;\r\n\r\n            gl_FragColor = vec4(finalColor, 1.0);\r\n        }\r\n    `\r\n};\r\n\r\nexport const StarfieldBackground = () => {\r\n    const materialRef = useRef<THREE.ShaderMaterial>(null);\r\n    const meshRef = useRef<THREE.Mesh>(null);\r\n\r\n    useFrame(({ clock, camera }) => {\r\n        if (materialRef.current) {\r\n            materialRef.current.uniforms.time.value = clock.getElapsedTime() * 0.5;\r\n        }\r\n        if (meshRef.current) {\r\n            meshRef.current.position.copy(camera.position);\r\n        }\r\n    });\r\n\r\n    const uniforms = useMemo(() => {\r\n        // Random Seed\r\n        const seed = Math.random() * 100.0;\r\n\r\n        // Randomize Nebula Palette\r\n        const baseHue = Math.random();\r\n\r\n        // Helper for hsl\r\n        const deep = new THREE.Color().setHSL(baseHue, 0.6, 0.02);\r\n        const mist = new THREE.Color().setHSL((baseHue + 0.1) % 1.0, 0.5, 0.15);\r\n        const glow = new THREE.Color().setHSL((baseHue + 0.5) % 1.0, 0.8, 0.2);\r\n        const core = new THREE.Color().setHSL((baseHue + 0.05) % 1.0, 1.0, 0.3);\r\n\r\n        return {\r\n            time: { value: 0 },\r\n            seed: { value: seed },\r\n            uColorDeep: { value: deep },\r\n            uColorMist: { value: mist },\r\n            uColorGlow: { value: glow },\r\n            uColorCore: { value: core },\r\n        };\r\n    }, []);\r\n\r\n    return (\r\n        <mesh ref={meshRef} frustumCulled={false}>\r\n            <sphereGeometry args={[40000, 64, 64]} />\r\n            <shaderMaterial\r\n                ref={materialRef}\r\n                uniforms={uniforms}\r\n                vertexShader={starfieldShader.vertexShader}\r\n                fragmentShader={starfieldShader.fragmentShader}\r\n                side={THREE.BackSide}\r\n                depthWrite={false}\r\n            />\r\n        </mesh>\r\n    );\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\yngsw\\dev\\orbit-simulator\\src\\components\\ui\\BodyInspectorContent.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":121,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":121,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6346,6349],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6346,6349],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":124,"column":71,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":124,"endColumn":74,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6547,6550],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6547,6550],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":175,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":175,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9249,9252],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9249,9252],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":178,"column":73,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":178,"endColumn":76,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9456,9459],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9456,9459],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":204,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":204,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10890,10893],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10890,10893],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":207,"column":72,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":207,"endColumn":75,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11111,11114],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11111,11114],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":248,"column":60,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":248,"endColumn":63,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13467,13470],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13467,13470],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":250,"column":65,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":250,"endColumn":68,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13627,13630],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13627,13630],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":269,"column":60,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":269,"endColumn":63,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14758,14761],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14758,14761],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":271,"column":65,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":271,"endColumn":68,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14918,14921],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14918,14921],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":10,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState } from 'react';\r\nimport { usePhysicsStore } from '../../store/physicsStore';\r\nimport { useTranslation } from '../../utils/i18n';\r\nimport { Trash2, Settings, ChevronDown, ChevronUp, X } from 'lucide-react';\r\nimport { VectorInput } from './common/VectorInput';\r\nimport { SafeInput } from './common/SafeInput';\r\nimport type { CelestialBody } from '../../types/physics';\r\n\r\nimport { useToast } from './common/Toast';\r\n\r\nimport { ConfirmModal } from './common/ConfirmModal';\r\nimport { ContextHelp } from './common/ContextHelp';\r\n\r\ninterface BodyInspectorContentProps {\r\n    body: CelestialBody;\r\n}\r\n\r\nexport const BodyInspectorContent: React.FC<BodyInspectorContentProps> = ({ body: selectedBody }) => {\r\n    const updateBody = usePhysicsStore(state => state.updateBody);\r\n    const selectBody = usePhysicsStore(state => state.selectBody);\r\n    const removeBody = usePhysicsStore(state => state.removeBody);\r\n    const setFollowingBody = usePhysicsStore(state => state.setFollowingBody);\r\n    const followingBodyId = usePhysicsStore(state => state.followingBodyId);\r\n    const pushHistoryAction = usePhysicsStore(state => state.pushHistoryAction);\r\n\r\n\r\n\r\n    const bodies = usePhysicsStore(state => state.bodies);\r\n    const { t } = useTranslation();\r\n    const { showToast } = useToast();\r\n    const [isAdvancedOpen, setIsAdvancedOpen] = useState(true);\r\n    const [showDeleteModal, setShowDeleteModal] = useState(false);\r\n\r\n    const sun = bodies.find(b => b.name === 'Sun');\r\n    const distanceToSun = sun && selectedBody.id !== sun.id\r\n        ? selectedBody.position.distanceTo(sun.position).toFixed(1)\r\n        : '0.0';\r\n\r\n    const velocity = selectedBody.velocity.length().toFixed(3);\r\n\r\n    return (\r\n        <div className=\"inspector-content\" style={{ padding: '0 20px 20px' }}>\r\n            {/* Header */}\r\n            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '15px' }}>\r\n                <h3 style={{ margin: 0, fontSize: '18px', fontWeight: 600, display: 'flex', alignItems: 'center', gap: '8px', color: 'white' }}>\r\n                    <Settings size={16} color=\"#60a5fa\" />\r\n                    {selectedBody.name}\r\n                </h3>\r\n                <div style={{ display: 'flex', gap: '8px', alignItems: 'center' }}>\r\n                    <ContextHelp topic=\"inspector\" />\r\n                    <button\r\n                        onClick={() => selectBody(null)}\r\n                        style={{\r\n                            background: 'transparent', border: 'none',\r\n                            color: 'rgba(255, 255, 255, 0.5)', cursor: 'pointer',\r\n                            padding: '4px'\r\n                        }}\r\n                        title=\"Close inspector\"\r\n                    >\r\n                        <X size={20} />\r\n                    </button>\r\n                </div>\r\n            </div>\r\n\r\n            <div style={{ display: 'grid', gap: '10px', fontSize: '14px' }}>\r\n                {/* Properties Display (Read Only info always visible) */}\r\n                <div style={{ display: 'flex', justifyContent: 'space-between' }}>\r\n                    <span style={{ color: '#888' }}>{t('distance_sun')}:</span>\r\n                    <span>{distanceToSun} AU</span>\r\n                </div>\r\n                <div style={{ display: 'flex', justifyContent: 'space-between' }}>\r\n                    <span style={{ color: '#888' }}>{t('orbital_speed')}:</span>\r\n                    <span>{velocity} km/s</span>\r\n                </div>\r\n\r\n                <hr style={{ borderColor: 'rgba(255,255,255,0.1)', width: '100%', margin: '10px 0' }} />\r\n\r\n                {/* Name */}\r\n                <div style={{ marginBottom: '5px' }}>\r\n                    <label style={{ display: 'block', color: '#888', marginBottom: '5px' }}>Name</label>\r\n                    <input\r\n                        type=\"text\"\r\n                        value={selectedBody.name}\r\n                        onChange={(e) => updateBody(selectedBody.id, { name: e.target.value })}\r\n                        onFocus={(e) => {\r\n                            e.target.dataset.startValue = e.target.value;\r\n                        }}\r\n                        onBlur={(e) => {\r\n                            const startValue = e.target.dataset.startValue;\r\n                            if (startValue !== undefined && startValue !== e.target.value) {\r\n                                pushHistoryAction({\r\n                                    type: 'UPDATE',\r\n                                    id: selectedBody.id,\r\n                                    previous: { name: startValue },\r\n                                    current: { name: e.target.value }\r\n                                });\r\n                            }\r\n                        }}\r\n                        className=\"lab-input\"\r\n                        style={{ width: '100%', boxSizing: 'border-box', background: 'rgba(0,0,0,0.3)', border: '1px solid rgba(255,255,255,0.2)', padding: '6px', borderRadius: '4px', color: 'white' }}\r\n                    />\r\n                </div>\r\n\r\n                {/* Mass */}\r\n                <div style={{ marginBottom: '5px' }}>\r\n                    <div style={{ display: 'flex', justifyContent: 'space-between' }}>\r\n                        <label style={{ display: 'block', color: '#888', marginBottom: '5px' }}>\r\n                            {t('mass')} <span style={{ fontSize: '0.8em', color: '#666' }}>(M)</span>\r\n                        </label>\r\n                        <span style={{ fontSize: '10px', color: '#666' }}>10^{Math.log10(selectedBody.mass).toFixed(1)}</span>\r\n                    </div>\r\n                    <input\r\n                        type=\"range\"\r\n                        min=\"-2\" max=\"6\" step=\"0.1\"\r\n                        value={Math.log10(selectedBody.mass > 0 ? selectedBody.mass : 1)}\r\n                        onChange={(e) => updateBody(selectedBody.id, { mass: Math.pow(10, parseFloat(e.target.value)) })}\r\n                        onPointerDown={(e) => {\r\n                            // Store implicit start value from store (since range is log10)\r\n                            // Actually, simpler to just store the actual mass on start\r\n                            // We use a ref or dataset.\r\n                            (e.target as any).dataset.startMass = selectedBody.mass.toString();\r\n                        }}\r\n                        onPointerUp={(e) => {\r\n                            const startMass = parseFloat((e.target as any).dataset.startMass);\r\n                            if (!isNaN(startMass) && startMass !== selectedBody.mass) {\r\n                                pushHistoryAction({\r\n                                    type: 'UPDATE',\r\n                                    id: selectedBody.id,\r\n                                    previous: { mass: startMass },\r\n                                    current: { mass: selectedBody.mass }\r\n                                });\r\n                            }\r\n                        }}\r\n                        className=\"lab-range\"\r\n                        style={{ marginBottom: '5px', width: '100%' }}\r\n                    />\r\n\r\n                    <SafeInput\r\n                        value={selectedBody.mass}\r\n                        onChange={(val) => updateBody(selectedBody.id, { mass: val })}\r\n                        onCommit={(startVal, endVal) => {\r\n                            if (startVal !== endVal) {\r\n                                pushHistoryAction({\r\n                                    type: 'UPDATE',\r\n                                    id: selectedBody.id,\r\n                                    previous: { mass: startVal },\r\n                                    current: { mass: endVal }\r\n                                });\r\n                            }\r\n                        }}\r\n                        min={0.0001}\r\n                        step={0.1}\r\n                        style={{\r\n                            width: '100%', boxSizing: 'border-box',\r\n                            background: 'rgba(0,0,0,0.3)', border: '1px solid rgba(255,255,255,0.2)',\r\n                            padding: '6px', borderRadius: '4px', color: 'white'\r\n                        }}\r\n                    />\r\n                </div>\r\n\r\n                {/* Radius */}\r\n                <div style={{ marginBottom: '5px' }}>\r\n                    <div style={{ display: 'flex', justifyContent: 'space-between' }}>\r\n                        <label style={{ display: 'block', color: '#888', marginBottom: '5px' }}>\r\n                            Radius <span style={{ fontSize: '0.8em', color: '#666' }}>(R)</span>\r\n                        </label>\r\n                        <span style={{ fontSize: '10px', color: '#666' }}>{selectedBody.radius.toFixed(1)}</span>\r\n                    </div>\r\n                    <input\r\n                        type=\"range\"\r\n                        min=\"0.1\" max=\"100\" step=\"0.1\"\r\n                        value={selectedBody.radius}\r\n                        onChange={(e) => updateBody(selectedBody.id, { radius: parseFloat(e.target.value) })}\r\n                        onPointerDown={(e) => {\r\n                            (e.target as any).dataset.startRadius = selectedBody.radius.toString();\r\n                        }}\r\n                        onPointerUp={(e) => {\r\n                            const startRadius = parseFloat((e.target as any).dataset.startRadius);\r\n                            if (!isNaN(startRadius) && startRadius !== selectedBody.radius) {\r\n                                pushHistoryAction({\r\n                                    type: 'UPDATE',\r\n                                    id: selectedBody.id,\r\n                                    previous: { radius: startRadius },\r\n                                    current: { radius: selectedBody.radius }\r\n                                });\r\n                            }\r\n                        }}\r\n                        className=\"lab-range\"\r\n                        style={{ width: '100%' }}\r\n                    />\r\n                </div>\r\n\r\n                {/* Rotation Speed - Now always visible */}\r\n                <div style={{ marginBottom: '5px' }}>\r\n                    <div style={{ display: 'flex', justifyContent: 'space-between' }}>\r\n                        <label style={{ display: 'block', color: '#888', marginBottom: '5px' }}>{t('rotation_speed')}</label>\r\n                    </div>\r\n                    <input\r\n                        type=\"range\"\r\n                        min=\"0\" max=\"10\" step=\"0.1\"\r\n                        value={selectedBody.rotationSpeed || 1.0}\r\n                        onChange={(e) => updateBody(selectedBody.id, { rotationSpeed: parseFloat(e.target.value) })}\r\n                        onPointerDown={(e) => {\r\n                            (e.target as any).dataset.startSpeed = (selectedBody.rotationSpeed || 1.0).toString();\r\n                        }}\r\n                        onPointerUp={(e) => {\r\n                            const startSpeed = parseFloat((e.target as any).dataset.startSpeed);\r\n                            const currentSpeed = selectedBody.rotationSpeed || 1.0;\r\n                            if (!isNaN(startSpeed) && startSpeed !== currentSpeed) {\r\n                                pushHistoryAction({\r\n                                    type: 'UPDATE',\r\n                                    id: selectedBody.id,\r\n                                    previous: { rotationSpeed: startSpeed },\r\n                                    current: { rotationSpeed: currentSpeed }\r\n                                });\r\n                            }\r\n                        }}\r\n                        className=\"lab-range\"\r\n                        style={{ marginBottom: '5px', width: '100%' }}\r\n                    />\r\n                    <SafeInput\r\n                        value={selectedBody.rotationSpeed || 1.0}\r\n                        onChange={(val) => updateBody(selectedBody.id, { rotationSpeed: val })}\r\n                        onCommit={(startVal, endVal) => {\r\n                            if (startVal !== endVal) {\r\n                                pushHistoryAction({\r\n                                    type: 'UPDATE',\r\n                                    id: selectedBody.id,\r\n                                    previous: { rotationSpeed: startVal },\r\n                                    current: { rotationSpeed: endVal }\r\n                                });\r\n                            }\r\n                        }}\r\n                        min={0}\r\n                        step={0.1}\r\n                        style={{ width: '100%', boxSizing: 'border-box', background: 'rgba(0,0,0,0.3)', border: '1px solid rgba(255,255,255,0.2)', padding: '6px', borderRadius: '4px', color: 'white' }}\r\n                    />\r\n                </div>\r\n\r\n                {/* Color */}\r\n                <div style={{ marginBottom: '5px' }}>\r\n                    <label style={{ display: 'block', color: '#888', marginBottom: '5px' }}>{t('color')}</label>\r\n                    <div style={{ display: 'flex', gap: '8px' }}>\r\n                        <input\r\n                            type=\"color\"\r\n                            value={selectedBody.color}\r\n                            onChange={(e) => updateBody(selectedBody.id, { color: e.target.value })}\r\n                            onFocus={(e) => { (e.target as any).dataset.startColor = selectedBody.color; }}\r\n                            onBlur={(e) => {\r\n                                const startColor = (e.target as any).dataset.startColor;\r\n                                if (startColor && startColor !== selectedBody.color) {\r\n                                    pushHistoryAction({\r\n                                        type: 'UPDATE',\r\n                                        id: selectedBody.id,\r\n                                        previous: { color: startColor },\r\n                                        current: { color: selectedBody.color }\r\n                                    });\r\n                                }\r\n                            }}\r\n                            style={{\r\n                                width: '40px', height: '36px', border: 'none', borderRadius: '4px',\r\n                                padding: 0, cursor: 'pointer', background: 'transparent'\r\n                            }}\r\n                        />\r\n                        <input\r\n                            type=\"text\"\r\n                            value={selectedBody.color}\r\n                            onChange={(e) => updateBody(selectedBody.id, { color: e.target.value })}\r\n                            onFocus={(e) => { (e.target as any).dataset.startColor = selectedBody.color; }}\r\n                            onBlur={(e) => {\r\n                                const startColor = (e.target as any).dataset.startColor;\r\n                                if (startColor && startColor !== selectedBody.color) {\r\n                                    pushHistoryAction({\r\n                                        type: 'UPDATE',\r\n                                        id: selectedBody.id,\r\n                                        previous: { color: startColor },\r\n                                        current: { color: selectedBody.color }\r\n                                    });\r\n                                }\r\n                            }}\r\n                            style={{ flex: 1, background: 'rgba(0,0,0,0.3)', border: '1px solid rgba(255,255,255,0.2)', padding: '6px', borderRadius: '4px', color: 'white' }}\r\n                        />\r\n                    </div>\r\n                </div>\r\n\r\n                {/* Physics & Vectors */}\r\n                <hr style={{ borderColor: 'rgba(255,255,255,0.1)', width: '100%', margin: '10px 0' }} />\r\n                <button\r\n                    onClick={() => setIsAdvancedOpen(!isAdvancedOpen)}\r\n                    style={{\r\n                        background: 'transparent', border: 'none', color: '#60a5fa',\r\n                        display: 'flex', alignItems: 'center', justifyContent: 'space-between',\r\n                        width: '100%', padding: '5px 0', cursor: 'pointer', fontSize: '12px', fontWeight: 600, letterSpacing: '1px'\r\n                    }}\r\n                >\r\n                    VECTORS & PHYSICS\r\n                    {isAdvancedOpen ? <ChevronUp size={14} /> : <ChevronDown size={14} />}\r\n                </button>\r\n\r\n                {isAdvancedOpen && (\r\n                    <div style={{ marginTop: '10px' }}>\r\n                        <VectorInput\r\n                            label=\"Position\"\r\n                            value={selectedBody.position}\r\n                            onChange={(v) => updateBody(selectedBody.id, { position: v })}\r\n                            onCommit={(startV, endV) => {\r\n                                // Need deep comparison or assume change if committed\r\n                                if (!startV.equals(endV)) {\r\n                                    pushHistoryAction({\r\n                                        type: 'UPDATE',\r\n                                        id: selectedBody.id,\r\n                                        previous: { position: startV },\r\n                                        current: { position: endV }\r\n                                    });\r\n                                }\r\n                            }}\r\n                        />\r\n                        <div style={{ height: '10px' }} />\r\n                        <VectorInput\r\n                            label=\"Velocity\"\r\n                            value={selectedBody.velocity}\r\n                            onChange={(v) => updateBody(selectedBody.id, { velocity: v })}\r\n                            onCommit={(startV, endV) => {\r\n                                if (!startV.equals(endV)) {\r\n                                    pushHistoryAction({\r\n                                        type: 'UPDATE',\r\n                                        id: selectedBody.id,\r\n                                        previous: { velocity: startV },\r\n                                        current: { velocity: endV }\r\n                                    });\r\n                                }\r\n                            }}\r\n                        />\r\n                    </div>\r\n                )}\r\n\r\n                {/* Actions */}\r\n                <div style={{ marginTop: '10px', display: 'flex', gap: '8px' }}>\r\n                    <button\r\n                        onClick={() => setFollowingBody(followingBodyId === selectedBody.id ? null : selectedBody.id)}\r\n                        style={{\r\n                            flex: 1, padding: '8px',\r\n                            background: followingBodyId === selectedBody.id ? 'rgba(34, 170, 255, 0.3)' : 'rgba(255, 255, 255, 0.1)',\r\n                            border: `1px solid ${followingBodyId === selectedBody.id ? '#22aaff' : 'rgba(255, 255, 255, 0.2)'}`,\r\n                            borderRadius: '6px', color: 'white', cursor: 'pointer', transition: 'all 0.2s', fontWeight: 500, fontSize: '0.9rem'\r\n                        }}\r\n                    >\r\n                        {followingBodyId === selectedBody.id ? t('stop_following') : t('camera_follow')}\r\n                    </button>\r\n                    {!selectedBody.isFixed && (\r\n                        <button\r\n                            onClick={() => setShowDeleteModal(true)}\r\n                            style={{\r\n                                padding: '8px', background: 'rgba(255, 64, 80, 0.2)',\r\n                                border: '1px solid rgba(255, 64, 80, 0.4)', borderRadius: '6px',\r\n                                color: '#ff4050', cursor: 'pointer', display: 'flex', alignItems: 'center', justifyContent: 'center'\r\n                            }}\r\n                            title={t('remove')}\r\n                        >\r\n                            <Trash2 size={16} />\r\n                        </button>\r\n                    )}\r\n                </div>\r\n            </div>\r\n\r\n            <ConfirmModal\r\n                isOpen={showDeleteModal}\r\n                title={t('delete_title')}\r\n                message={t('delete_message').replace('{name}', selectedBody.name)}\r\n                onConfirm={() => {\r\n                    removeBody(selectedBody.id);\r\n                    showToast(`${selectedBody.name} deleted`, 'success');\r\n                    selectBody(null);\r\n                    setShowDeleteModal(false);\r\n                }}\r\n                onCancel={() => setShowDeleteModal(false)}\r\n                danger={true}\r\n                confirmText={t('delete_confirm')}\r\n                cancelText={t('delete_cancel')}\r\n            />\r\n        </div>\r\n    );\r\n};\r\n\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\yngsw\\dev\\orbit-simulator\\src\\components\\ui\\CompactControls.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\yngsw\\dev\\orbit-simulator\\src\\components\\ui\\DateDisplay.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\yngsw\\dev\\orbit-simulator\\src\\components\\ui\\HelpModal.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":369,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":369,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16674,16677],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16674,16677],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\r\nimport { createPortal } from 'react-dom';\r\nimport { useTranslation } from '../../utils/i18n';\r\nimport { X, HelpCircle, Mouse, Move, Rotate3D, ZoomIn, Info, History } from 'lucide-react';\r\nimport pkg from '../../../package.json';\r\n\r\ninterface HelpModalProps {\r\n    isOpen: boolean;\r\n    onClose: () => void;\r\n}\r\n\r\nexport const HelpModal: React.FC<HelpModalProps> = ({ isOpen, onClose }) => {\r\n    const { t } = useTranslation();\r\n    const [activeTab, setActiveTab] = React.useState<'controls' | 'changelog'>('controls');\r\n\r\n    // Simple responsive check\r\n    const [isMobile, setIsMobile] = React.useState(window.innerWidth < 768);\r\n\r\n    React.useEffect(() => {\r\n        const handleResize = () => setIsMobile(window.innerWidth < 768);\r\n        window.addEventListener('resize', handleResize);\r\n        return () => window.removeEventListener('resize', handleResize);\r\n    }, []);\r\n\r\n    if (!isOpen) return null;\r\n\r\n    return createPortal(\r\n        <div style={{\r\n            position: 'fixed',\r\n            top: 0,\r\n            left: 0,\r\n            width: '100vw',\r\n            height: '100vh',\r\n            background: 'rgba(0,0,0,0.6)',\r\n            zIndex: 2000,\r\n            display: 'flex',\r\n            alignItems: 'center',\r\n            justifyContent: 'center',\r\n            backdropFilter: 'blur(4px)'\r\n        }}>\r\n            <div style={{\r\n                background: 'rgba(10, 10, 15, 0.85)',\r\n                backdropFilter: 'blur(12px)',\r\n                border: '1px solid rgba(255, 255, 255, 0.1)',\r\n                borderRadius: '12px',\r\n                width: '700px',\r\n                maxWidth: '90%',\r\n                height: '500px',\r\n                maxHeight: '80vh',\r\n                display: 'flex',\r\n                flexDirection: 'column',\r\n                boxShadow: '0 8px 32px 0 rgba(0, 0, 0, 0.3)',\r\n                color: 'white',\r\n                overflow: 'hidden'\r\n            }}>\r\n                {/* Header */}\r\n                <div style={{\r\n                    padding: '16px 24px',\r\n                    borderBottom: '1px solid rgba(255,255,255,0.1)',\r\n                    display: 'flex',\r\n                    alignItems: 'center',\r\n                    justifyContent: 'space-between',\r\n                    background: 'rgba(255,255,255,0.02)',\r\n                    flexShrink: 0 // Keep header fixed size\r\n                }}>\r\n                    <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>\r\n                        <HelpCircle size={20} color=\"#3b82f6\" />\r\n                        <h2 style={{ margin: 0, fontSize: '1.1rem', fontWeight: 600, letterSpacing: '0.02em' }}>{t('help_title')}</h2>\r\n                    </div>\r\n                    <button\r\n                        onClick={onClose}\r\n                        style={{\r\n                            background: 'none',\r\n                            border: 'none',\r\n                            color: '#94a3b8',\r\n                            cursor: 'pointer',\r\n                            padding: '4px',\r\n                            display: 'flex',\r\n                            alignItems: 'center',\r\n                            transition: 'color 0.2s'\r\n                        }}\r\n                        onMouseEnter={(e) => e.currentTarget.style.color = 'white'}\r\n                        onMouseLeave={(e) => e.currentTarget.style.color = '#94a3b8'}\r\n                    >\r\n                        <X size={20} />\r\n                    </button>\r\n                </div>\r\n\r\n                {/* Content Wrapper */}\r\n                <div style={{\r\n                    display: 'flex',\r\n                    flex: 1,\r\n                    minHeight: 0,\r\n                    flexDirection: isMobile ? 'column' : 'row'\r\n                }}>\r\n\r\n                    {/* Sidebar / Tabs */}\r\n                    <div style={{\r\n                        width: isMobile ? '100%' : '200px',\r\n                        minWidth: isMobile ? '100%' : '200px',\r\n                        borderRight: isMobile ? 'none' : '1px solid rgba(255,255,255,0.1)',\r\n                        borderBottom: isMobile ? '1px solid rgba(255,255,255,0.1)' : 'none',\r\n                        background: 'rgba(0,0,0,0.2)',\r\n                        padding: isMobile ? '0' : '16px 0',\r\n                        display: 'flex',\r\n                        flexDirection: isMobile ? 'row' : 'column',\r\n                        flexShrink: 0,\r\n                        overflowX: isMobile ? 'auto' : 'hidden' // Scroll tabs horizontally if needed\r\n                    }}>\r\n                        <TabButton\r\n                            active={activeTab === 'controls'}\r\n                            onClick={() => setActiveTab('controls')}\r\n                            icon={<Mouse size={16} />}\r\n                            label={t('controls_header')}\r\n                            isMobile={isMobile}\r\n                        />\r\n                        <TabButton\r\n                            active={activeTab === 'changelog'}\r\n                            onClick={() => setActiveTab('changelog')}\r\n                            icon={<History size={16} />}\r\n                            label={t('changelog_header')}\r\n                            isMobile={isMobile}\r\n                        />\r\n\r\n                        {!isMobile && <div style={{ flex: 1 }} />} {/* Spacer only for desktop */}\r\n\r\n                        {/* Info Block */}\r\n                        <div style={{\r\n                            padding: isMobile ? '0 16px' : '16px',\r\n                            borderTop: isMobile ? 'none' : '1px solid rgba(255,255,255,0.05)',\r\n                            display: isMobile ? 'flex' : 'block',\r\n                            alignItems: 'center',\r\n                            marginLeft: isMobile ? 'auto' : 0\r\n                        }}>\r\n                            <div style={{\r\n                                display: 'flex',\r\n                                alignItems: 'center',\r\n                                gap: '8px',\r\n                                fontSize: '0.75rem',\r\n                                color: '#64748b',\r\n                                background: 'rgba(255,255,255,0.03)',\r\n                                padding: '8px 12px',\r\n                                borderRadius: '6px',\r\n                                justifyContent: 'center'\r\n                            }}>\r\n                                <Info size={14} />\r\n                                <span style={{ fontFamily: 'var(--font-mono)' }}>v{pkg.version}</span>\r\n                            </div>\r\n                        </div>\r\n                    </div>\r\n\r\n                    {/* Main Panel */}\r\n                    <div style={{\r\n                        flex: 1,\r\n                        padding: '24px',\r\n                        overflowY: 'auto' // Vertical Scroll\r\n                    }}>\r\n\r\n                        {/* Tab Content starts at the very top for both */}\r\n\r\n                        {activeTab === 'controls' && (\r\n                            <div style={{ display: 'flex', flexDirection: 'column', gap: '20px' }}>\r\n                                {/* Camera Controls */}\r\n                                <div>\r\n                                    <h3 style={{\r\n                                        margin: '0 0 12px 0',\r\n                                        fontSize: '0.85rem',\r\n                                        color: '#64748b',\r\n                                        fontWeight: 600,\r\n                                        letterSpacing: '0.05em',\r\n                                        textTransform: 'uppercase'\r\n                                    }}>\r\n                                        \r\n                                    </h3>\r\n                                    <div style={{ display: 'flex', flexDirection: 'column', gap: '12px' }}>\r\n                                        <ControlItem icon={<Rotate3D size={18} />} label={t('ctrl_rotate')} desc={t('ctrl_rotate_desc')} />\r\n                                        <ControlItem icon={<Move size={18} />} label={t('ctrl_pan')} desc={t('ctrl_pan_desc')} />\r\n                                        <ControlItem icon={<ZoomIn size={18} />} label={t('ctrl_zoom')} desc={t('ctrl_zoom_desc')} />\r\n                                        <ControlItem icon={<Mouse size={18} />} label={t('ctrl_select')} desc={t('ctrl_select_desc')} />\r\n                                    </div>\r\n                                </div>\r\n\r\n                                {/* Keyboard Shortcuts */}\r\n                                <div>\r\n                                    <h3 style={{\r\n                                        margin: '0 0 12px 0',\r\n                                        fontSize: '0.85rem',\r\n                                        color: '#64748b',\r\n                                        fontWeight: 600,\r\n                                        letterSpacing: '0.05em',\r\n                                        textTransform: 'uppercase'\r\n                                    }}>\r\n                                        \r\n                                    </h3>\r\n                                    <div style={{ display: 'flex', flexDirection: 'column', gap: '12px' }}>\r\n                                        <ShortcutItem shortcut=\"Alt + 1\" desc=\"\" />\r\n                                        <ShortcutItem shortcut=\"Alt + 2\" desc=\"\" />\r\n                                        <ShortcutItem shortcut=\"Alt + 3\" desc=\"\" />\r\n                                        <ShortcutItem shortcut=\"Alt + F\" desc=\"\" />\r\n                                        <ShortcutItem shortcut=\"Ctrl + Z\" desc=\" (Undo)\" />\r\n                                        <ShortcutItem shortcut=\"Ctrl + Shift + Z\" desc=\" (Redo)\" />\r\n                                    </div>\r\n                                </div>\r\n                            </div>\r\n                        )}\r\n\r\n                        {activeTab === 'changelog' && (\r\n                            <div style={{ display: 'flex', flexDirection: 'column', gap: '20px' }}>\r\n                                {getChangelogData(t).map((log, index) => (\r\n                                    <div key={log.version}>\r\n                                        <h4 style={{ margin: '0 0 8px 0', fontSize: '0.9rem', color: log.isCurrent ? '#10b981' : '#64748b', display: 'flex', alignItems: 'center', gap: '8px' }}>\r\n                                            {log.title || `v${log.version}`}\r\n                                            {log.isCurrent && <span style={{ fontSize: '0.7rem', color: '#94a3b8', fontWeight: 'normal' }}>Current</span>}\r\n                                        </h4>\r\n                                        <div style={{\r\n                                            background: 'rgba(255,255,255,0.02)',\r\n                                            borderRadius: '8px',\r\n                                            padding: '16px',\r\n                                            border: '1px solid rgba(255,255,255,0.05)',\r\n                                            opacity: index > 2 ? 0.7 : 1\r\n                                        }}>\r\n                                            <ul style={{ paddingLeft: '20px', margin: 0, color: '#e2e8f0', lineHeight: 1.8, fontSize: '0.9rem' }}>\r\n                                                {log.changes.map((change, i) => (\r\n                                                    <li key={i} style={{ marginBottom: i === log.changes.length - 1 ? 0 : '8px' }}>\r\n                                                        <ChangeBadge type={change.type} />\r\n                                                        {change.content}\r\n                                                    </li>\r\n                                                ))}\r\n                                            </ul>\r\n                                        </div>\r\n                                    </div>\r\n                                ))}\r\n                            </div>\r\n                        )}\r\n                    </div>\r\n                </div>\r\n            </div>\r\n        </div>,\r\n        document.body\r\n    );\r\n};\r\n\r\n// --- Sub Components ---\r\n\r\nconst TabButton = ({ active, onClick, icon, label, isMobile }: { active: boolean, onClick: () => void, icon: React.ReactNode, label: string, isMobile: boolean }) => (\r\n    <button\r\n        onClick={onClick}\r\n        style={{\r\n            display: 'flex',\r\n            alignItems: 'center',\r\n            gap: '10px',\r\n            padding: isMobile ? '12px 16px' : '10px 20px',\r\n            width: isMobile ? 'auto' : '100%',\r\n            flex: isMobile ? 1 : 'none',\r\n            justifyContent: isMobile ? 'center' : 'flex-start',\r\n            background: active ? 'rgba(59, 130, 246, 0.1)' : 'transparent',\r\n            border: 'none',\r\n            borderLeft: (!isMobile && active) ? '3px solid #3b82f6' : '3px solid transparent',\r\n            borderBottom: (isMobile && active) ? '3px solid #3b82f6' : '3px solid transparent',\r\n            color: active ? '#3b82f6' : '#94a3b8',\r\n            cursor: 'pointer',\r\n            fontSize: '0.9rem',\r\n            transition: 'all 0.2s',\r\n            whiteSpace: 'nowrap'\r\n        }}\r\n    >\r\n        {icon}\r\n        {label}\r\n    </button>\r\n);\r\n\r\nconst ControlItem = ({ icon, label, desc }: { icon: React.ReactNode, label: string, desc: string }) => (\r\n    <div style={{\r\n        display: 'flex',\r\n        alignItems: 'center',\r\n        gap: '16px',\r\n        padding: '12px 16px',\r\n        background: 'rgba(255,255,255,0.02)',\r\n        borderRadius: '8px',\r\n        border: '1px solid rgba(255,255,255,0.03)',\r\n        transition: 'background 0.2s'\r\n    }}\r\n        onMouseEnter={(e) => e.currentTarget.style.background = 'rgba(255,255,255,0.05)'}\r\n        onMouseLeave={(e) => e.currentTarget.style.background = 'rgba(255,255,255,0.02)'}\r\n    >\r\n        <div style={{ color: '#3b82f6', opacity: 0.9 }}>{icon}</div>\r\n        <div style={{ flex: 1 }}>\r\n            <div style={{ fontWeight: 500, fontSize: '0.9rem', color: '#f1f5f9' }}>{label}</div>\r\n            <div style={{ fontSize: '0.8rem', color: '#94a3b8' }}>{desc}</div>\r\n        </div>\r\n    </div>\r\n);\r\n\r\nconst ShortcutItem = ({ shortcut, desc }: { shortcut: string, desc: string }) => (\r\n    <div style={{\r\n        display: 'flex',\r\n        alignItems: 'center',\r\n        justifyContent: 'space-between',\r\n        padding: '10px 16px',\r\n        background: 'rgba(255,255,255,0.02)',\r\n        borderRadius: '8px',\r\n        border: '1px solid rgba(255,255,255,0.03)',\r\n        transition: 'background 0.2s'\r\n    }}\r\n        onMouseEnter={(e) => e.currentTarget.style.background = 'rgba(255,255,255,0.05)'}\r\n        onMouseLeave={(e) => e.currentTarget.style.background = 'rgba(255,255,255,0.02)'}\r\n    >\r\n        <div style={{ fontSize: '0.85rem', color: '#94a3b8' }}>{desc}</div>\r\n        <div style={{\r\n            fontFamily: 'var(--font-mono)',\r\n            fontSize: '0.8rem',\r\n            color: '#3b82f6',\r\n            background: 'rgba(59, 130, 246, 0.1)',\r\n            padding: '4px 10px',\r\n            borderRadius: '4px',\r\n            border: '1px solid rgba(59, 130, 246, 0.2)',\r\n            whiteSpace: 'nowrap'\r\n        }}>\r\n            {shortcut}\r\n        </div>\r\n    </div>\r\n);\r\n\r\n// --- Changelog Data & types ---\r\n\r\ntype ChangeType = 'new' | 'improve' | 'fix' | 'remove' | 'tech' | 'none';\r\n\r\ninterface ChangeItemData {\r\n    type: ChangeType;\r\n    content: string;\r\n}\r\n\r\ninterface VersionLog {\r\n    version: string;\r\n    title?: string;\r\n    isCurrent?: boolean;\r\n    changes: ChangeItemData[];\r\n}\r\n\r\nconst ChangeBadge = ({ type }: { type: ChangeType }) => {\r\n    if (type === 'none') return null;\r\n\r\n    let color = '#94a3b8';\r\n    let label = 'Other';\r\n\r\n    switch (type) {\r\n        case 'new': color = '#10b981'; label = ''; break;\r\n        case 'improve': color = '#3b82f6'; label = ''; break;\r\n        case 'fix': color = '#a855f7'; label = ''; break;\r\n        case 'remove': color = '#ef4444'; label = ''; break;\r\n        case 'tech': color = '#f59e0b'; label = ''; break;\r\n    }\r\n\r\n    return (\r\n        <span style={{\r\n            color: color,\r\n            fontWeight: 'bold',\r\n            fontSize: '0.75rem',\r\n            border: `1px solid ${color}4d`, // 30% alpha roughly\r\n            padding: '1px 4px',\r\n            borderRadius: '4px',\r\n            marginRight: '8px'\r\n        }}>\r\n            {label}\r\n        </span>\r\n    );\r\n};\r\n\r\nconst getChangelogData = (t: any): VersionLog[] => [\r\n    {\r\n        version: '0.5.0',\r\n        isCurrent: true,\r\n        changes: [\r\n            { type: 'new', content: '' },\r\n            { type: 'new', content: '' },\r\n            { type: 'new', content: '' }\r\n        ]\r\n    },\r\n    {\r\n        version: '0.4.1',\r\n        changes: [\r\n            { type: 'improve', content: ' (8)' },\r\n            { type: 'new', content: '' },\r\n            { type: 'fix', content: '' }\r\n        ]\r\n    },\r\n    {\r\n        version: '0.4.0',\r\n        title: t('cl_v0_4_0_title'),\r\n        changes: [\r\n            { type: 'improve', content: t('cl_item_compact') },\r\n            { type: 'new', content: t('cl_item_zen') },\r\n            { type: 'tech', content: t('cl_item_ui') },\r\n            { type: 'new', content: t('cl_item_gallery') }\r\n        ]\r\n    },\r\n    {\r\n        version: '0.3.0',\r\n        title: t('cl_v0_3_0_title'),\r\n        changes: [\r\n            { type: 'improve', content: t('cl_item_energy') },\r\n            { type: 'new', content: t('cl_item_hybrid') },\r\n            { type: 'tech', content: t('cl_item_cleanup') }\r\n        ]\r\n    },\r\n    {\r\n        version: '0.2.1',\r\n        title: t('cl_v0_2_1_title'),\r\n        changes: [\r\n            { type: 'improve', content: t('cl_item_surface') },\r\n            { type: 'new', content: t('cl_item_perf') },\r\n            { type: 'tech', content: t('cl_item_physics') }\r\n        ]\r\n    },\r\n    {\r\n        version: '0.2.0',\r\n        changes: [\r\n            { type: 'improve', content: ' (11)' },\r\n            { type: 'new', content: ' ()' },\r\n            { type: 'fix', content: '' },\r\n            { type: 'tech', content: 'WebGPU ()' }\r\n        ]\r\n    },\r\n    {\r\n        version: '0.1.0',\r\n        changes: [\r\n            { type: 'new', content: '' },\r\n            { type: 'none', content: ' (Barnes-Hut, WebWorker, WebGPU)' },\r\n            { type: 'none', content: 'UI ()' }\r\n        ]\r\n    }\r\n];\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\yngsw\\dev\\orbit-simulator\\src\\components\\ui\\PerformanceStats.tsx","messages":[{"ruleId":"react-hooks/purity","severity":2,"message":"Error: Cannot call impure function during render\n\n`performance.now` is an impure function. Calling an impure function can produce unstable results that update unpredictably when the component happens to re-render. (https://react.dev/reference/rules/components-and-hooks-must-be-pure#components-and-hooks-must-be-idempotent).\n\nC:\\Users\\yngsw\\dev\\orbit-simulator\\src\\components\\ui\\PerformanceStats.tsx:10:32\n   8 |     const statsRef = useRef<HTMLDivElement>(null);\n   9 |     const fpsRef = useRef(0);\n> 10 |     const lastTimeRef = useRef(performance.now());\n     |                                ^^^^^^^^^^^^^^^^^ Cannot call impure function\n  11 |     const frameCountRef = useRef(0);\n  12 |     const { t, lang } = useTranslation();\n  13 |","line":10,"column":32,"nodeType":null,"endLine":10,"endColumn":49},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":41,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":41,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1742,1745],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1742,1745],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useEffect, useRef } from 'react';\r\nimport { physicsStats, usePhysicsStore } from '../../store/physicsStore';\r\nimport { useTranslation } from '../../utils/i18n';\r\n\r\n// PhysicsStats component\r\nexport const PerformanceStats = () => {\r\n    const zenMode = usePhysicsStore(state => state.zenMode);\r\n    const statsRef = useRef<HTMLDivElement>(null);\r\n    const fpsRef = useRef(0);\r\n    const lastTimeRef = useRef(performance.now());\r\n    const frameCountRef = useRef(0);\r\n    const { t, lang } = useTranslation();\r\n\r\n    useEffect(() => {\r\n        if (zenMode) return;\r\n\r\n        let animationFrameId: number;\r\n\r\n        const loop = () => {\r\n            const now = performance.now();\r\n            frameCountRef.current++;\r\n            const elapsed = now - lastTimeRef.current;\r\n\r\n            if (elapsed >= 500) { // Update 2 times per second\r\n                fpsRef.current = Math.round((frameCountRef.current * 1000) / elapsed);\r\n                frameCountRef.current = 0;\r\n                lastTimeRef.current = now;\r\n            }\r\n\r\n            if (statsRef.current && !zenMode) {\r\n                const { physicsDuration, bodyCount, mode, energy } = physicsStats;\r\n                const fps = fpsRef.current;\r\n\r\n                const absDrift = Math.abs(energy.drift);\r\n                // Drift Color: < 0.01% Green, < 1% Yellow, > 1% Red\r\n                const driftColor = absDrift < 0.0001 ? '#44ff44' : (absDrift < 0.01 ? '#ffff44' : '#ff4444');\r\n                const driftText = (energy.drift * 100).toFixed(4) + '%';\r\n                const totalText = energy.total.toExponential(4);\r\n\r\n                // Correctly typed cameraPosition from the extended physicsStats object\r\n                const camPos = (physicsStats as any).cameraPosition || [0, 0, 0];\r\n                const camText = `[${Math.round(camPos[0])}, ${Math.round(camPos[1])}, ${Math.round(camPos[2])}]`;\r\n\r\n                // Direct DOM manipulation for minimal React overhead on high-frequency data\r\n                statsRef.current.innerHTML = `\r\n                    <div style=\"font-weight: bold; margin-bottom: 4px;\">${t('perf_stats')}</div>\r\n                    <div style=\"display: flex; justify-content: space-between; gap: 12px;\">\r\n                        <span>${t('perf_fps')}:</span> <span style=\"color: ${fps < 30 ? '#ff4444' : '#44ff44'}\">${fps}</span>\r\n                    </div>\r\n                    <div style=\"display: flex; justify-content: space-between;\">\r\n                        <span>Cam:</span> <span style=\"font-family: monospace; color: #aaaaff;\">${camText}</span>\r\n                    </div>\r\n                    <div style=\"display: flex; justify-content: space-between;\">\r\n                        <span>${t('perf_mode')}:</span> <span style=\"color: #44aaff\">${mode}</span>\r\n                    </div>\r\n                    <div style=\"display: flex; justify-content: space-between;\">\r\n                        <span>${t('perf_bodies')}:</span> <span>${bodyCount}</span>\r\n                    </div>\r\n                    <div style=\"display: flex; justify-content: space-between;\">\r\n                        <span>${t('perf_physics')}:</span> <span>${physicsDuration.toFixed(1)}ms</span>\r\n                    </div>\r\n                    <hr style=\"border: 0; border-top: 1px solid rgba(255,255,255,0.1); margin: 4px 0;\" />\r\n                    <div style=\"display: flex; justify-content: space-between;\">\r\n                        <span>${t('perf_energy')}:</span> <span style=\"font-family: monospace; font-size: 0.9em;\">${totalText}</span>\r\n                    </div>\r\n                    <div style=\"display: flex; justify-content: space-between;\">\r\n                        <span>${t('perf_error')}:</span> <span style=\"font-family: monospace; font-size: 0.9em; color: ${driftColor}\">${driftText}</span>\r\n                    </div>\r\n                    <div style=\"font-size: 0.85em; opacity: 0.7; margin-top: 4px; display: flex; flex-direction: column; gap: 2px;\">\r\n                       <div style=\"display: flex; justify-content: space-between;\"><span>${t('perf_kinetic')}:</span> <span>${energy.kinetic.toExponential(2)}</span></div>\r\n                       <div style=\"display: flex; justify-content: space-between;\"><span>${t('perf_potential')}:</span> <span>${energy.potential.toExponential(2)}</span></div>\r\n                    </div>\r\n                `;\r\n            }\r\n\r\n            animationFrameId = requestAnimationFrame(loop);\r\n        };\r\n\r\n        loop();\r\n\r\n        return () => {\r\n            cancelAnimationFrame(animationFrameId);\r\n        };\r\n    }, [t, lang, zenMode]);\r\n\r\n    if (zenMode) return null;\r\n\r\n    return (\r\n        <div\r\n            ref={statsRef}\r\n            style={{\r\n                position: 'absolute',\r\n                bottom: '250px',\r\n                left: '10px',\r\n                background: 'rgba(20, 30, 40, 0.1)', // More transparent\r\n                backdropFilter: 'blur(4px)', // Glass effect\r\n                padding: '12px',\r\n                borderRadius: '8px',\r\n                color: '#e0e0e0',\r\n                fontFamily: 'Inter, system-ui, sans-serif',\r\n                fontSize: '12px',\r\n                border: '1px solid rgba(255, 255, 255, 0.1)',\r\n                width: '220px',\r\n                boxShadow: '0 4px 12px rgba(0, 0, 0, 0.3)',\r\n                pointerEvents: 'none', // Allow clicking through\r\n                zIndex: 1000,\r\n                userSelect: 'none'\r\n            }}\r\n        />\r\n    );\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\yngsw\\dev\\orbit-simulator\\src\\components\\ui\\SimulationControls.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":277,"column":84,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":277,"endColumn":87,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13927,13930],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13927,13930],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState } from 'react';\r\nimport { usePhysicsStore } from '../../store/physicsStore';\r\nimport { Play, Pause, RefreshCw, AlertCircle, Trash2, Zap, LayoutGrid, Undo, Redo } from 'lucide-react';\r\nimport { useTranslation } from '../../utils/i18n';\r\nimport { StarSystemGallery } from './StarSystemGallery';\r\nimport { ContextHelp } from './common/ContextHelp';\r\n\r\nexport const SimulationControls: React.FC = () => {\r\n    const simulationState = usePhysicsStore((state) => state.simulationState);\r\n    const timeScale = usePhysicsStore((state) => state.timeScale);\r\n    const setSimulationState = usePhysicsStore((state) => state.setSimulationState);\r\n    const setTimeScale = usePhysicsStore((state) => state.setTimeScale);\r\n    const reset = usePhysicsStore((state) => state.reset);\r\n    const followingBodyId = usePhysicsStore((state) => state.followingBodyId);\r\n    const removeBody = usePhysicsStore((state) => state.removeBody);\r\n    const cameraMode = usePhysicsStore((state) => state.cameraMode);\r\n    const setCameraMode = usePhysicsStore((state) => state.setCameraMode);\r\n    const undo = usePhysicsStore((state) => state.undo);\r\n    const redo = usePhysicsStore((state) => state.redo);\r\n    const historyIndex = usePhysicsStore((state) => state.historyIndex);\r\n    const history = usePhysicsStore((state) => state.history);\r\n    const { t } = useTranslation();\r\n\r\n    const [showGallery, setShowGallery] = useState(false);\r\n\r\n    const togglePause = () => {\r\n        setSimulationState(simulationState === 'running' ? 'paused' : 'running');\r\n    };\r\n\r\n    return (\r\n        <div style={{\r\n            display: 'flex',\r\n            flexDirection: 'column',\r\n            gap: '12px',\r\n            width: '100%'\r\n        }}>\r\n            {/* Header */}\r\n            <div style={{\r\n                marginBottom: '4px',\r\n                borderBottom: '1px solid rgba(255,255,255,0.1)',\r\n                paddingBottom: '8px',\r\n                display: 'flex',\r\n                justifyContent: 'flex-end',\r\n                alignItems: 'center'\r\n            }}>\r\n                <ContextHelp topic=\"controls\" />\r\n            </div>\r\n\r\n            <div style={{ display: 'flex', gap: '8px' }} className=\"sim-controls-buttons\">\r\n                <button\r\n                    onClick={togglePause}\r\n                    style={{\r\n                        flex: 1,\r\n                        display: 'flex',\r\n                        alignItems: 'center',\r\n                        justifyContent: 'center',\r\n                        gap: '8px',\r\n                        background: simulationState === 'running' ? '#ff4050' : '#00ce7c',\r\n                        border: 'none',\r\n                        borderRadius: '6px',\r\n                        padding: '8px',\r\n                        color: 'white',\r\n                        cursor: 'pointer',\r\n                        fontWeight: 'bold'\r\n                    }}\r\n                >\r\n                    {simulationState === 'running' ? <Pause size={16} /> : <Play size={16} />}\r\n                    {simulationState === 'running' ? t('pause') : t('resume')}\r\n                </button>\r\n\r\n                <button\r\n                    onClick={reset}\r\n                    style={{\r\n                        background: 'rgba(255, 255, 255, 0.1)',\r\n                        border: 'none',\r\n                        borderRadius: '6px',\r\n                        padding: '8px',\r\n                        color: 'white',\r\n                        cursor: 'pointer',\r\n                        display: 'flex',\r\n                        alignItems: 'center',\r\n                        justifyContent: 'center'\r\n                    }}\r\n                    title={t('reset')}\r\n                >\r\n                    <RefreshCw size={16} />\r\n                </button>\r\n            </div>\r\n\r\n            {/* Undo/Redo Controls */}\r\n            <div style={{ display: 'flex', gap: '8px', marginTop: '4px' }}>\r\n                <button\r\n                    onClick={undo}\r\n                    disabled={historyIndex <= 0}\r\n                    style={{\r\n                        flex: 1,\r\n                        display: 'flex',\r\n                        alignItems: 'center',\r\n                        justifyContent: 'center',\r\n                        gap: '6px',\r\n                        background: historyIndex > 0 ? 'rgba(96, 165, 250, 0.2)' : 'rgba(255, 255, 255, 0.05)',\r\n                        border: `1px solid ${historyIndex > 0 ? 'rgba(96, 165, 250, 0.3)' : 'rgba(255, 255, 255, 0.1)'}`,\r\n                        borderRadius: '6px',\r\n                        padding: '6px 8px',\r\n                        color: historyIndex > 0 ? '#60a5fa' : 'rgba(255, 255, 255, 0.3)',\r\n                        cursor: historyIndex > 0 ? 'pointer' : 'not-allowed',\r\n                        fontSize: '0.85rem',\r\n                        transition: 'all 0.2s'\r\n                    }}\r\n                    title=\"Undo (Ctrl+Z)\"\r\n                >\r\n                    <Undo size={14} />\r\n                    <span>Undo</span>\r\n                </button>\r\n                <button\r\n                    onClick={redo}\r\n                    disabled={historyIndex >= history.length}\r\n                    style={{\r\n                        flex: 1,\r\n                        display: 'flex',\r\n                        alignItems: 'center',\r\n                        justifyContent: 'center',\r\n                        gap: '6px',\r\n                        background: historyIndex < history.length ? 'rgba(96, 165, 250, 0.2)' : 'rgba(255, 255, 255, 0.05)',\r\n                        border: `1px solid ${historyIndex < history.length ? 'rgba(96, 165, 250, 0.3)' : 'rgba(255, 255, 255, 0.1)'}`,\r\n                        borderRadius: '6px',\r\n                        padding: '6px 8px',\r\n                        color: historyIndex < history.length ? '#60a5fa' : 'rgba(255, 255, 255, 0.3)',\r\n                        cursor: historyIndex < history.length ? 'pointer' : 'not-allowed',\r\n                        fontSize: '0.85rem',\r\n                        transition: 'all 0.2s'\r\n                    }}\r\n                    title=\"Redo (Ctrl+Shift+Z)\"\r\n                >\r\n                    <Redo size={14} />\r\n                    <span>Redo</span>\r\n                </button>\r\n            </div>\r\n\r\n            <button\r\n                onClick={() => setShowGallery(true)}\r\n                style={{\r\n                    background: 'rgba(255, 255, 255, 0.1)',\r\n                    border: '1px solid rgba(255, 255, 255, 0.1)',\r\n                    borderRadius: '6px',\r\n                    padding: '8px',\r\n                    color: 'white',\r\n                    cursor: 'pointer',\r\n                    fontSize: '0.8rem',\r\n                    display: 'flex',\r\n                    alignItems: 'center',\r\n                    justifyContent: 'center',\r\n                    gap: '6px'\r\n                }}\r\n            >\r\n                <LayoutGrid size={16} />\r\n                <span>{t('star_system_gallery')}</span>\r\n            </button>\r\n\r\n            <StarSystemGallery\r\n                isOpen={showGallery}\r\n                onClose={() => setShowGallery(false)}\r\n            />\r\n\r\n            <div style={{ display: 'flex', flexDirection: 'column', gap: '4px' }}>\r\n                <label style={{ fontSize: '0.8rem', opacity: 0.7 }}>{t('time_scale')}: {timeScale.toFixed(1)}x</label>\r\n                <input\r\n                    type=\"range\"\r\n                    min=\"0.1\"\r\n                    max=\"5.0\"\r\n                    step=\"0.1\"\r\n                    value={timeScale}\r\n                    onChange={(e) => setTimeScale(parseFloat(e.target.value))}\r\n                    style={{ width: '100%', cursor: 'pointer', accentColor: '#3b82f6' }}\r\n                />\r\n\r\n                {/* Time Elapsed moved to DateDisplay Overlay */}\r\n            </div>\r\n\r\n            <div style={{ display: 'flex', flexDirection: 'column', gap: '8px', marginTop: '10px' }}>\r\n                <label style={{ display: 'flex', alignItems: 'center', gap: '8px', cursor: 'pointer', fontSize: '0.9rem', color: 'white' }}>\r\n                    <input\r\n                        type=\"checkbox\"\r\n                        onChange={() => usePhysicsStore.getState().togglePrediction()}\r\n                        checked={usePhysicsStore(s => s.showPrediction)}\r\n                    />\r\n                    {t('show_prediction')}\r\n                    <div title=\"High performance cost / \" style={{ display: 'flex', alignItems: 'center', color: '#ffb302' }}>\r\n                        <AlertCircle size={14} />\r\n                    </div>\r\n                </label>\r\n                <label style={{ display: 'flex', alignItems: 'center', gap: '8px', cursor: 'pointer', fontSize: '0.9rem', color: 'white' }}>\r\n                    <input\r\n                        type=\"checkbox\"\r\n                        onChange={() => usePhysicsStore.getState().toggleGrid()}\r\n                        checked={usePhysicsStore(s => s.showGrid)}\r\n                    />\r\n                    {t('show_grid')}\r\n                </label>\r\n                <label style={{ display: 'flex', alignItems: 'center', gap: '8px', cursor: 'pointer', fontSize: '0.9rem', color: 'white' }}>\r\n                    <input\r\n                        type=\"checkbox\"\r\n                        onChange={() => usePhysicsStore.getState().toggleRealisticVisuals()}\r\n                        checked={usePhysicsStore(s => s.showRealisticVisuals)}\r\n                    />\r\n                    {t('show_realistic')}\r\n                </label>\r\n                <label style={{ display: 'flex', alignItems: 'center', gap: '8px', cursor: 'pointer', fontSize: '0.9rem', color: 'white' }}>\r\n                    <input\r\n                        type=\"checkbox\"\r\n                        checked={usePhysicsStore(state => state.showHabitableZone)}\r\n                        onChange={() => usePhysicsStore.getState().toggleHabitableZone()}\r\n                    />\r\n                    {t('show_habitable')}\r\n                </label>\r\n                <label style={{ display: 'flex', alignItems: 'center', gap: '8px', cursor: 'pointer', fontSize: '0.9rem', color: 'white' }}>\r\n                    <input\r\n                        type=\"checkbox\"\r\n                        checked={usePhysicsStore(state => state.useRealisticDistances)}\r\n                        onChange={() => usePhysicsStore.getState().toggleRealisticDistances()}\r\n                    />\r\n                    {t('show_realistic_distances')}\r\n                </label>\r\n\r\n                <div style={{ height: '1px', background: 'rgba(255,255,255,0.1)', margin: '4px 0' }} />\r\n\r\n\r\n                <label style={{ display: 'flex', alignItems: 'center', gap: '8px', cursor: 'pointer', fontSize: '0.9rem', color: 'white' }}>\r\n                    <input\r\n                        type=\"checkbox\"\r\n                        checked={usePhysicsStore(state => state.showGravityField)}\r\n                        onChange={() => usePhysicsStore.getState().toggleGravityField()}\r\n                    />\r\n                    {t('show_gravity_field')}\r\n                </label>\r\n                <label style={{ display: 'flex', alignItems: 'center', gap: '8px', cursor: 'pointer', fontSize: '0.9rem', color: 'white' }}>\r\n                    <input\r\n                        type=\"checkbox\"\r\n                        checked={usePhysicsStore(state => state.useMultithreading)}\r\n                        onChange={() => usePhysicsStore.getState().toggleMultithreading()}\r\n                        disabled={!usePhysicsStore.getState().isWorkerSupported}\r\n                    />\r\n                    <span>{t('show_multithreading')}</span>\r\n                    {!usePhysicsStore.getState().isWorkerSupported && <span style={{ fontSize: '0.7rem', color: '#ff4050' }}>(N/A)</span>}\r\n                    {usePhysicsStore.getState().isWorkerSupported && <div style={{ color: '#00ce7c' }}><Zap size={14} fill=\"#00ce7c\" /></div>}\r\n                </label>\r\n                <label style={{ display: 'flex', alignItems: 'center', gap: '8px', cursor: 'pointer', fontSize: '0.9rem', color: 'white' }}>\r\n                    <input\r\n                        type=\"checkbox\"\r\n                        checked={usePhysicsStore(state => state.useGPU)}\r\n                        onChange={() => usePhysicsStore.getState().toggleGPU()}\r\n                        disabled={!usePhysicsStore(s => s.isGPUSupported)}\r\n                    />\r\n                    <span>{t('show_gpu')}</span>\r\n                    {usePhysicsStore(s => s.isGPUSupported) === false && <span style={{ fontSize: '0.7rem', color: '#ff4050' }}>(N/A)</span>}\r\n                    {usePhysicsStore(s => s.isGPUSupported) === true && <div style={{ color: '#00ce7c' }}><Zap size={14} fill=\"#00ce7c\" /></div>}\r\n                </label>\r\n                <label style={{ display: 'flex', alignItems: 'center', gap: '8px', cursor: 'pointer', fontSize: '0.9rem', color: 'white' }}>\r\n                    <input\r\n                        type=\"checkbox\"\r\n                        onChange={() => usePhysicsStore.getState().togglePerformance()}\r\n                        checked={usePhysicsStore(s => s.showPerformance)}\r\n                    />\r\n                    {t('show_performance')}\r\n                </label>\r\n            </div>\r\n\r\n            {/* Camera Mode Choice Chips */}\r\n            <div style={{ display: 'flex', gap: '4px', marginTop: '10px', marginBottom: '8px', flexWrap: 'wrap' }}>\r\n                {[\r\n                    { id: 'free', label: t('camera_mode_free') },\r\n                    { id: 'sun_lock', label: t('camera_mode_sun') },\r\n                    { id: 'surface_lock', label: t('camera_mode_surface') }\r\n                ].map(mode => (\r\n                    <button\r\n                        key={mode.id}\r\n                        onClick={() => followingBodyId && setCameraMode(mode.id as any)}\r\n                        disabled={!followingBodyId && mode.id !== 'free'}\r\n                        style={{\r\n                            flex: '1 0 80px',\r\n                            padding: '4px 2px',\r\n                            fontSize: '0.7rem',\r\n                            background: cameraMode === mode.id ? '#3b82f6' : 'rgba(255,255,255,0.1)',\r\n                            color: 'white',\r\n                            border: 'none',\r\n                            borderRadius: '4px',\r\n                            cursor: followingBodyId ? 'pointer' : 'not-allowed',\r\n                            opacity: (!followingBodyId && mode.id !== 'free') ? 0.5 : 1,\r\n                            transition: 'background 0.2s',\r\n                            textAlign: 'center'\r\n                        }}\r\n                        title={mode.label}\r\n                    >\r\n                        {mode.label}\r\n                    </button>\r\n                ))}\r\n            </div>\r\n\r\n            {/* Body List */}\r\n            <div style={{ display: 'flex', flexDirection: 'column', gap: '4px' }}>\r\n                {/* Removed label: {t('camera_follow')} */}\r\n                <div style={{\r\n                    display: 'flex',\r\n                    flexDirection: 'column',\r\n                    gap: '4px',\r\n                    maxHeight: '200px',\r\n                    overflowY: 'auto',\r\n                    paddingRight: '4px'\r\n                }}>\r\n                    {usePhysicsStore(s => s.bodies).map(body => (\r\n                        <div key={body.id} style={{ display: 'flex', gap: '4px' }}>\r\n                            <button\r\n                                onClick={() => {\r\n                                    if (followingBodyId === body.id) {\r\n                                        usePhysicsStore.getState().setFollowingBody(null);\r\n                                    } else {\r\n                                        usePhysicsStore.getState().setFollowingBody(body.id);\r\n                                    }\r\n                                }}\r\n                                style={{\r\n                                    flex: 1,\r\n                                    display: 'flex',\r\n                                    alignItems: 'center',\r\n                                    justifyContent: 'space-between',\r\n                                    padding: '6px 8px',\r\n                                    background: followingBodyId === body.id ? 'rgba(59, 130, 246, 0.3)' : 'rgba(255, 255, 255, 0.05)',\r\n                                    border: followingBodyId === body.id ? '1px solid #3b82f6' : '1px solid transparent',\r\n                                    borderRadius: '4px',\r\n                                    color: 'white',\r\n                                    cursor: 'pointer',\r\n                                    fontSize: '0.9rem',\r\n                                    transition: 'all 0.2s',\r\n                                    textAlign: 'left'\r\n                                }}\r\n                            >\r\n                                <span style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>\r\n                                    <span style={{\r\n                                        width: '8px',\r\n                                        height: '8px',\r\n                                        borderRadius: '50%',\r\n                                        background: body.color,\r\n                                        boxShadow: `0 0 5px ${body.color}`\r\n                                    }} />\r\n                                    {body.name}\r\n                                </span>\r\n                                {followingBodyId === body.id && <span style={{ fontSize: '0.7rem', opacity: 0.7 }}>On</span>}\r\n                            </button>\r\n\r\n                            {!body.isFixed && (\r\n                                <button\r\n                                    onClick={(e) => {\r\n                                        e.stopPropagation();\r\n                                        removeBody(body.id);\r\n                                        // If following this body, stop following\r\n                                        if (followingBodyId === body.id) {\r\n                                            usePhysicsStore.getState().setFollowingBody(null);\r\n                                        }\r\n                                    }}\r\n                                    style={{\r\n                                        background: 'rgba(255, 64, 80, 0.1)',\r\n                                        border: '1px solid rgba(255, 64, 80, 0.2)',\r\n                                        borderRadius: '4px',\r\n                                        color: '#ff4050',\r\n                                        cursor: 'pointer',\r\n                                        padding: '0 8px',\r\n                                        display: 'flex',\r\n                                        alignItems: 'center',\r\n                                        justifyContent: 'center',\r\n                                        transition: 'background 0.2s'\r\n                                    }}\r\n                                    title={t('remove')}\r\n                                    onMouseOver={(e) => (e.currentTarget.style.background = 'rgba(255, 64, 80, 0.3)')}\r\n                                    onMouseOut={(e) => (e.currentTarget.style.background = 'rgba(255, 64, 80, 0.1)')}\r\n                                >\r\n                                    <Trash2 size={14} />\r\n                                </button>\r\n                            )}\r\n                        </div>\r\n                    ))}\r\n                </div>\r\n            </div>\r\n        </div>\r\n    );\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\yngsw\\dev\\orbit-simulator\\src\\components\\ui\\StarSystemGallery.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\yngsw\\dev\\orbit-simulator\\src\\components\\ui\\TabContent.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\yngsw\\dev\\orbit-simulator\\src\\components\\ui\\TabNavigation.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\yngsw\\dev\\orbit-simulator\\src\\components\\ui\\Tour.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\yngsw\\dev\\orbit-simulator\\src\\components\\ui\\UnifiedBodyCreator.tsx","messages":[{"ruleId":"react-hooks/purity","severity":2,"message":"Error: Cannot call impure function during render\n\n`Math.random` is an impure function. Calling an impure function can produce unstable results that update unpredictably when the component happens to re-render. (https://react.dev/reference/rules/components-and-hooks-must-be-pure#components-and-hooks-must-be-idempotent).\n\nC:\\Users\\yngsw\\dev\\orbit-simulator\\src\\components\\ui\\UnifiedBodyCreator.tsx:23:25\n  21 |\n  22 |     const handlePresetAdd = (type: string) => {\n> 23 |         const offset = (Math.random() - 0.5) * 50;\n     |                         ^^^^^^^^^^^^^ Cannot call impure function\n  24 |         const position = new Vector3(offset, 0, (Math.random() - 0.5) * 50);\n  25 |         let props: any = {\n  26 |             position,","line":23,"column":25,"nodeType":null,"endLine":23,"endColumn":38},{"ruleId":"react-hooks/purity","severity":2,"message":"Error: Cannot call impure function during render\n\n`Math.random` is an impure function. Calling an impure function can produce unstable results that update unpredictably when the component happens to re-render. (https://react.dev/reference/rules/components-and-hooks-must-be-pure#components-and-hooks-must-be-idempotent).\n\nC:\\Users\\yngsw\\dev\\orbit-simulator\\src\\components\\ui\\UnifiedBodyCreator.tsx:24:50\n  22 |     const handlePresetAdd = (type: string) => {\n  23 |         const offset = (Math.random() - 0.5) * 50;\n> 24 |         const position = new Vector3(offset, 0, (Math.random() - 0.5) * 50);\n     |                                                  ^^^^^^^^^^^^^ Cannot call impure function\n  25 |         let props: any = {\n  26 |             position,\n  27 |             velocity: new Vector3(0, 0, 0),","line":24,"column":50,"nodeType":null,"endLine":24,"endColumn":63},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":25,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":25,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[933,936],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[933,936],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState } from 'react';\r\nimport { usePhysicsStore } from '../../store/physicsStore';\r\nimport { Vector3 } from 'three';\r\nimport { useTranslation } from '../../utils/i18n';\r\nimport { Sun, Globe, Disc, Zap } from 'lucide-react';\r\n\r\nexport const UnifiedBodyCreator: React.FC = () => {\r\n    const { t } = useTranslation();\r\n    const addBody = usePhysicsStore((state) => state.addBody);\r\n    const [mode, setMode] = useState<'preset' | 'custom'>('preset');\r\n\r\n    // Custom Mode State\r\n    const [newBody, setNewBody] = useState({\r\n        name: 'New Planet',\r\n        mass: 1.0,\r\n        radius: 0.5,\r\n        color: '#ffffff',\r\n        position: { x: 10, y: 0, z: 0 },\r\n        velocity: { x: 0, y: 0, z: 2 }\r\n    });\r\n\r\n    const handlePresetAdd = (type: string) => {\r\n        const offset = (Math.random() - 0.5) * 50;\r\n        const position = new Vector3(offset, 0, (Math.random() - 0.5) * 50);\r\n        let props: any = {\r\n            position,\r\n            velocity: new Vector3(0, 0, 0),\r\n            name: `New ${type}`\r\n        };\r\n\r\n        switch (type) {\r\n            case 'Star':\r\n                props = { ...props, type: 'star', mass: 10000, radius: 20, color: '#ffaa00', name: 'New Star' };\r\n                break;\r\n            case 'Planet':\r\n                props = { ...props, type: 'planet', mass: 1, radius: 1, color: '#3388ff', name: 'New Planet' };\r\n                break;\r\n            case 'Gas Giant':\r\n                props = { ...props, type: 'planet', mass: 300, radius: 10, color: '#dcb159', name: 'Gas Giant' };\r\n                break;\r\n            case 'Black Hole':\r\n                props = { ...props, type: 'black_hole', mass: 50000, radius: 2, color: '#000000', name: 'Black Hole', isCompactObject: true };\r\n                break;\r\n        }\r\n\r\n        addBody(props);\r\n    };\r\n\r\n    const handleCustomAdd = () => {\r\n        addBody({\r\n            name: newBody.name,\r\n            mass: newBody.mass,\r\n            radius: newBody.radius,\r\n            color: newBody.color,\r\n            position: new Vector3(newBody.position.x, newBody.position.y, newBody.position.z),\r\n            velocity: new Vector3(newBody.velocity.x, newBody.velocity.y, newBody.velocity.z)\r\n        });\r\n    };\r\n\r\n    return (\r\n        <div style={{ marginTop: '20px', borderTop: '1px solid rgba(255,255,255,0.1)', paddingTop: '15px' }}>\r\n            <h3 style={{ fontSize: '14px', marginBottom: '10px', color: 'rgba(255,255,255,0.7)', textTransform: 'uppercase', letterSpacing: '0.05em' }}>\r\n                {t('add_body')}\r\n            </h3>\r\n\r\n            <div style={{ display: 'flex', marginBottom: '15px', background: 'rgba(0,0,0,0.3)', borderRadius: '6px', padding: '2px' }}>\r\n                <button\r\n                    onClick={() => setMode('preset')}\r\n                    style={{\r\n                        flex: 1, padding: '6px', borderRadius: '4px',\r\n                        background: mode === 'preset' ? 'rgba(255,255,255,0.1)' : 'transparent',\r\n                        color: mode === 'preset' ? 'white' : 'rgba(255,255,255,0.4)',\r\n                        border: 'none', cursor: 'pointer', transition: 'all 0.2s'\r\n                    }}\r\n                >\r\n                    {t('preset_mode')}\r\n                </button>\r\n                <button\r\n                    onClick={() => setMode('custom')}\r\n                    style={{\r\n                        flex: 1, padding: '6px', borderRadius: '4px',\r\n                        background: mode === 'custom' ? 'rgba(255,255,255,0.1)' : 'transparent',\r\n                        color: mode === 'custom' ? 'white' : 'rgba(255,255,255,0.4)',\r\n                        border: 'none', cursor: 'pointer', transition: 'all 0.2s'\r\n                    }}\r\n                >\r\n                    {t('custom_mode')}\r\n                </button>\r\n            </div>\r\n\r\n            {mode === 'preset' ? (\r\n                <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '8px' }}>\r\n                    {[\r\n                        { type: 'Star', icon: Sun, color: '#facc15' },\r\n                        { type: 'Planet', icon: Globe, color: '#60a5fa' },\r\n                        { type: 'Gas Giant', icon: Disc, color: '#fdba74' },\r\n                        { type: 'Black Hole', icon: Zap, color: '#c084fc' }\r\n                    ].map(item => (\r\n                        <button\r\n                            key={item.type}\r\n                            onClick={() => handlePresetAdd(item.type)}\r\n                            style={{\r\n                                display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '8px',\r\n                                padding: '12px', background: 'rgba(255,255,255,0.05)',\r\n                                border: '1px solid rgba(255,255,255,0.1)', borderRadius: '8px',\r\n                                color: 'white', cursor: 'pointer', transition: 'all 0.2s'\r\n                            }}\r\n                            onMouseOver={(e) => e.currentTarget.style.background = 'rgba(255,255,255,0.1)'}\r\n                            onMouseOut={(e) => e.currentTarget.style.background = 'rgba(255,255,255,0.05)'}\r\n                        >\r\n                            <item.icon size={24} color={item.color} />\r\n                            <span style={{ fontSize: '12px' }}>{item.type}</span>\r\n                        </button>\r\n                    ))}\r\n                </div>\r\n            ) : (\r\n                <div style={{ display: 'flex', flexDirection: 'column', gap: '10px' }}>\r\n                    <input\r\n                        type=\"text\"\r\n                        value={newBody.name}\r\n                        onChange={e => setNewBody({ ...newBody, name: e.target.value })}\r\n                        placeholder={t('name')}\r\n                        className=\"lab-input\" // Assuming utility class or keep inline\r\n                        style={{ width: '100%', padding: '8px', background: 'rgba(0,0,0,0.3)', border: '1px solid rgba(255,255,255,0.2)', borderRadius: '4px', color: 'white' }}\r\n                    />\r\n\r\n                    <div style={{ display: 'flex', gap: '8px' }}>\r\n                        <div style={{ flex: 1 }}>\r\n                            <label style={{ fontSize: '10px', color: '#888', display: 'block', marginBottom: '2px' }}>{t('mass')}</label>\r\n                            <input\r\n                                type=\"number\"\r\n                                value={newBody.mass}\r\n                                onChange={e => setNewBody({ ...newBody, mass: parseFloat(e.target.value) })}\r\n                                style={{ width: '100%', padding: '6px', background: 'rgba(0,0,0,0.3)', border: '1px solid rgba(255,255,255,0.2)', borderRadius: '4px', color: 'white' }}\r\n                            />\r\n                        </div>\r\n                        <div style={{ flex: 1 }}>\r\n                            <label style={{ fontSize: '10px', color: '#888', display: 'block', marginBottom: '2px' }}>{t('radius')}</label>\r\n                            <input\r\n                                type=\"number\"\r\n                                value={newBody.radius}\r\n                                onChange={e => setNewBody({ ...newBody, radius: parseFloat(e.target.value) })}\r\n                                style={{ width: '100%', padding: '6px', background: 'rgba(0,0,0,0.3)', border: '1px solid rgba(255,255,255,0.2)', borderRadius: '4px', color: 'white' }}\r\n                            />\r\n                        </div>\r\n                    </div>\r\n\r\n                    <button\r\n                        onClick={handleCustomAdd}\r\n                        style={{\r\n                            width: '100%', padding: '10px', marginTop: '5px',\r\n                            background: '#3b82f6', border: 'none', borderRadius: '6px',\r\n                            color: 'white', fontWeight: 600, cursor: 'pointer'\r\n                        }}\r\n                    >\r\n                        {t('create_body')}\r\n                    </button>\r\n                </div>\r\n            )}\r\n        </div>\r\n    );\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\yngsw\\dev\\orbit-simulator\\src\\components\\ui\\UnifiedSidePanel.tsx","messages":[{"ruleId":"react-hooks/set-state-in-effect","severity":2,"message":"Error: Calling setState synchronously within an effect can trigger cascading renders\n\nEffects are intended to synchronize state between React and external systems such as manually updating the DOM, state management libraries, or other platform APIs. In general, the body of an effect should do one or both of the following:\n* Update external systems with the latest state from React.\n* Subscribe for updates from some external system, calling setState in a callback function when external state changes.\n\nCalling setState synchronously within an effect body causes cascading renders that can hurt performance, and is not recommended. (https://react.dev/learn/you-might-not-need-an-effect).\n\nC:\\Users\\yngsw\\dev\\orbit-simulator\\src\\components\\ui\\UnifiedSidePanel.tsx:26:13\n  24 |     useEffect(() => {\n  25 |         if (selectedBodyId) {\n> 26 |             setActiveTab('inspector');\n     |             ^^^^^^^^^^^^ Avoid calling setState() directly within an effect\n  27 |             if (!isOpen) setIsOpen(true);\n  28 |         }\n  29 |     }, [selectedBodyId]);","line":26,"column":13,"nodeType":null,"endLine":26,"endColumn":25},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'isOpen'. Either include it or remove the dependency array.","line":29,"column":8,"nodeType":"ArrayExpression","endLine":29,"endColumn":24,"suggestions":[{"desc":"Update the dependencies array to be: [isOpen, selectedBodyId]","fix":{"range":[1174,1190],"text":"[isOpen, selectedBodyId]"}}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect } from 'react';\r\nimport { usePhysicsStore } from '../../store/physicsStore';\r\nimport { TabNavigation, type TabId } from './TabNavigation';\r\nimport { TabContent } from './TabContent';\r\nimport './UnifiedSidePanel.css';\r\nimport { CompactControls } from './CompactControls';\r\nimport { HelpCircle } from 'lucide-react';\r\nimport { HelpModal } from './HelpModal';\r\nimport { useTranslation } from '../../utils/i18n';\r\n\r\ninterface UnifiedSidePanelProps {\r\n    defaultTab?: TabId;\r\n}\r\n\r\nexport const UnifiedSidePanel: React.FC<UnifiedSidePanelProps> = ({ defaultTab = 'controls' }) => {\r\n    const [activeTab, setActiveTab] = useState<TabId>(defaultTab);\r\n    const [isOpen, setIsOpen] = useState(true);\r\n    const [showHelp, setShowHelp] = useState(false);\r\n    const zenMode = usePhysicsStore(state => state.zenMode);\r\n    const selectedBodyId = usePhysicsStore(state => state.selectedBodyId);\r\n    const { t } = useTranslation();\r\n\r\n    // Auto-switch to inspector when a body is selected\r\n    useEffect(() => {\r\n        if (selectedBodyId) {\r\n            setActiveTab('inspector');\r\n            if (!isOpen) setIsOpen(true);\r\n        }\r\n    }, [selectedBodyId]);\r\n\r\n    // Keyboard Shortcuts\r\n    useEffect(() => {\r\n        const handleKeyDown = (e: KeyboardEvent) => {\r\n            // Check if user is typing in an input\r\n            const activeElement = document.activeElement;\r\n            const isTyping = activeElement?.tagName === 'INPUT' || activeElement?.tagName === 'TEXTAREA';\r\n\r\n            // Alt+Number for tab switching\r\n            if (e.altKey) {\r\n                if (e.key === '1') { setActiveTab('controls'); e.preventDefault(); }\r\n                if (e.key === '2') { setActiveTab('bodies'); e.preventDefault(); }\r\n                if (e.key === '3') { setActiveTab('inspector'); e.preventDefault(); }\r\n                if (e.key === 'f') {\r\n                    setActiveTab('bodies');\r\n                    e.preventDefault();\r\n                    setTimeout(() => {\r\n                        const searchInput = document.querySelector('.lab-search input') as HTMLInputElement;\r\n                        if (searchInput) searchInput.focus();\r\n                    }, 50);\r\n                }\r\n            }\r\n\r\n            // Ctrl+Z / Ctrl+Shift+Z for Undo/Redo (only when not typing)\r\n            if (!isTyping && (e.ctrlKey || e.metaKey)) {\r\n                const store = usePhysicsStore.getState();\r\n                if (e.key === 'z' && !e.shiftKey) {\r\n                    store.undo();\r\n                    e.preventDefault();\r\n                }\r\n                if (e.key === 'z' && e.shiftKey) {\r\n                    store.redo();\r\n                    e.preventDefault();\r\n                }\r\n            }\r\n        };\r\n\r\n        window.addEventListener('keydown', handleKeyDown);\r\n        return () => window.removeEventListener('keydown', handleKeyDown);\r\n    }, []);\r\n\r\n    if (zenMode) return null; // ZenMode handled elsewhere or completely hidden\r\n\r\n    return (\r\n        <>\r\n            {/* Help Button (visible when panel is closed) */}\r\n            <button\r\n                onClick={() => setShowHelp(true)}\r\n                style={{\r\n                    position: 'absolute',\r\n                    top: 10,\r\n                    right: 70,\r\n                    zIndex: 1001,\r\n                    background: 'rgba(20, 20, 30, 0.8)',\r\n                    border: '1px solid rgba(255, 255, 255, 0.2)',\r\n                    color: 'white',\r\n                    padding: '12px',\r\n                    borderRadius: '8px',\r\n                    cursor: 'pointer',\r\n                    display: 'flex',\r\n                    alignItems: 'center',\r\n                    justifyContent: 'center',\r\n                    minWidth: '48px',\r\n                    minHeight: '48px',\r\n                    boxSizing: 'border-box',\r\n                    transition: 'all 0.2s',\r\n                    opacity: isOpen ? 0 : 1,\r\n                    pointerEvents: isOpen ? 'none' : 'auto'\r\n                }}\r\n                title={t('help_title')}\r\n            >\r\n                <HelpCircle size={20} />\r\n            </button>\r\n\r\n            {!isOpen && (\r\n                <CompactControls onOpenPanel={() => setIsOpen(true)} />\r\n            )}\r\n\r\n            <div className={`unified-side-panel ${!isOpen ? 'collapsed' : ''}`}>\r\n                <div style={{ // Header bar with close button if needed\r\n                    display: 'flex', justifyContent: 'flex-end', padding: '10px',\r\n                    borderBottom: '1px solid rgba(255,255,255,0.05)'\r\n                }}>\r\n                    <button\r\n                        onClick={() => setIsOpen(false)}\r\n                        style={{\r\n                            background: 'transparent', border: 'none', color: 'rgba(255,255,255,0.5)',\r\n                            cursor: 'pointer', fontSize: '20px', lineHeight: 1\r\n                        }}\r\n                    ></button>\r\n                </div>\r\n\r\n                <TabNavigation activeTab={activeTab} onChange={setActiveTab} />\r\n                <TabContent activeTab={activeTab} />\r\n            </div>\r\n\r\n            <HelpModal isOpen={showHelp} onClose={() => setShowHelp(false)} />\r\n        </>\r\n    );\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\yngsw\\dev\\orbit-simulator\\src\\components\\ui\\common\\ConfirmModal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\yngsw\\dev\\orbit-simulator\\src\\components\\ui\\common\\ContextHelp.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\yngsw\\dev\\orbit-simulator\\src\\components\\ui\\common\\SafeInput.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'step' is assigned a value but never used.","line":21,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":21,"endColumn":9},{"ruleId":"react-hooks/set-state-in-effect","severity":2,"message":"Error: Calling setState synchronously within an effect can trigger cascading renders\n\nEffects are intended to synchronize state between React and external systems such as manually updating the DOM, state management libraries, or other platform APIs. In general, the body of an effect should do one or both of the following:\n* Update external systems with the latest state from React.\n* Subscribe for updates from some external system, calling setState in a callback function when external state changes.\n\nCalling setState synchronously within an effect body causes cascading renders that can hurt performance, and is not recommended. (https://react.dev/learn/you-might-not-need-an-effect).\n\nC:\\Users\\yngsw\\dev\\orbit-simulator\\src\\components\\ui\\common\\SafeInput.tsx:33:9\n  31 |     // Sync with external value changes\n  32 |     useEffect(() => {\n> 33 |         setInputValue(value.toString());\n     |         ^^^^^^^^^^^^^ Avoid calling setState() directly within an effect\n  34 |         setError(null);\n  35 |     }, [value]);\n  36 |","line":33,"column":9,"nodeType":null,"endLine":33,"endColumn":22}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect } from 'react';\r\n\r\ninterface SafeInputProps {\r\n    value: number;\r\n    onChange: (value: number) => void;\r\n    onCommit?: (start: number, end: number) => void;\r\n    min?: number;\r\n    max?: number;\r\n    step?: number;\r\n    className?: string;\r\n    style?: React.CSSProperties;\r\n    placeholder?: string;\r\n}\r\n\r\nexport const SafeInput: React.FC<SafeInputProps> = ({\r\n    value,\r\n    onChange,\r\n    onCommit,\r\n    min,\r\n    max,\r\n    step = 1,\r\n    className,\r\n    style,\r\n    placeholder\r\n}) => {\r\n    const [inputValue, setInputValue] = useState(value.toString());\r\n    const [error, setError] = useState<string | null>(null);\r\n\r\n    const [startValue, setStartValue] = useState<number | null>(null);\r\n\r\n    // Sync with external value changes\r\n    useEffect(() => {\r\n        setInputValue(value.toString());\r\n        setError(null);\r\n    }, [value]);\r\n\r\n    const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {\r\n        const newValue = e.target.value;\r\n        setInputValue(newValue);\r\n\r\n        const parsed = parseFloat(newValue);\r\n\r\n        if (newValue === '' || newValue === '-') {\r\n            // Allow temporary empty or negative sign state\r\n            return;\r\n        }\r\n\r\n        if (isNaN(parsed)) {\r\n            setError('Invalid number');\r\n            return;\r\n        }\r\n\r\n        if (min !== undefined && parsed < min) {\r\n            setError(`Min: ${min}`);\r\n            return;\r\n        }\r\n\r\n        if (max !== undefined && parsed > max) {\r\n            setError(`Max: ${max}`);\r\n            return;\r\n        }\r\n\r\n        setError(null);\r\n        onChange(parsed);\r\n    };\r\n\r\n    const handleFocus = () => {\r\n        setStartValue(value);\r\n    };\r\n\r\n    const handleBlur = () => {\r\n        // Reset to valid value on blur if invalid\r\n        if (error || inputValue === '' || inputValue === '-') {\r\n            setInputValue(value.toString());\r\n            setError(null);\r\n        } else if (onCommit && startValue !== null) {\r\n            onCommit(startValue, parseFloat(inputValue));\r\n        }\r\n        setStartValue(null);\r\n    };\r\n\r\n    return (\r\n        <div style={{ position: 'relative', width: '100%' }}>\r\n            <input\r\n                type=\"text\" // Use text to allow fuller control over input (e.g. preventing 'e')\r\n                value={inputValue}\r\n                onChange={handleChange}\r\n                onFocus={handleFocus}\r\n                onBlur={handleBlur}\r\n                className={className}\r\n                style={{\r\n                    ...style,\r\n                    borderColor: error ? '#ef4444' : style?.borderColor\r\n                }}\r\n                placeholder={placeholder}\r\n            />\r\n            {error && (\r\n                <div style={{\r\n                    position: 'absolute',\r\n                    right: 0,\r\n                    top: '-18px',\r\n                    fontSize: '0.7rem',\r\n                    color: '#ef4444',\r\n                    background: 'rgba(0,0,0,0.8)',\r\n                    padding: '1px 4px',\r\n                    borderRadius: '2px',\r\n                    zIndex: 10\r\n                }}>\r\n                    {error}\r\n                </div>\r\n            )}\r\n        </div>\r\n    );\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\yngsw\\dev\\orbit-simulator\\src\\components\\ui\\common\\Toast.tsx","messages":[{"ruleId":"react-refresh/only-export-components","severity":2,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":19,"column":14,"nodeType":"Identifier","messageId":"namedExport","endLine":19,"endColumn":22}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { createContext, useContext, useState, useCallback } from 'react';\r\nimport { createPortal } from 'react-dom';\r\nimport { CheckCircle2, AlertCircle, X, Info } from 'lucide-react';\r\n\r\nexport type ToastType = 'success' | 'error' | 'info';\r\n\r\ninterface ToastMessage {\r\n    id: string;\r\n    message: string;\r\n    type: ToastType;\r\n}\r\n\r\ninterface ToastContextType {\r\n    showToast: (message: string, type?: ToastType) => void;\r\n}\r\n\r\nconst ToastContext = createContext<ToastContextType | undefined>(undefined);\r\n\r\nexport const useToast = () => {\r\n    const context = useContext(ToastContext);\r\n    if (!context) {\r\n        throw new Error('useToast must be used within a ToastProvider');\r\n    }\r\n    return context;\r\n};\r\n\r\ninterface ToastProviderProps {\r\n    children: React.ReactNode;\r\n}\r\n\r\nexport const ToastProvider: React.FC<ToastProviderProps> = ({ children }) => {\r\n    const [toasts, setToasts] = useState<ToastMessage[]>([]);\r\n\r\n    const showToast = useCallback((message: string, type: ToastType = 'info') => {\r\n        const id = Math.random().toString(36).substring(2, 9);\r\n        setToasts((prev) => [...prev, { id, message, type }]);\r\n\r\n        // Auto remove after 3 seconds\r\n        setTimeout(() => {\r\n            setToasts((prev) => prev.filter((t) => t.id !== id));\r\n        }, 3000);\r\n    }, []);\r\n\r\n    const removeToast = useCallback((id: string) => {\r\n        setToasts((prev) => prev.filter((t) => t.id !== id));\r\n    }, []);\r\n\r\n    return (\r\n        <ToastContext.Provider value={{ showToast }}>\r\n            {children}\r\n            {createPortal(\r\n                <div style={{\r\n                    position: 'fixed',\r\n                    bottom: '24px',\r\n                    right: '24px',\r\n                    display: 'flex',\r\n                    flexDirection: 'column',\r\n                    gap: '8px',\r\n                    zIndex: 9999,\r\n                    pointerEvents: 'none' // Allow clicking through the container area\r\n                }}>\r\n                    {toasts.map((toast) => (\r\n                        <div\r\n                            key={toast.id}\r\n                            style={{\r\n                                pointerEvents: 'auto', // Re-enable clicks for the toast itself\r\n                                background: 'rgba(20, 20, 30, 0.9)',\r\n                                backdropFilter: 'blur(12px)',\r\n                                border: `1px solid ${toast.type === 'success' ? 'rgba(16, 185, 129, 0.3)' :\r\n                                        toast.type === 'error' ? 'rgba(239, 68, 68, 0.3)' :\r\n                                            'rgba(59, 130, 246, 0.3)'\r\n                                    }`,\r\n                                borderRadius: '8px',\r\n                                padding: '12px 16px',\r\n                                minWidth: '300px',\r\n                                boxShadow: '0 4px 12px rgba(0, 0, 0, 0.3)',\r\n                                display: 'flex',\r\n                                alignItems: 'center',\r\n                                gap: '12px',\r\n                                color: 'white',\r\n                                fontSize: '0.9rem',\r\n                                animation: 'slideIn 0.3s ease-out forwards',\r\n                                transform: 'translateX(0)',\r\n                                opacity: 1,\r\n                            }}\r\n                        >\r\n                            <div style={{\r\n                                color: toast.type === 'success' ? '#10b981' :\r\n                                    toast.type === 'error' ? '#ef4444' :\r\n                                        '#3b82f6',\r\n                                display: 'flex', alignItems: 'center'\r\n                            }}>\r\n                                {toast.type === 'success' && <CheckCircle2 size={18} />}\r\n                                {toast.type === 'error' && <AlertCircle size={18} />}\r\n                                {toast.type === 'info' && <Info size={18} />}\r\n                            </div>\r\n                            <span style={{ flex: 1 }}>{toast.message}</span>\r\n                            <button\r\n                                onClick={() => removeToast(toast.id)}\r\n                                style={{\r\n                                    background: 'transparent',\r\n                                    border: 'none',\r\n                                    color: 'rgba(255, 255, 255, 0.4)',\r\n                                    cursor: 'pointer',\r\n                                    padding: '4px',\r\n                                    display: 'flex',\r\n                                    alignItems: 'center'\r\n                                }}\r\n                            >\r\n                                <X size={14} />\r\n                            </button>\r\n                        </div>\r\n                    ))}\r\n                </div>,\r\n                document.body\r\n            )}\r\n            <style>{`\r\n                @keyframes slideIn {\r\n                    from { transform: translateX(100%); opacity: 0; }\r\n                    to { transform: translateX(0); opacity: 1; }\r\n                }\r\n            `}</style>\r\n        </ToastContext.Provider>\r\n    );\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\yngsw\\dev\\orbit-simulator\\src\\components\\ui\\common\\VectorInput.tsx","messages":[{"ruleId":"react-hooks/set-state-in-effect","severity":2,"message":"Error: Calling setState synchronously within an effect can trigger cascading renders\n\nEffects are intended to synchronize state between React and external systems such as manually updating the DOM, state management libraries, or other platform APIs. In general, the body of an effect should do one or both of the following:\n* Update external systems with the latest state from React.\n* Subscribe for updates from some external system, calling setState in a callback function when external state changes.\n\nCalling setState synchronously within an effect body causes cascading renders that can hurt performance, and is not recommended. (https://react.dev/learn/you-might-not-need-an-effect).\n\nC:\\Users\\yngsw\\dev\\orbit-simulator\\src\\components\\ui\\common\\VectorInput.tsx:16:9\n  14 |\n  15 |     useEffect(() => {\n> 16 |         setLocal({ x: value.x, y: value.y, z: value.z });\n     |         ^^^^^^^^ Avoid calling setState() directly within an effect\n  17 |     }, [value.x, value.y, value.z]);\n  18 |\n  19 |     const handleChange = (axis: 'x' | 'y' | 'z', val: string) => {","line":16,"column":9,"nodeType":null,"endLine":16,"endColumn":17}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useEffect, useState } from 'react';\r\nimport { Vector3 } from 'three';\r\nimport './VectorInput.css';\r\n\r\ninterface VectorInputProps {\r\n    label: string;\r\n    value: Vector3;\r\n    onChange: (val: Vector3) => void;\r\n    onCommit?: (start: Vector3, end: Vector3) => void;\r\n}\r\n\r\nexport const VectorInput: React.FC<VectorInputProps> = ({ label, value, onChange, onCommit }) => {\r\n    const [local, setLocal] = useState({ x: value.x, y: value.y, z: value.z });\r\n\r\n    useEffect(() => {\r\n        setLocal({ x: value.x, y: value.y, z: value.z });\r\n    }, [value.x, value.y, value.z]);\r\n\r\n    const handleChange = (axis: 'x' | 'y' | 'z', val: string) => {\r\n        const num = parseFloat(val);\r\n        const newLocal = { ...local, [axis]: isNaN(num) ? local[axis] : num };\r\n        setLocal(newLocal);\r\n    };\r\n\r\n    const commit = () => {\r\n        const newVec = new Vector3(local.x, local.y, local.z);\r\n        if (!newVec.equals(value)) {\r\n            if (onCommit) onCommit(value.clone(), newVec);\r\n            onChange(newVec);\r\n        }\r\n    };\r\n\r\n    return (\r\n        <div className=\"lab-field\">\r\n            <label className=\"lab-label\" style={{ textTransform: 'uppercase', letterSpacing: '0.05em' }}>{label}</label>\r\n            <div className=\"lab-vector-grid\">\r\n                {(['x', 'y', 'z'] as const).map(axis => (\r\n                    <div key={axis} className=\"lab-vector-field\">\r\n                        <span className=\"lab-vector-label\">{axis}</span>\r\n                        <input\r\n                            type=\"number\"\r\n                            value={local[axis]}\r\n                            onChange={(e) => handleChange(axis, e.target.value)}\r\n                            onBlur={commit}\r\n                            onKeyDown={(e) => e.key === 'Enter' && commit()}\r\n                            className=\"lab-vector-input\"\r\n                        />\r\n                    </div>\r\n                ))}\r\n            </div>\r\n        </div>\r\n    );\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\yngsw\\dev\\orbit-simulator\\src\\components\\ui\\tabs\\BodiesTab.tsx","messages":[{"ruleId":"@typescript-eslint/ban-ts-comment","severity":2,"message":"Use \"@ts-expect-error\" instead of \"@ts-ignore\", as \"@ts-ignore\" will do nothing if the following line is error-free.","line":14,"column":5,"nodeType":"Line","messageId":"tsIgnoreInsteadOfExpectError","endLine":14,"endColumn":18,"suggestions":[{"messageId":"replaceTsIgnoreWithTsExpectError","fix":{"range":[637,650],"text":"// @ts-expect-error"},"desc":"Replace \"@ts-ignore\" with \"@ts-expect-error\"."}]},{"ruleId":"@typescript-eslint/ban-ts-comment","severity":2,"message":"Use \"@ts-expect-error\" instead of \"@ts-ignore\", as \"@ts-ignore\" will do nothing if the following line is error-free.","line":16,"column":5,"nodeType":"Line","messageId":"tsIgnoreInsteadOfExpectError","endLine":16,"endColumn":18,"suggestions":[{"messageId":"replaceTsIgnoreWithTsExpectError","fix":{"range":[693,706],"text":"// @ts-expect-error"},"desc":"Replace \"@ts-ignore\" with \"@ts-expect-error\"."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":205,"column":59,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":205,"endColumn":62,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9787,9790],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9787,9790],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":250,"column":146,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":250,"endColumn":149,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12470,12473],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12470,12473],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useMemo, useState } from 'react';\r\nimport { usePhysicsStore } from '../../../store/physicsStore';\r\nimport { Search, Trash2, Sun, Globe, Zap, Circle, Copy } from 'lucide-react';\r\nimport type { CelestialBody } from '../../../types/physics';\r\nimport { useTranslation } from '../../../utils/i18n';\r\nimport { ConfirmModal } from '../common/ConfirmModal';\r\nimport '../common/ConfirmModal.css';\r\nimport { useToast } from '../common/Toast';\r\nimport { ContextHelp } from '../common/ContextHelp';\r\n\r\n// Helper to determine body type string\r\nconst getBodyType = (body: CelestialBody) => {\r\n    if (body.type) return body.type;\r\n    // @ts-ignore\r\n    if (body.isStar) return 'star';\r\n    // @ts-ignore\r\n    if (body.isCompactObject) return 'black_hole';\r\n    return 'planet';\r\n};\r\n\r\nexport const BodiesTab: React.FC = () => {\r\n    const { t } = useTranslation();\r\n    const { showToast } = useToast();\r\n    const bodies = usePhysicsStore((state) => state.bodies);\r\n    const selectedBodyId = usePhysicsStore((state) => state.selectedBodyId);\r\n    const selectBody = usePhysicsStore((state) => state.selectBody);\r\n    const removeBody = usePhysicsStore((state) => state.removeBody);\r\n    const duplicateBody = usePhysicsStore((state) => state.duplicateBody);\r\n\r\n    const [searchTerm, setSearchTerm] = useState('');\r\n    const [filterType, setFilterType] = useState<'all' | 'star' | 'planet' | 'black_hole'>('all');\r\n\r\n    // Multi-selection state\r\n    const [selectedIds, setSelectedIds] = useState<Set<string>>(new Set());\r\n    const [isMultiSelectMode, setIsMultiSelectMode] = useState(false);\r\n\r\n    // Modal State\r\n    const [confirmDeleteId, setConfirmDeleteId] = useState<string | null>(null);\r\n    const [confirmBulkDelete, setConfirmBulkDelete] = useState(false);\r\n    const bodyToDelete = bodies.find(b => b.id === confirmDeleteId);\r\n\r\n    const filteredBodies = useMemo(() => {\r\n        return bodies.filter(b => {\r\n            const matchesSearch = b.name.toLowerCase().includes(searchTerm.toLowerCase());\r\n            const type = getBodyType(b);\r\n            const matchesType = filterType === 'all' ||\r\n                (filterType === 'black_hole' ? type === 'black_hole' : type === filterType) ||\r\n                (filterType === 'planet' && type === 'asteroid'); // Group asteroids with planets for now? Or separate?\r\n            // Actually let's just match exact string for simplicity\r\n\r\n            return matchesSearch && matchesType;\r\n        });\r\n    }, [bodies, searchTerm, filterType]);\r\n\r\n    // Count bodies by type for filter badges\r\n    const bodyCounts = useMemo(() => {\r\n        return {\r\n            all: bodies.length,\r\n            star: bodies.filter(b => getBodyType(b) === 'star').length,\r\n            planet: bodies.filter(b => {\r\n                const type = getBodyType(b);\r\n                return type === 'planet' || type === 'asteroid';\r\n            }).length,\r\n            black_hole: bodies.filter(b => getBodyType(b) === 'black_hole').length\r\n        };\r\n    }, [bodies]);\r\n\r\n    const getIcon = (body: CelestialBody) => {\r\n        const type = getBodyType(body);\r\n        if (type === 'star') return <Sun size={16} color=\"#fbbf24\" />;\r\n        if (type === 'black_hole') return <Zap size={16} color=\"#c084fc\" />;\r\n        if (type === 'planet') return <Globe size={16} color=\"#60a5fa\" />;\r\n        return <Circle size={16} color=\"#9ca3af\" />;\r\n    };\r\n\r\n    // Handle body click with multi-select support\r\n    const handleBodyClick = (bodyId: string, e: React.MouseEvent) => {\r\n        if (e.shiftKey || e.ctrlKey || e.metaKey) {\r\n            // Multi-select mode\r\n            setIsMultiSelectMode(true);\r\n            setSelectedIds(prev => {\r\n                const next = new Set(prev);\r\n                if (next.has(bodyId)) {\r\n                    next.delete(bodyId);\r\n                } else {\r\n                    next.add(bodyId);\r\n                }\r\n                return next;\r\n            });\r\n        } else {\r\n            // Single select mode\r\n            if (isMultiSelectMode && selectedIds.size > 0) {\r\n                // Clear multi-selection\r\n                setSelectedIds(new Set());\r\n                setIsMultiSelectMode(false);\r\n            }\r\n            selectBody(bodyId);\r\n        }\r\n    };\r\n\r\n    // Bulk delete handler\r\n    const handleBulkDelete = () => {\r\n        selectedIds.forEach(id => removeBody(id));\r\n        showToast(`${selectedIds.size} bodies deleted`, 'success');\r\n        setSelectedIds(new Set());\r\n        setIsMultiSelectMode(false);\r\n        setConfirmBulkDelete(false);\r\n    };\r\n\r\n    return (\r\n        <div style={{ display: 'flex', flexDirection: 'column', height: '100%' }}>\r\n            {/* Multi-select toolbar */}\r\n            {isMultiSelectMode && selectedIds.size > 0 && (\r\n                <div style={{\r\n                    padding: '12px 20px',\r\n                    background: 'rgba(96, 165, 250, 0.15)',\r\n                    borderBottom: '1px solid rgba(96, 165, 250, 0.3)',\r\n                    display: 'flex',\r\n                    alignItems: 'center',\r\n                    justifyContent: 'space-between'\r\n                }}>\r\n                    <div style={{ fontSize: '0.9rem', color: '#60a5fa' }}>\r\n                        {selectedIds.size} {selectedIds.size === 1 ? 'body' : 'bodies'} selected\r\n                    </div>\r\n                    <div style={{ display: 'flex', gap: '8px' }}>\r\n                        <button\r\n                            onClick={() => {\r\n                                setSelectedIds(new Set());\r\n                                setIsMultiSelectMode(false);\r\n                            }}\r\n                            style={{\r\n                                background: 'rgba(255, 255, 255, 0.1)',\r\n                                border: '1px solid rgba(255, 255, 255, 0.2)',\r\n                                color: 'white',\r\n                                padding: '6px 12px',\r\n                                borderRadius: '4px',\r\n                                cursor: 'pointer',\r\n                                fontSize: '0.85rem'\r\n                            }}\r\n                        >\r\n                            Cancel\r\n                        </button>\r\n                        <button\r\n                            onClick={() => setConfirmBulkDelete(true)}\r\n                            style={{\r\n                                background: 'rgba(239, 68, 68, 0.2)',\r\n                                border: '1px solid rgba(239, 68, 68, 0.4)',\r\n                                color: '#ef4444',\r\n                                padding: '6px 12px',\r\n                                borderRadius: '4px',\r\n                                cursor: 'pointer',\r\n                                fontSize: '0.85rem',\r\n                                display: 'flex',\r\n                                alignItems: 'center',\r\n                                gap: '4px'\r\n                            }}\r\n                        >\r\n                            <Trash2 size={14} />\r\n                            Delete {selectedIds.size}\r\n                        </button>\r\n                    </div>\r\n                </div>\r\n            )}\r\n\r\n            {/* Search & Filter Header */}\r\n            <div style={{ padding: '0 20px 10px', background: 'rgba(0,0,0,0.2)', borderBottom: '1px solid rgba(255,255,255,0.05)' }}>\r\n                <div style={{ display: 'flex', justifyContent: 'flex-end', paddingTop: '8px', paddingBottom: '4px' }}>\r\n                    <ContextHelp topic=\"bodies\" />\r\n                </div>\r\n                <div className=\"lab-search\" style={{ marginTop: '6px', display: 'flex', alignItems: 'center', background: 'rgba(255,255,255,0.05)', borderRadius: '6px', padding: '4px 8px' }}>\r\n                    <Search size={14} color=\"#aaa\" />\r\n                    <input\r\n                        type=\"text\"\r\n                        placeholder={t('search_placeholder')}\r\n                        value={searchTerm}\r\n                        onChange={(e) => setSearchTerm(e.target.value)}\r\n                        style={{ border: 'none', background: 'transparent', color: 'white', marginLeft: '8px', flex: 1, outline: 'none', fontSize: '13px' }}\r\n                    />\r\n                </div>\r\n\r\n                <div style={{ display: 'flex', gap: '4px', marginTop: '8px', overflowX: 'auto', paddingBottom: '4px' }} className=\"custom-scrollbar\">\r\n                    {(['all', 'star', 'planet', 'black_hole'] as const).map(f => {\r\n                        const count = bodyCounts[f];\r\n                        return (\r\n                            <button\r\n                                key={f}\r\n                                onClick={() => setFilterType(f)}\r\n                                style={{\r\n                                    border: 'none',\r\n                                    background: filterType === f ? 'rgba(96, 165, 250, 0.2)' : 'transparent',\r\n                                    color: filterType === f ? '#60a5fa' : '#888',\r\n                                    fontSize: '11px',\r\n                                    padding: '8px 12px',\r\n                                    borderRadius: '12px',\r\n                                    cursor: 'pointer',\r\n                                    whiteSpace: 'nowrap',\r\n                                    textTransform: 'capitalize',\r\n                                    transition: 'all 0.2s',\r\n                                    display: 'flex',\r\n                                    alignItems: 'center',\r\n                                    gap: '4px',\r\n                                    minHeight: '36px'\r\n                                }}\r\n                            >\r\n                                <span>{t(`filter_${f}` as any)}</span>\r\n                                <span style={{\r\n                                    fontSize: '10px',\r\n                                    opacity: 0.7,\r\n                                    fontWeight: 600,\r\n                                    background: filterType === f ? 'rgba(96, 165, 250, 0.2)' : 'rgba(255, 255, 255, 0.1)',\r\n                                    padding: '1px 5px',\r\n                                    borderRadius: '8px',\r\n                                    minWidth: '18px',\r\n                                    textAlign: 'center'\r\n                                }}>\r\n                                    {count}\r\n                                </span>\r\n                            </button>\r\n                        );\r\n                    })}\r\n                </div>\r\n            </div>\r\n\r\n            {/* List */}\r\n            <div className=\"custom-scrollbar\" style={{ flex: 1, overflowY: 'auto', padding: '10px 20px' }}>\r\n                {filteredBodies.map(body => {\r\n                    const isSelected = selectedBodyId === body.id;\r\n                    const isMultiSelected = selectedIds.has(body.id);\r\n                    const isHighlighted = isSelected || isMultiSelected;\r\n\r\n                    return (\r\n                        <div\r\n                            key={body.id}\r\n                            onClick={(e) => handleBodyClick(body.id, e)}\r\n                            className={`lab-list-item ${isHighlighted ? 'selected' : ''}`}\r\n                            style={{\r\n                                display: 'flex', alignItems: 'center', gap: '10px', padding: '8px',\r\n                                marginBottom: '4px', borderRadius: '6px', cursor: 'pointer',\r\n                                background: isHighlighted ? 'rgba(96, 165, 250, 0.1)' : 'transparent',\r\n                                border: `1px solid ${isHighlighted ? 'rgba(96, 165, 250, 0.3)' : 'transparent'}`,\r\n                                transition: 'all 0.2s',\r\n                                position: 'relative'\r\n                            }}\r\n                        >\r\n                        <div style={{ flexShrink: 0 }}>{getIcon(body)}</div>\r\n                        <div style={{ flex: 1, minWidth: 0 }}>\r\n                            <div style={{ fontSize: '0.9rem', fontWeight: selectedBodyId === body.id ? 600 : 400, color: selectedBodyId === body.id ? 'white' : '#ddd' }} className=\"truncate\">\r\n                                {body.name}\r\n                            </div>\r\n                            <div style={{ fontSize: '0.75rem', color: '#666', textTransform: 'capitalize' }}>{t(`filter_${getBodyType(body)}` as any)}</div>\r\n                        </div>\r\n\r\n                        <div style={{ display: 'flex', gap: '4px', opacity: isHighlighted ? 1 : 0.5 }}>\r\n                            {isMultiSelected && (\r\n                                <div style={{\r\n                                    position: 'absolute',\r\n                                    top: '8px',\r\n                                    left: '8px',\r\n                                    width: '6px',\r\n                                    height: '6px',\r\n                                    borderRadius: '50%',\r\n                                    background: '#60a5fa'\r\n                                }} />\r\n                            )}\r\n                            <button\r\n                                onClick={(e) => {\r\n                                    e.stopPropagation();\r\n                                    duplicateBody(body.id);\r\n                                    showToast(`${body.name} duplicated`, 'success');\r\n                                }}\r\n                                style={{ background: 'transparent', border: 'none', color: '#aaa', cursor: 'pointer', padding: '4px' }}\r\n                                title={t('duplicate')}\r\n                            >\r\n                                <Copy size={14} />\r\n                            </button>\r\n                            <button\r\n                                onClick={(e) => {\r\n                                    e.stopPropagation();\r\n                                    setConfirmDeleteId(body.id);\r\n                                }}\r\n                                style={{ background: 'transparent', border: 'none', color: '#aaa', cursor: 'pointer', padding: '4px' }}\r\n                                title={t('remove')}\r\n                            >\r\n                                <Trash2 size={14} />\r\n                            </button>\r\n                        </div>\r\n                    </div>\r\n                    );\r\n                })}\r\n\r\n                {filteredBodies.length === 0 && (\r\n                    <div style={{ textAlign: 'center', color: '#6b7280', padding: '2rem 0', fontSize: '0.875rem' }}>\r\n                        {t('no_bodies_found')}\r\n                    </div>\r\n                )}\r\n            </div>\r\n\r\n            {/* Single delete modal */}\r\n            <ConfirmModal\r\n                isOpen={!!confirmDeleteId}\r\n                title={t('delete_title')}\r\n                message={t('delete_message').replace('{name}', bodyToDelete?.name || '')}\r\n                onConfirm={() => {\r\n                    if (confirmDeleteId) {\r\n                        removeBody(confirmDeleteId);\r\n                        showToast(`${bodyToDelete?.name} deleted`, 'success');\r\n                    }\r\n                    setConfirmDeleteId(null);\r\n                }}\r\n                onCancel={() => setConfirmDeleteId(null)}\r\n                danger={true}\r\n                confirmText={t('delete_confirm')}\r\n                cancelText={t('delete_cancel')}\r\n            />\r\n\r\n            {/* Bulk delete modal */}\r\n            <ConfirmModal\r\n                isOpen={confirmBulkDelete}\r\n                title=\"Delete Multiple Bodies\"\r\n                message={`Are you sure you want to delete ${selectedIds.size} ${selectedIds.size === 1 ? 'body' : 'bodies'}? This action cannot be undone.`}\r\n                onConfirm={handleBulkDelete}\r\n                onCancel={() => setConfirmBulkDelete(false)}\r\n                danger={true}\r\n                confirmText=\"Delete All\"\r\n                cancelText=\"Cancel\"\r\n            />\r\n        </div>\r\n    );\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\yngsw\\dev\\orbit-simulator\\src\\components\\ui\\tabs\\InspectorTab.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\yngsw\\dev\\orbit-simulator\\src\\constants\\physics.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\yngsw\\dev\\orbit-simulator\\src\\gpu\\GPUPhysicsEngine.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\yngsw\\dev\\orbit-simulator\\src\\hooks\\usePhysicsLoop.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\yngsw\\dev\\orbit-simulator\\src\\main.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\yngsw\\dev\\orbit-simulator\\src\\store\\effectsStore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\yngsw\\dev\\orbit-simulator\\src\\store\\physicsStore.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":522,"column":76,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":522,"endColumn":79,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18667,18670],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18667,18670],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { create } from 'zustand';\r\nimport type { CelestialBody, SimulationState, CameraMode, PhysicsState, TidalDisruptionEvent, LegacyCollisionEvent, CollisionEvent } from '../types/physics';\r\nimport type { StarSystemMode } from '../types/starSystem';\r\nimport { updatePhysicsSoA, createPhysicsState, syncStateToBodies, BASE_DT, calculateTotalEnergy, applyCollisions } from '../utils/physics';\r\nimport { Vector3 } from 'three';\r\nimport { v4 as uuidv4 } from 'uuid';\r\nimport { createSolarSystem } from '../utils/solarSystem';\r\nimport { getPresetById } from '../utils/starSystems';\r\nimport { PhysicsWorkerManager } from '../workers/physicsWorkerManager';\r\nimport { GPUPhysicsEngine } from '../gpu/GPUPhysicsEngine';\r\nimport { useEffectsStore } from './effectsStore';\r\n\r\nimport { BUFFER_LIMITS } from '../constants/physics';\r\nimport { DISTANCE_SCALE_FACTOR } from '../utils/solarSystem';\r\n\r\n// Helper to trigger visual effects for collisions\r\nconst triggerCollisionEffects = (events: CollisionEvent[]) => {\r\n    const effectsStore = useEffectsStore.getState();\r\n    events.forEach(event => {\r\n        effectsStore.triggerCollisionEffects({\r\n            body1Id: event.largerBodyId,\r\n            body2Id: event.smallerBodyId,\r\n            collisionPoint: event.collisionPoint,\r\n            relativeVelocity: event.relativeVelocity,\r\n            combinedMass: event.combinedMass,\r\n            largerBodyId: event.largerBodyId,\r\n            smallerBodyId: event.smallerBodyId,\r\n            smallerBodyColor: event.smallerBodyColor,\r\n            smallerBodyRadius: event.smallerBodyRadius\r\n        });\r\n    });\r\n};\r\n\r\nlet _workerManager: PhysicsWorkerManager | null = null;\r\nexport const getWorkerManager = (): PhysicsWorkerManager => {\r\n    if (!_workerManager) {\r\n        _workerManager = new PhysicsWorkerManager(BUFFER_LIMITS.MAX_BODIES);\r\n        _workerManager.initWorkers();\r\n    }\r\n    return _workerManager;\r\n};\r\n\r\nlet _gpuEngine: GPUPhysicsEngine | null = null;\r\nexport const getGPUEngine = (): GPUPhysicsEngine => {\r\n    if (!_gpuEngine) {\r\n        _gpuEngine = new GPUPhysicsEngine();\r\n    }\r\n    return _gpuEngine;\r\n};\r\n\r\nexport const physicsStats = {\r\n    fps: 0,\r\n    physicsDuration: 0,\r\n    renderDuration: 0, // Assigned by Scene/Loop\r\n    bodyCount: 0,\r\n    mode: 'CPU',\r\n    energy: {\r\n        kinetic: 0,\r\n        potential: 0,\r\n        total: 0,\r\n        initial: 0,\r\n        drift: 0\r\n    },\r\n    lastEnergyCheck: 0,\r\n    cameraPosition: [0, 0, 0]\r\n};\r\n\r\nconst MAX_STABLE_DT = 0.02; // Threshold to split steps\r\n\r\nexport type HistoryAction =\r\n    | { type: 'ADD'; body: CelestialBody }\r\n    | { type: 'REMOVE'; body: CelestialBody }\r\n    | { type: 'UPDATE'; id: string; previous: Partial<CelestialBody>; current: Partial<CelestialBody> };\r\n\r\ninterface PhysicsStore {\r\n    bodies: CelestialBody[];\r\n    physicsState: PhysicsState | null; // Persisted SoA state\r\n    simulationState: SimulationState;\r\n    timeScale: number;\r\n    simulationTime: number; // Accumulated time for rotation sync\r\n    showPrediction: boolean;\r\n    showGrid: boolean;\r\n    showRealisticVisuals: boolean;\r\n    showHabitableZone: boolean;\r\n    showPerformance: boolean;\r\n    followingBodyId: string | null;\r\n    selectedBodyId: string | null;\r\n    cameraMode: CameraMode;\r\n    gpuDataInvalidated: boolean; // Flag to trigger data upload to GPU\r\n    zenMode: boolean;\r\n    labMode: boolean;\r\n    resetToken: number; // Increment to signal forced visual resets\r\n\r\n    // History\r\n    history: HistoryAction[];\r\n    historyIndex: number;\r\n    pushHistoryAction: (action: HistoryAction) => void;\r\n    undo: () => void;\r\n    redo: () => void;\r\n\r\n    // Distance Scale\r\n    useRealisticDistances: boolean;\r\n    toggleRealisticDistances: () => void;\r\n    toggleZenMode: () => void;\r\n    toggleLabMode: () => void;\r\n\r\n    // Gravity Visualization\r\n    showGravityField: boolean;\r\n    toggleGravityField: () => void;\r\n\r\n    // Multithreading\r\n    useMultithreading: boolean;\r\n    useGPU: boolean;\r\n    isCalculating: boolean;\r\n    isWorkerSupported: boolean;\r\n    isGPUSupported: boolean | null; // null = checking\r\n    toggleMultithreading: () => void;\r\n    toggleGPU: () => void;\r\n    checkGPUSupport: () => Promise<void>;\r\n\r\n    // Star System\r\n    currentSystemId: string | null;\r\n    currentSystemMode: StarSystemMode | null;\r\n    loadStarSystem: (systemId: string, mode?: StarSystemMode) => void;\r\n\r\n    addBody: (body: Omit<CelestialBody, 'id'>) => void;\r\n    duplicateBody: (id: string) => void;\r\n    removeBody: (id: string) => void;\r\n    // Destruction Events\r\n    tidallyDisruptedEvents: TidalDisruptionEvent[];\r\n    collisionEvents: LegacyCollisionEvent[];\r\n    addTidalDisruptionEvent: (event: TidalDisruptionEvent) => void;\r\n    removeTidalDisruptionEvent: (bodyId: string) => void;\r\n    addCollisionEvent: (event: LegacyCollisionEvent) => void;\r\n    removeCollisionEvent: (eventId: string) => void;\r\n\r\n    updateBodies: () => void;\r\n    loadSolarSystem: () => void;\r\n    setSimulationState: (state: SimulationState) => void;\r\n    setTimeScale: (scale: number) => void;\r\n    togglePrediction: () => void;\r\n    toggleGrid: () => void;\r\n    toggleRealisticVisuals: () => void;\r\n    toggleHabitableZone: () => void;\r\n    togglePerformance: () => void;\r\n    setFollowingBody: (id: string | null) => void;\r\n    selectBody: (id: string | null) => void;\r\n    updateBody: (id: string, updates: Partial<CelestialBody>) => void;\r\n    setCameraMode: (mode: CameraMode) => void;\r\n    reset: () => void;\r\n    cleanup: () => void;\r\n}\r\n\r\n// Use the shared solar system generator to ensure consistency between Initial Load and Reset\r\nconst INITIAL_BODIES: CelestialBody[] = createSolarSystem();\r\n\r\nexport const usePhysicsStore = create<PhysicsStore>((set, get) => ({\r\n    bodies: INITIAL_BODIES,\r\n    physicsState: null,\r\n    simulationState: 'running',\r\n    timeScale: 1.0,\r\n    simulationTime: 0,\r\n    showPrediction: false,\r\n    showGrid: true,\r\n    showRealisticVisuals: true,\r\n    showHabitableZone: false,\r\n    showPerformance: false,\r\n    followingBodyId: null,\r\n    selectedBodyId: null,\r\n    cameraMode: 'free',\r\n    gpuDataInvalidated: true,\r\n    showGravityField: false,\r\n\r\n    tidallyDisruptedEvents: [],\r\n    collisionEvents: [],\r\n\r\n    // Star System\r\n    currentSystemId: 'solar-system',\r\n    currentSystemMode: null,\r\n\r\n    useRealisticDistances: false,\r\n\r\n    zenMode: false,\r\n    labMode: false,\r\n    resetToken: 0,\r\n\r\n    useMultithreading: false,\r\n    useGPU: false,\r\n    isCalculating: false,\r\n    isWorkerSupported: typeof window !== 'undefined' && !!window.Worker && !!window.SharedArrayBuffer,\r\n    isGPUSupported: null,\r\n\r\n    checkGPUSupport: async () => {\r\n        const supported = await GPUPhysicsEngine.isSupported();\r\n        set({ isGPUSupported: supported });\r\n    },\r\n\r\n    cleanup: () => {\r\n        if (_workerManager) {\r\n            _workerManager.terminate();\r\n            _workerManager = null;\r\n        }\r\n        if (_gpuEngine) {\r\n            _gpuEngine.dispose();\r\n            _gpuEngine = null;\r\n        }\r\n    },\r\n\r\n    toggleMultithreading: () => {\r\n        const { useMultithreading } = get();\r\n        // If we are currently using MT, we are disabling it -> Clean up Worker\r\n        if (useMultithreading) {\r\n            if (_workerManager) {\r\n                _workerManager.terminate();\r\n                _workerManager = null;\r\n            }\r\n        }\r\n        // If we are enabling MT, we must ensure GPU is off and cleaned up\r\n        if (!useMultithreading) {\r\n            if (_gpuEngine) {\r\n                _gpuEngine.dispose();\r\n                _gpuEngine = null;\r\n            }\r\n        }\r\n\r\n        set((state) => ({\r\n            useMultithreading: !state.useMultithreading,\r\n            useGPU: false, // Ensure GPU off\r\n            physicsState: null,\r\n            gpuDataInvalidated: true,\r\n            isCalculating: false // Reset in case we were stuck\r\n        }));\r\n    },\r\n\r\n    toggleGPU: () => {\r\n        const { useGPU } = get();\r\n        // If currently using GPU, disabling it -> Clean up GPU\r\n        if (useGPU) {\r\n            if (_gpuEngine) {\r\n                _gpuEngine.dispose();\r\n                _gpuEngine = null;\r\n            }\r\n        }\r\n        // If enabling GPU, ensure Worker is off and cleaned up\r\n        if (!useGPU) {\r\n            if (_workerManager) {\r\n                _workerManager.terminate();\r\n                _workerManager = null;\r\n            }\r\n        }\r\n\r\n        set((state) => ({\r\n            useGPU: !state.useGPU,\r\n            useMultithreading: false, // Ensure MT off\r\n            physicsState: null,\r\n            gpuDataInvalidated: true, // Force upload when switching\r\n            isCalculating: false // Reset in case we were stuck\r\n        }));\r\n    },\r\n\r\n    toggleRealisticDistances: () => {\r\n        const { useRealisticDistances, bodies } = get();\r\n        const newScale = !useRealisticDistances;\r\n\r\n        // Scale factor: REALISTIC (1AU=50) / COMPRESSED (1AU=20) = 2.5\r\n        // NOTE: Updated constants make this 4.0 (200/50).\r\n        const factor = newScale ? DISTANCE_SCALE_FACTOR : 1 / DISTANCE_SCALE_FACTOR;\r\n\r\n        // Velocity scaling: v = sqrt(GM/r), so when r -> r*factor, v -> v/sqrt(factor)\r\n        const velocityFactor = 1 / Math.sqrt(factor);\r\n\r\n\r\n\r\n        // Transform all body positions and velocities (except fixed bodies at origin)\r\n        const scaledBodies = bodies.map(body => {\r\n            // Skip fixed bodies (usually central star)\r\n            if (body.isFixed) return body;\r\n\r\n            return {\r\n                ...body,\r\n                position: new Vector3(\r\n                    body.position.x * factor,\r\n                    body.position.y * factor,\r\n                    body.position.z * factor\r\n                ),\r\n                velocity: new Vector3(\r\n                    body.velocity.x * velocityFactor,\r\n                    body.velocity.y * velocityFactor,\r\n                    body.velocity.z * velocityFactor\r\n                )\r\n            };\r\n        });\r\n\r\n        // Dispatch event for camera adjustment\r\n        if (typeof window !== 'undefined') {\r\n            window.dispatchEvent(new CustomEvent('distanceScaleChanged', {\r\n                detail: { realistic: newScale, factor }\r\n            }));\r\n        }\r\n\r\n        set({\r\n            useRealisticDistances: newScale,\r\n            // timeScale: newTimeScale, // Do NOT overwrite user setting. We handle scaling dynamically in updateBodies\r\n            bodies: scaledBodies,\r\n            physicsState: null,\r\n            gpuDataInvalidated: true\r\n        });\r\n    },\r\n\r\n\r\n    addTidalDisruptionEvent: (event) => set((state) => ({\r\n        tidallyDisruptedEvents: [...state.tidallyDisruptedEvents, event]\r\n    })),\r\n\r\n    removeTidalDisruptionEvent: (bodyId) => set((state) => ({\r\n        tidallyDisruptedEvents: state.tidallyDisruptedEvents.filter(e => e.bodyId !== bodyId)\r\n    })),\r\n\r\n    addCollisionEvent: (event) => set((state) => ({\r\n        collisionEvents: [...state.collisionEvents, event]\r\n    })),\r\n\r\n    removeCollisionEvent: (eventId) => set((state) => ({\r\n        collisionEvents: state.collisionEvents.filter(e => e.id !== eventId)\r\n    })),\r\n\r\n    toggleGravityField: () => set((state) => ({ showGravityField: !state.showGravityField })),\r\n\r\n    // History\r\n    history: [],\r\n    historyIndex: -1,\r\n\r\n    pushHistoryAction: (action) => set((state) => {\r\n        const newHistory = state.history.slice(0, state.historyIndex + 1);\r\n        return {\r\n            history: [...newHistory, action],\r\n            historyIndex: newHistory.length\r\n        };\r\n    }),\r\n\r\n    undo: () => {\r\n        const { history, historyIndex } = get();\r\n        if (historyIndex < 0) return;\r\n\r\n        const action = history[historyIndex];\r\n\r\n        switch (action.type) {\r\n            case 'ADD':\r\n                // Reverse of ADD is REMOVE\r\n                set(state => ({\r\n                    bodies: state.bodies.filter(b => b.id !== action.body.id),\r\n                    physicsState: null,\r\n                    gpuDataInvalidated: true,\r\n                    // If we removed the selected body, deselect it\r\n                    selectedBodyId: state.selectedBodyId === action.body.id ? null : state.selectedBodyId\r\n                }));\r\n                break;\r\n            case 'REMOVE':\r\n                // Reverse of REMOVE is ADD\r\n                set(state => ({\r\n                    bodies: [...state.bodies, action.body],\r\n                    physicsState: null,\r\n                    gpuDataInvalidated: true\r\n                }));\r\n                break;\r\n            case 'UPDATE':\r\n                // Reverse of UPDATE is restoring PREVIOUS values\r\n                set(state => ({\r\n                    bodies: state.bodies.map(b =>\r\n                        b.id === action.id ? { ...b, ...action.previous } : b\r\n                    ),\r\n                    physicsState: null,\r\n                    gpuDataInvalidated: true\r\n                }));\r\n                // If updated body was selected, it stays selected.\r\n                break;\r\n        }\r\n\r\n        set({ historyIndex: historyIndex - 1 });\r\n    },\r\n\r\n    redo: () => {\r\n        const { history, historyIndex } = get();\r\n        if (historyIndex >= history.length - 1) return;\r\n\r\n        const action = history[historyIndex + 1];\r\n\r\n        switch (action.type) {\r\n            case 'ADD':\r\n                // Re-apply ADD\r\n                set(state => ({\r\n                    bodies: [...state.bodies, action.body],\r\n                    physicsState: null,\r\n                    gpuDataInvalidated: true\r\n                }));\r\n                break;\r\n            case 'REMOVE':\r\n                // Re-apply REMOVE\r\n                set(state => ({\r\n                    bodies: state.bodies.filter(b => b.id !== action.body.id),\r\n                    physicsState: null,\r\n                    gpuDataInvalidated: true,\r\n                    selectedBodyId: state.selectedBodyId === action.body.id ? null : state.selectedBodyId\r\n                }));\r\n                break;\r\n            case 'UPDATE':\r\n                // Re-apply UPDATE (restore CURRENT values)\r\n                set(state => ({\r\n                    bodies: state.bodies.map(b =>\r\n                        b.id === action.id ? { ...b, ...action.current } : b\r\n                    ),\r\n                    physicsState: null,\r\n                    gpuDataInvalidated: true\r\n                }));\r\n                break;\r\n        }\r\n\r\n        set({ historyIndex: historyIndex + 1 });\r\n    },\r\n\r\n    addBody: (body) => {\r\n        const { bodies, pushHistoryAction } = get();\r\n        const newBody = { ...body, id: uuidv4() };\r\n\r\n        pushHistoryAction({ type: 'ADD', body: newBody });\r\n\r\n        const newBodies = [...bodies, newBody];\r\n        set({ bodies: newBodies, physicsState: null, gpuDataInvalidated: true });\r\n    },\r\n\r\n    duplicateBody: (id) => {\r\n        const { bodies, pushHistoryAction } = get();\r\n        const bodyToDuplicate = bodies.find(b => b.id === id);\r\n        if (!bodyToDuplicate) return;\r\n\r\n        const newBody = {\r\n            ...bodyToDuplicate,\r\n            id: uuidv4(),\r\n            name: `${bodyToDuplicate.name} (Copy)`,\r\n            position: bodyToDuplicate.position.clone().add(new Vector3(2, 0, 2)), // Offset slightly\r\n            velocity: bodyToDuplicate.velocity.clone()\r\n        };\r\n\r\n        pushHistoryAction({ type: 'ADD', body: newBody });\r\n\r\n        set((state) => ({\r\n            bodies: [...state.bodies, newBody],\r\n            selectedBodyId: newBody.id, // Select the new body\r\n            physicsState: null, // Invalidate state\r\n            gpuDataInvalidated: true\r\n        }));\r\n    },\r\n\r\n    removeBody: (id) => {\r\n        const { bodies, followingBodyId, selectedBodyId, pushHistoryAction } = get();\r\n        const bodyToRemove = bodies.find(b => b.id === id);\r\n\r\n        if (bodyToRemove) {\r\n            pushHistoryAction({ type: 'REMOVE', body: bodyToRemove });\r\n        }\r\n\r\n        const newBodies = bodies.filter(b => b.id !== id);\r\n        set({\r\n            bodies: newBodies,\r\n            physicsState: null, // Invalidate state\r\n            followingBodyId: followingBodyId === id ? null : followingBodyId,\r\n            selectedBodyId: selectedBodyId === id ? null : selectedBodyId,\r\n            gpuDataInvalidated: true\r\n        });\r\n    },\r\n\r\n\r\n\r\n    updateBodies: async () => {\r\n        const { bodies, simulationState, timeScale, simulationTime, physicsState, useMultithreading, useGPU, isCalculating, gpuDataInvalidated } = get();\r\n\r\n        physicsStats.bodyCount = bodies.length;\r\n        physicsStats.mode = useGPU ? 'GPU' : (useMultithreading ? 'Worker' : 'CPU');\r\n\r\n        if (simulationState === 'paused') return;\r\n        if ((useMultithreading || useGPU) && isCalculating) return;\r\n\r\n        const start = performance.now();\r\n\r\n\r\n\r\n        // Correction: We actually want this applied regardless of CPU/GPU IF we want visual parity.\r\n        // However, GPU/Worker might need dt passed explicitly.\r\n        // Wait, 'useRealisticDistances' is state.\r\n        const distModeMultiplier = get().useRealisticDistances ? 8.0 : 1.0;\r\n\r\n        const dt = BASE_DT * timeScale * distModeMultiplier;\r\n\r\n        // Energy Calculation (Throttled 1Hz)\r\n        const now = performance.now();\r\n        if (!physicsStats.lastEnergyCheck || now - physicsStats.lastEnergyCheck > 1000) {\r\n            physicsStats.lastEnergyCheck = now;\r\n\r\n            const handleEnergyUpdate = (e: { kinetic: number, potential: number, total: number } | number) => {\r\n                const current = typeof e === 'number' ? { kinetic: 0, potential: 0, total: e } : e;\r\n\r\n                // Initialize Initial Energy if reset or first run\r\n                if (simulationTime < 0.1 || physicsStats.energy.initial === 0) {\r\n                    physicsStats.energy.initial = current.total;\r\n                }\r\n\r\n                const drift = physicsStats.energy.initial !== 0\r\n                    ? (current.total - physicsStats.energy.initial) / Math.abs(physicsStats.energy.initial)\r\n                    : 0;\r\n\r\n                physicsStats.energy = {\r\n                    ...current,\r\n                    initial: physicsStats.energy.initial,\r\n                    drift\r\n                };\r\n            };\r\n\r\n            if (useMultithreading) {\r\n                // Determine if worker returns object or number\r\n                // Worker currently returns number, we will accept it for now or assume implementation plan allows simpler update\r\n                // For now, let's treat worker result as total\r\n                getWorkerManager().calculateEnergy(bodies.length).then((e: any) => {\r\n                    // Temporarily handle both until worker is updated\r\n                    handleEnergyUpdate(e);\r\n                });\r\n            } else {\r\n                const energy = calculateTotalEnergy(bodies);\r\n                handleEnergyUpdate(energy);\r\n            }\r\n        }\r\n\r\n        if (useGPU) {\r\n            set({ isCalculating: true });\r\n            try {\r\n                const navGPU = getGPUEngine();\r\n                if (!navGPU.isReady) await navGPU.init(BUFFER_LIMITS.MAX_BODIES);\r\n\r\n                const steps = Math.ceil(dt / MAX_STABLE_DT);\r\n                const stepDt = dt / steps;\r\n\r\n                // Optimization: Only upload bodies if invalidated or new\r\n                if (gpuDataInvalidated || !navGPU.isReady) {\r\n                    await navGPU.setBodies(bodies);\r\n                    set({ gpuDataInvalidated: false });\r\n                }\r\n\r\n                for (let i = 0; i < steps; i++) {\r\n                    await navGPU.step(stepDt, bodies.length);\r\n                }\r\n                const gpuData = await navGPU.getBodies(bodies.length);\r\n\r\n                if (gpuData) {\r\n                    let nextBodies = bodies.map((b, i) => {\r\n                        const idx = i * 12;\r\n                        return {\r\n                            ...b,\r\n                            position: new Vector3(gpuData[idx], gpuData[idx + 1], gpuData[idx + 2]),\r\n                            velocity: new Vector3(gpuData[idx + 4], gpuData[idx + 5], gpuData[idx + 6])\r\n                        };\r\n                    });\r\n\r\n                    // GPU Collision Sync/Resolution\r\n                    const collisions = await navGPU.getCollisions();\r\n\r\n                    if (collisions && collisions.length > 0) {\r\n                        const { bodies: resolvedBodies, hasRemovals, collisionEvents } = applyCollisions(nextBodies, collisions);\r\n                        nextBodies = resolvedBodies;\r\n\r\n                        // Dispatch events (Store legacy format) and Trigger Effects (New format)\r\n                        if (collisionEvents && collisionEvents.length > 0) {\r\n                            // 1. Dispatch legacy store events (for Scene.tsx independent rendering if needed? Actually we are moving to EffectsStore)\r\n                            // But Scene.tsx in Week 1 uses store.collisionEvents. So we need to map them back?\r\n                            // physics.ts/applyCollisions now returns detailed CollisionEvent[] (HEAD)\r\n                            // Scene.tsx uses store.addCollisionEvent({ id, position, color, startTime })\r\n\r\n                            collisionEvents.forEach(e => {\r\n                                get().addCollisionEvent({\r\n                                    id: uuidv4(),\r\n                                    position: e.collisionPoint,\r\n                                    color: e.smallerBodyColor,\r\n                                    startTime: performance.now()\r\n                                });\r\n                            });\r\n\r\n                            // 2. Trigger new visual effects (EffectsLayer)\r\n                            triggerCollisionEffects(collisionEvents);\r\n                        }\r\n\r\n                        if (hasRemovals) {\r\n                            set({ physicsState: null, gpuDataInvalidated: true });\r\n                        }\r\n                    }\r\n\r\n                    set({\r\n                        bodies: nextBodies,\r\n                        physicsState: null,\r\n                        simulationTime: simulationTime + dt,\r\n                        isCalculating: false\r\n                    });\r\n                }\r\n            } catch (e) {\r\n                // Ignore AbortError caused by buffer destruction during cleanup/dispose\r\n                if (e instanceof Error && (e.name === 'AbortError' || e.message.includes('destroyed'))) {\r\n                    return;\r\n                }\r\n                console.error(\"GPU Step Failed\", e);\r\n                set({ isCalculating: false, useGPU: false });\r\n            }\r\n\r\n        } else if (useMultithreading) {\r\n            set({ isCalculating: true });\r\n\r\n            const workerMgr = getWorkerManager();\r\n\r\n            if (!physicsState || physicsState.count !== bodies.length) {\r\n                workerMgr.setBodies(bodies);\r\n            }\r\n\r\n            // Capture collisions\r\n            const collisions: [number, number][] = [];\r\n            workerMgr.onCollision = (pairs: [number, number][]) => {\r\n                collisions.push(...pairs);\r\n            };\r\n\r\n            try {\r\n                await workerMgr.executeStep(bodies.length, dt);\r\n\r\n                const workerState = workerMgr.getPhysicsState(bodies.length);\r\n                workerState.ids = bodies.map(b => b.id);\r\n                let nextBodies = syncStateToBodies(workerState, bodies);\r\n\r\n                // Resolve Collisions (CPU Main Thread)\r\n                if (collisions.length > 0) {\r\n                    const { bodies: resolvedBodies, hasRemovals, collisionEvents } = applyCollisions(nextBodies, collisions);\r\n                    nextBodies = resolvedBodies;\r\n\r\n                    if (collisionEvents && collisionEvents.length > 0) {\r\n                        collisionEvents.forEach(e => {\r\n                            get().addCollisionEvent({\r\n                                id: uuidv4(),\r\n                                position: e.collisionPoint,\r\n                                color: e.smallerBodyColor,\r\n                                startTime: performance.now()\r\n                            });\r\n                        });\r\n\r\n                        triggerCollisionEffects(collisionEvents);\r\n                    }\r\n\r\n                    if (hasRemovals) {\r\n                        set({ physicsState: null });\r\n                    }\r\n                }\r\n\r\n                set({\r\n                    bodies: nextBodies,\r\n                    physicsState: workerState,\r\n                    simulationTime: simulationTime + dt,\r\n                    isCalculating: false\r\n                });\r\n            } catch (e) {\r\n                console.warn(\"Worker Step Failed / Terminated\", e);\r\n                set({ isCalculating: false, useMultithreading: false });\r\n            }\r\n\r\n\r\n        } else {\r\n            let currentState = physicsState;\r\n            if (!currentState || currentState.count !== bodies.length) {\r\n                currentState = createPhysicsState(bodies);\r\n            }\r\n\r\n            const steps = Math.ceil(dt / MAX_STABLE_DT);\r\n            const stepDt = dt / steps;\r\n\r\n            // Disable collisions in updatePhysicsSoA, handle them manually for effects\r\n            for (let i = 0; i < steps; i++) {\r\n                updatePhysicsSoA(currentState, stepDt, false, false);\r\n            }\r\n\r\n            let nextBodies = syncStateToBodies(currentState, bodies);\r\n\r\n            // CPU-mode collision detection and effects\r\n            // Use applyCollisions to get collision events for visual effects\r\n            const { positions, radii, masses } = currentState;\r\n            const collisionPairs: [number, number][] = [];\r\n\r\n            for (let i = 0; i < currentState.count; i++) {\r\n                if (masses[i] <= 0) continue;\r\n\r\n                for (let j = i + 1; j < currentState.count; j++) {\r\n                    if (masses[j] <= 0) continue;\r\n\r\n                    const i3 = i * 3;\r\n                    const j3 = j * 3;\r\n\r\n                    const dx = positions[i3] - positions[j3];\r\n                    const dy = positions[i3 + 1] - positions[j3 + 1];\r\n                    const dz = positions[i3 + 2] - positions[j3 + 2];\r\n\r\n                    const distSq = dx * dx + dy * dy + dz * dz;\r\n                    const radSum = radii[i] + radii[j];\r\n\r\n                    if (distSq < (radSum * 0.8) ** 2) {\r\n                        collisionPairs.push([i, j]);\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (collisionPairs.length > 0) {\r\n                const { bodies: resolvedBodies, collisionEvents } = applyCollisions(nextBodies, collisionPairs);\r\n                nextBodies = resolvedBodies;\r\n\r\n                // Trigger visual effects\r\n                if (collisionEvents && collisionEvents.length > 0) {\r\n                    // Add legacy collision events for Scene.tsx\r\n                    collisionEvents.forEach(e => {\r\n                        get().addCollisionEvent({\r\n                            id: uuidv4(),\r\n                            position: e.collisionPoint,\r\n                            color: e.smallerBodyColor,\r\n                            startTime: performance.now()\r\n                        });\r\n                    });\r\n\r\n                    // Trigger new effects system\r\n                    triggerCollisionEffects(collisionEvents);\r\n                }\r\n\r\n                // Invalidate state due to removals\r\n                set({ physicsState: null });\r\n            }\r\n\r\n            // Roche Limit Check: DISABLED\r\n            // The simulation's visual scaling (large radii for visibility, compressed distances)\r\n            // makes accurate Roche limit physics impractical. Collision effects provide sufficient drama.\r\n\r\n            set({\r\n                bodies: nextBodies,\r\n                physicsState: currentState,\r\n                simulationTime: simulationTime + dt\r\n            });\r\n        }\r\n\r\n        physicsStats.physicsDuration = performance.now() - start;\r\n    },\r\n\r\n    setSimulationState: (state) => set({ simulationState: state }),\r\n\r\n    loadSolarSystem: () => {\r\n        set({\r\n            bodies: createSolarSystem(),\r\n            physicsState: null,\r\n            timeScale: 1.0,\r\n            simulationState: 'running',\r\n            simulationTime: 0,\r\n            followingBodyId: null,\r\n            selectedBodyId: null,\r\n            cameraMode: 'free',\r\n            gpuDataInvalidated: true,\r\n            useRealisticDistances: false,\r\n            currentSystemId: 'solar-system',\r\n            currentSystemMode: null,\r\n            resetToken: 0,\r\n            history: [],\r\n            historyIndex: -1\r\n        });\r\n    },\r\n\r\n    loadStarSystem: (systemId: string, mode?: StarSystemMode) => {\r\n        const preset = getPresetById(systemId);\r\n        if (!preset) return;\r\n\r\n        const bodies = preset.createBodies(mode).map(body => ({\r\n            ...body,\r\n            id: uuidv4()\r\n        }));\r\n\r\n        // Get camera config: use mode-specific if available, otherwise default\r\n        const cameraConfig = (mode && preset.getCameraForMode)\r\n            ? preset.getCameraForMode(mode)\r\n            : preset.initialCamera;\r\n\r\n        // Dispatch event for camera reset\r\n        if (typeof window !== 'undefined') {\r\n            window.dispatchEvent(new CustomEvent('starSystemChanged', {\r\n                detail: {\r\n                    systemId,\r\n                    mode,\r\n                    camera: cameraConfig\r\n                }\r\n            }));\r\n        }\r\n\r\n        set({\r\n            bodies,\r\n            currentSystemId: systemId,\r\n            currentSystemMode: mode || null,\r\n            physicsState: null,\r\n            timeScale: 1.0,\r\n            simulationState: 'running',\r\n            simulationTime: 0,\r\n            followingBodyId: null,\r\n            selectedBodyId: null,\r\n            cameraMode: 'free',\r\n            gpuDataInvalidated: true,\r\n            useRealisticDistances: false,\r\n            // Zen Mode\r\n            zenMode: false,\r\n            resetToken: 0,\r\n            history: [],\r\n            historyIndex: -1\r\n        });\r\n    },\r\n\r\n    toggleZenMode: () => set((state) => ({ zenMode: !state.zenMode })),\r\n    toggleLabMode: () => set((state) => ({ labMode: !state.labMode })),\r\n\r\n    setTimeScale: (scale) => set({ timeScale: scale }),\r\n\r\n    togglePrediction: () => set((state) => ({ showPrediction: !state.showPrediction })),\r\n    toggleGrid: () => set((state) => ({ showGrid: !state.showGrid })),\r\n    toggleRealisticVisuals: () => set((state) => ({ showRealisticVisuals: !state.showRealisticVisuals })),\r\n    toggleHabitableZone: () => set((state) => ({ showHabitableZone: !state.showHabitableZone })),\r\n    togglePerformance: () => set((state) => ({ showPerformance: !state.showPerformance })),\r\n    setFollowingBody: (id) => set({ followingBodyId: id }),\r\n    selectBody: (id) => set({ selectedBodyId: id }),\r\n    setCameraMode: (mode) => set({ cameraMode: mode }),\r\n\r\n    updateBody: (id, updates) => {\r\n        const { bodies } = get();\r\n        const newBodies = bodies.map(b => b.id === id ? { ...b, ...updates } : b);\r\n        set({ bodies: newBodies, physicsState: null, gpuDataInvalidated: true });\r\n    },\r\n\r\n    reset: () => {\r\n        const { currentSystemId, currentSystemMode, bodies, resetToken } = get();\r\n\r\n        // Determine which bodies to load\r\n        let initialBodies = INITIAL_BODIES;\r\n        if (currentSystemId && currentSystemId !== 'solar-system') {\r\n            const preset = getPresetById(currentSystemId);\r\n            if (preset) {\r\n                initialBodies = preset.createBodies(currentSystemMode || undefined).map(body => ({\r\n                    ...body,\r\n                    id: uuidv4()\r\n                }));\r\n            }\r\n        } else {\r\n            initialBodies = createSolarSystem();\r\n        }\r\n\r\n        // PRESERVE IDs: Overwrite new IDs with existing ones for matching bodies\r\n        // This ensures the Scene/Camera component doesn't see them as \"new\" objects\r\n        const existingIdMap = new Map(bodies.map(b => [b.name, b.id]));\r\n\r\n        const bodiesWithPreservedIds = initialBodies.map(newBody => {\r\n            if (existingIdMap.has(newBody.name)) {\r\n                return { ...newBody, id: existingIdMap.get(newBody.name)! };\r\n            }\r\n            return newBody;\r\n        });\r\n\r\n        // If realistic mode is on, we must re-apply the scaling to the freshly loaded bodies\r\n        // becasue createSolarSystem/createBodies generates them at \"Normal\" (Compressed) scale.\r\n        const useRealisticDistances = get().useRealisticDistances;\r\n        let finalBodies = bodiesWithPreservedIds;\r\n\r\n        if (useRealisticDistances) {\r\n            const factor = DISTANCE_SCALE_FACTOR;\r\n            const velocityFactor = 1 / Math.sqrt(factor);\r\n\r\n            finalBodies = finalBodies.map(body => {\r\n                if (body.isFixed) return body;\r\n                return {\r\n                    ...body,\r\n                    position: new Vector3(\r\n                        body.position.x * factor,\r\n                        body.position.y * factor,\r\n                        body.position.z * factor\r\n                    ),\r\n                    velocity: new Vector3(\r\n                        body.velocity.x * velocityFactor,\r\n                        body.velocity.y * velocityFactor,\r\n                        body.velocity.z * velocityFactor\r\n                    )\r\n                };\r\n            });\r\n        }\r\n\r\n        set({\r\n            bodies: finalBodies,\r\n            physicsState: null,\r\n            simulationTime: 0,\r\n            gpuDataInvalidated: true,\r\n            resetToken: resetToken + 1,\r\n            // Reset visualization states\r\n\r\n            showGravityField: false,\r\n            // We don't touch followingBodyId/cameraMode here, relying on ID preservation.\r\n            history: [],\r\n            historyIndex: -1\r\n        });\r\n    }\r\n}));\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\yngsw\\dev\\orbit-simulator\\src\\types\\debris.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\yngsw\\dev\\orbit-simulator\\src\\types\\effects.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\yngsw\\dev\\orbit-simulator\\src\\types\\physics.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\yngsw\\dev\\orbit-simulator\\src\\types\\starSystem.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\yngsw\\dev\\orbit-simulator\\src\\utils\\barnesHut.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\yngsw\\dev\\orbit-simulator\\src\\utils\\benchmark.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":48,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":48,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1543,1546],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1543,1546],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Vector3 } from 'three';\r\nimport { updatePhysicsSoA, createPhysicsState, resetDebugCount } from './physics';\r\nimport type { CelestialBody } from '../types/physics';\r\n\r\n/**\r\n * Generates N random bodies for benchmarking\r\n */\r\nconst generateBodies = (count: number): CelestialBody[] => {\r\n    const bodies: CelestialBody[] = [];\r\n    for (let i = 0; i < count; i++) {\r\n        bodies.push({\r\n            id: `body-${i}`,\r\n            name: `Body ${i}`,\r\n            mass: Math.random() * 100 + 1,\r\n            radius: Math.random() * 2 + 0.5,\r\n            position: new Vector3(\r\n                (Math.random() - 0.5) * 100,\r\n                (Math.random() - 0.5) * 100,\r\n                (Math.random() - 0.5) * 100\r\n            ),\r\n            velocity: new Vector3(\r\n                (Math.random() - 0.5) * 2,\r\n                (Math.random() - 0.5) * 2,\r\n                (Math.random() - 0.5) * 2\r\n            ),\r\n            color: '#ffffff',\r\n            isFixed: false\r\n        });\r\n    }\r\n    return bodies;\r\n};\r\n\r\n/**\r\n * Runs a performance benchmark comparison\r\n */\r\n/**\r\n * Runs a performance benchmark comparison\r\n */\r\nimport { getWorkerManager } from '../store/physicsStore';\r\n\r\n/**\r\n * Runs a performance benchmark comparison\r\n */\r\nexport const runBenchmark = async (iterations: number = 600, bodyCounts: number[] = [100, 500, 1000]) => {\r\n    console.log(`Starting Benchmark Comparison (${iterations} frames)...`);\r\n    console.log('--------------------------------------------------');\r\n\r\n    const results: Record<string, any> = {};\r\n\r\n    for (const count of bodyCounts) {\r\n        console.log(`Testing with ${count} bodies...`);\r\n        const bodies = generateBodies(count);\r\n\r\n        // Warmup\r\n        const state = createPhysicsState(bodies);\r\n\r\n        // 1. Measure SoA Direct (O(N^2))\r\n        resetDebugCount();\r\n        const startDirect = performance.now();\r\n        for (let i = 0; i < iterations; i++) {\r\n            updatePhysicsSoA(state, 1.0, false, false);\r\n        }\r\n        const timeDirect = performance.now() - startDirect;\r\n        const countDirect = state.count;\r\n\r\n        // Anti-DCE: Accumulate position check\r\n        let checkDirect = 0;\r\n        for (let k = 0; k < state.count; k++) checkDirect += state.positions[k * 3];\r\n\r\n        // Reset state for BH (to be fair)\r\n        const stateBH = createPhysicsState(bodies);\r\n\r\n        // 2. Measure SoA Barnes-Hut (O(N log N))\r\n        const startBH = performance.now();\r\n        for (let i = 0; i < iterations; i++) {\r\n            updatePhysicsSoA(stateBH, 1.0, true, false);\r\n        }\r\n        const timeBH = performance.now() - startBH;\r\n        const countBH = stateBH.count;\r\n        let checkBH = 0;\r\n        for (let k = 0; k < stateBH.count; k++) checkBH += stateBH.positions[k * 3];\r\n\r\n        const avgDirect = timeDirect / iterations;\r\n        const avgBH = timeBH / iterations;\r\n        const ratio = avgDirect / avgBH;\r\n\r\n        console.log(`[${count} Bodies] -> Final: D=${countDirect}, BH=${countBH}`);\r\n        console.log(`  Direct (N^2):   ${avgDirect.toFixed(3)}ms/frame (~${(1000 / avgDirect).toFixed(1)} FPS)`);\r\n        console.log(`  Barnes-Hut:     ${avgBH.toFixed(3)}ms/frame (~${(1000 / avgBH).toFixed(1)} FPS)`);\r\n        console.log(`  Speedup (BH):   ${ratio.toFixed(2)}x`);\r\n\r\n        // 3. Measure Worker (Parallel N^2)\r\n        let avgWorker = 0;\r\n        let workerSpeedup = 0;\r\n\r\n        const workerMgr = getWorkerManager();\r\n        if (workerMgr.isSupported) {\r\n            console.log('  Testing Worker...');\r\n            workerMgr.setBodies(bodies);\r\n\r\n            // Warmup Worker with 1 frame\r\n            await workerMgr.executeStep(count, 1.0);\r\n\r\n            const startWorker = performance.now();\r\n            for (let i = 0; i < iterations; i++) {\r\n                await workerMgr.executeStep(count, 1.0);\r\n            }\r\n            const timeWorker = performance.now() - startWorker;\r\n            avgWorker = timeWorker / iterations;\r\n            workerSpeedup = avgDirect / avgWorker;\r\n\r\n            console.log(`  Worker (N^2):   ${avgWorker.toFixed(3)}ms/frame (~${(1000 / avgWorker).toFixed(1)} FPS)`);\r\n            console.log(`  Speedup (Work): ${workerSpeedup.toFixed(2)}x`);\r\n        } else {\r\n            console.log('  Worker:         Not Supported');\r\n        }\r\n\r\n        // 4. Measure GPU (WebGPU)\r\n        const { GPUPhysicsEngine } = await import('../gpu/GPUPhysicsEngine');\r\n        const isGPUSupported = await GPUPhysicsEngine.isSupported();\r\n        let avgGPU = 0;\r\n        let gpuSpeedup = 0;\r\n\r\n        if (isGPUSupported) {\r\n            console.log('  Testing GPU...');\r\n            const gpuEngine = new GPUPhysicsEngine();\r\n            try {\r\n                await gpuEngine.init(count);\r\n                await gpuEngine.setBodies(bodies);\r\n\r\n                // Warmup\r\n                await gpuEngine.step(1.0, count);\r\n                await gpuEngine.getBodies(count);\r\n\r\n                const startGPU = performance.now();\r\n                for (let i = 0; i < iterations; i++) {\r\n                    await gpuEngine.step(1.0, count);\r\n                    await gpuEngine.getBodies(count); // Include readback for fairness with Store usage\r\n                }\r\n                const timeGPU = performance.now() - startGPU;\r\n                avgGPU = timeGPU / iterations;\r\n                gpuSpeedup = avgDirect / avgGPU;\r\n\r\n                console.log(`  GPU:            ${avgGPU.toFixed(3)}ms/frame (~${(1000 / avgGPU).toFixed(1)} FPS)`);\r\n                console.log(`  Speedup (GPU):  ${gpuSpeedup.toFixed(2)}x`);\r\n\r\n            } catch (e) {\r\n                console.error('GPU Benchmark failed', e);\r\n            } finally {\r\n                gpuEngine.dispose();\r\n            }\r\n        } else {\r\n            console.log('  GPU:            Not Supported');\r\n        }\r\n\r\n        console.log(`  Checksums:      Direct=${checkDirect.toFixed(2)} | BH=${checkBH.toFixed(2)}`);\r\n        console.log('--------------------------------------------------');\r\n\r\n        results[count] = { direct: avgDirect, bh: avgBH, worker: avgWorker };\r\n    }\r\n\r\n    return results;\r\n};\r\n\r\n/**\r\n * Runs ONLY GPU benchmark (skipping CPU/Worker for speed/stability)\r\n */\r\nexport const runGPUBenchmark = async (iterations: number = 600, bodyCounts: number[] = [5000, 10000]) => {\r\n    console.log(`Starting GPU Benchmark (${iterations} frames)...`);\r\n    const { GPUPhysicsEngine } = await import('../gpu/GPUPhysicsEngine');\r\n    const isGPUSupported = await GPUPhysicsEngine.isSupported();\r\n\r\n    if (!isGPUSupported) {\r\n        console.error(\"WebGPU is not supported.\");\r\n        return;\r\n    }\r\n\r\n    for (const count of bodyCounts) {\r\n        console.log(`Testing with ${count} bodies...`);\r\n        const bodies = generateBodies(count);\r\n        const gpuEngine = new GPUPhysicsEngine();\r\n\r\n        try {\r\n            await gpuEngine.init(count);\r\n            await gpuEngine.setBodies(bodies);\r\n\r\n            // Warmup\r\n            await gpuEngine.step(1.0, count);\r\n            await gpuEngine.getBodies(count);\r\n\r\n            const startGPU = performance.now();\r\n            for (let i = 0; i < iterations; i++) {\r\n                await gpuEngine.step(1.0, count);\r\n                await gpuEngine.getBodies(count);\r\n            }\r\n            const timeGPU = performance.now() - startGPU;\r\n            const avgGPU = timeGPU / iterations;\r\n\r\n            console.log(`  GPU:            ${avgGPU.toFixed(3)}ms/frame (~${(1000 / avgGPU).toFixed(1)} FPS)`);\r\n\r\n        } catch (e) {\r\n            console.error('GPU Benchmark failed', e);\r\n        } finally {\r\n            gpuEngine.dispose();\r\n        }\r\n    }\r\n};\r\n\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\yngsw\\dev\\orbit-simulator\\src\\utils\\cameraTransitions.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\yngsw\\dev\\orbit-simulator\\src\\utils\\habitableZone.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\yngsw\\dev\\orbit-simulator\\src\\utils\\i18n.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\yngsw\\dev\\orbit-simulator\\src\\utils\\octree.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\yngsw\\dev\\orbit-simulator\\src\\utils\\physics.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\yngsw\\dev\\orbit-simulator\\src\\utils\\rocheLimit.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\yngsw\\dev\\orbit-simulator\\src\\utils\\solarSystem.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\yngsw\\dev\\orbit-simulator\\src\\utils\\spatialHash.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\yngsw\\dev\\orbit-simulator\\src\\utils\\starSystems.ts","messages":[],"suppressedMessages":[{"ruleId":"no-loss-of-precision","severity":2,"message":"This number literal will lose precision at runtime.","line":324,"column":22,"nodeType":"Literal","messageId":"noLossOfPrecision","endLine":324,"endColumn":41,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\yngsw\\dev\\orbit-simulator\\src\\workers\\physics.worker.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\yngsw\\dev\\orbit-simulator\\src\\workers\\physicsWorkerManager.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":25,"column":55,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":25,"endColumn":58,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[938,941],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[938,941],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":70,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":70,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2774,2777],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2774,2777],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":184,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":184,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6751,6754],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6751,6754],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":214,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":214,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7707,7710],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7707,7710],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"export class PhysicsWorkerManager {\r\n    private workers: Worker[] = [];\r\n    private sharedBuffer: SharedArrayBuffer;\r\n\r\n    // Views\r\n    public positions: Float64Array;\r\n    public velocities: Float64Array;\r\n    public accelerations: Float64Array;\r\n    public masses: Float64Array;\r\n    public radii: Float64Array;\r\n    public syncCounter: Int32Array;\r\n\r\n    private workerCount: number;\r\n    private maxBodies: number;\r\n    public readonly isSupported: boolean;\r\n\r\n    constructor(maxBodies: number, workerCount: number = navigator.hardwareConcurrency || 4) {\r\n        this.maxBodies = maxBodies;\r\n        this.workerCount = workerCount;\r\n        this.isSupported = typeof SharedArrayBuffer !== 'undefined';\r\n\r\n        if (!this.isSupported) {\r\n            console.warn('SharedArrayBuffer is not supported. Falling back to main thread.');\r\n            // Fallback initialization\r\n            this.sharedBuffer = new ArrayBuffer(0) as any; // Cast to satisfy type\r\n            this.positions = new Float64Array(0);\r\n            this.velocities = new Float64Array(0);\r\n            this.accelerations = new Float64Array(0);\r\n            this.masses = new Float64Array(0);\r\n            this.radii = new Float64Array(0);\r\n            this.syncCounter = new Int32Array(0);\r\n            return;\r\n        }\r\n\r\n        // Calculate size: (pos(3) + vel(3) + acc(3) + mass(1) + radius(1)) * 8 bytes * N + sync(4)\r\n        const elementCountPerBody = 3 + 3 + 3 + 1 + 1; // 11 doubles\r\n        const bufferSize = maxBodies * elementCountPerBody * 8 + 8; // +8 for Int32 counter (2 * 4 bytes)\r\n\r\n        this.sharedBuffer = new SharedArrayBuffer(bufferSize);\r\n\r\n        let offset = 0;\r\n\r\n        // positions\r\n        this.positions = new Float64Array(this.sharedBuffer, offset, maxBodies * 3);\r\n        offset += maxBodies * 3 * 8;\r\n\r\n        // velocities\r\n        this.velocities = new Float64Array(this.sharedBuffer, offset, maxBodies * 3);\r\n        offset += maxBodies * 3 * 8;\r\n\r\n        // accelerations\r\n        this.accelerations = new Float64Array(this.sharedBuffer, offset, maxBodies * 3);\r\n        offset += maxBodies * 3 * 8;\r\n\r\n        // masses\r\n        this.masses = new Float64Array(this.sharedBuffer, offset, maxBodies);\r\n        offset += maxBodies * 8;\r\n\r\n        // radii\r\n        this.radii = new Float64Array(this.sharedBuffer, offset, maxBodies);\r\n        offset += maxBodies * 8;\r\n\r\n        // syncCounter (Atomics) - [0]: arrival count, [1]: phase/generation\r\n        this.syncCounter = new Int32Array(this.sharedBuffer, offset, 2);\r\n    }\r\n\r\n    public onCollision: ((pairs: [number, number][]) => void) | null = null;\r\n    private initialized: boolean = false;\r\n    private initPromise: Promise<void> | null = null;\r\n    private pendingReject: ((reason?: any) => void) | null = null;\r\n\r\n    public initWorkers(): void {\r\n        if (!this.isSupported) return;\r\n        if (this.initialized || this.initPromise) return;\r\n\r\n        const initPromises: Promise<void>[] = [];\r\n\r\n        for (let i = 0; i < this.workerCount; i++) {\r\n            const worker = new Worker(new URL('./physics.worker.ts', import.meta.url), {\r\n                type: 'module'\r\n            });\r\n\r\n            // Wait for worker to confirm initialization\r\n            const initPromise = new Promise<void>((resolve) => {\r\n                const handler = (e: MessageEvent) => {\r\n                    if (e.data.type === 'initDone') {\r\n                        worker.removeEventListener('message', handler);\r\n                        resolve();\r\n                    }\r\n                };\r\n                worker.addEventListener('message', handler);\r\n            });\r\n\r\n            worker.postMessage({\r\n                type: 'init',\r\n                sharedBuffer: this.sharedBuffer,\r\n                workerId: i,\r\n                workerCount: this.workerCount,\r\n                maxBodies: this.maxBodies\r\n            });\r\n\r\n            this.workers.push(worker);\r\n            initPromises.push(initPromise);\r\n        }\r\n\r\n        // Store promise so we can await it before executeStep\r\n        this.initPromise = Promise.all(initPromises).then(() => {\r\n            this.initialized = true;\r\n        });\r\n    }\r\n\r\n    public async waitForInit(): Promise<void> {\r\n        if (this.initPromise) {\r\n            await this.initPromise;\r\n        }\r\n    }\r\n\r\n    public async executeStep(count: number, dt: number): Promise<void> {\r\n        if (!this.isSupported) return;\r\n\r\n        // Wait for workers to be initialized\r\n        await this.waitForInit();\r\n\r\n        Atomics.store(this.syncCounter, 0, 0);\r\n\r\n        const stepPromise = Promise.all(this.workers.map(worker =>\r\n            new Promise<void>((resolve) => {\r\n                const handler = (e: MessageEvent) => {\r\n                    if (e.data.type === 'done') {\r\n                        worker.removeEventListener('message', handler);\r\n                        resolve();\r\n                    } else if (e.data.type === 'collisions') {\r\n                        if (this.onCollision) {\r\n                            this.onCollision(e.data.collisions);\r\n                        }\r\n                    }\r\n                };\r\n                worker.addEventListener('message', handler);\r\n\r\n                worker.postMessage({\r\n                    type: 'step',\r\n                    count,\r\n                    dt\r\n                });\r\n            })\r\n        )).then(() => {\r\n            this.pendingReject = null;\r\n        });\r\n\r\n        // Allow external rejection (termination)\r\n        return new Promise<void>((resolve, reject) => {\r\n            this.pendingReject = reject;\r\n            stepPromise.then(resolve).catch(reject);\r\n        });\r\n    }\r\n\r\n    public calculateEnergy(count: number): Promise<number> {\r\n        if (!this.isSupported || this.workers.length === 0) return Promise.resolve(0);\r\n\r\n        return new Promise((resolve) => {\r\n            const worker = this.workers[0]; // Only worker 0 computes energy\r\n            const handler = (e: MessageEvent) => {\r\n                if (e.data.type === 'energyResult') {\r\n                    worker.removeEventListener('message', handler);\r\n                    resolve(e.data.totalEnergy);\r\n                }\r\n            };\r\n            worker.addEventListener('message', handler);\r\n            worker.postMessage({ type: 'energy', count });\r\n        });\r\n    }\r\n\r\n    public terminate(): void {\r\n        if (this.pendingReject) {\r\n            this.pendingReject(new Error('WorkerManager terminated'));\r\n            this.pendingReject = null;\r\n        }\r\n        this.workers.forEach(w => w.terminate());\r\n        this.workers = [];\r\n        this.initialized = false;\r\n        this.initPromise = null;\r\n    }\r\n\r\n    public setBodies(bodies: any[]): void {\r\n        if (!this.isSupported) return;\r\n\r\n        const count = bodies.length;\r\n        if (count > this.maxBodies) {\r\n            console.error('Too many bodies for worker manager');\r\n            return;\r\n        }\r\n\r\n        for (let i = 0; i < count; i++) {\r\n            const body = bodies[i];\r\n            const i3 = i * 3;\r\n\r\n            this.positions[i3] = body.position.x;\r\n            this.positions[i3 + 1] = body.position.y;\r\n            this.positions[i3 + 2] = body.position.z;\r\n\r\n            this.velocities[i3] = body.velocity.x;\r\n            this.velocities[i3 + 1] = body.velocity.y;\r\n            this.velocities[i3 + 2] = body.velocity.z;\r\n\r\n            this.accelerations[i3] = 0;\r\n            this.accelerations[i3 + 1] = 0;\r\n            this.accelerations[i3 + 2] = 0;\r\n\r\n            this.masses[i] = body.mass;\r\n            this.radii[i] = body.radius;\r\n        }\r\n    }\r\n\r\n    public getPhysicsState(count: number): any {\r\n        return {\r\n            count,\r\n            maxCount: this.maxBodies,\r\n            positions: this.positions,\r\n            velocities: this.velocities,\r\n            accelerations: this.accelerations,\r\n            masses: this.masses,\r\n            radii: this.radii,\r\n            ids: [], // IDs not needed for calculation, handled by main thread map\r\n            idToIndex: new Map() // Dummy\r\n        };\r\n    }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\yngsw\\dev\\orbit-simulator\\src\\workers\\predictionWorker.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\yngsw\\dev\\orbit-simulator\\vite.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]